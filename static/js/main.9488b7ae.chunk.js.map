{"version":3,"sources":["utils/transactions.ts","contexts/ConnectionContext.tsx","utils/merkleTree.ts","utils/programIds.ts","components/DefaultModal/index.tsx","contexts/AccountContext.tsx","utils/eventEmitter.ts","components/Settings/index.tsx","contexts/ColorModeContext.tsx","utils/merkleDistributor.ts","utils/notifications.tsx","utils/borsh.ts","utils/ids.ts","components/Claim.tsx","contexts/WalletContext/WalletContext.tsx","contexts/WalletContext/wallet.less","contexts/ModalContext.tsx","utils/accounts.ts","components/Header/Header.tsx","components/Close.tsx","utils/communication.ts","components/DragAndDrop.tsx","components/Create.tsx","App.tsx","reportWebVitals.ts","index.tsx","constants/math.ts","utils/utils.ts","utils/claimant.ts"],"names":["getUnixTs","Date","getTime","envFor","connection","match","_rpcEndpoint","explorerLinkFor","txid","sendSignedTransaction","a","signedTransaction","timeout","rawTransaction","serialize","startTime","slot","sendRawTransaction","skipPreflight","log","debug","done","sleep","awaitTransactionSignatureConfirmation","confirmation","Error","err","error","simulateResult","simulateTransaction","value","logs","i","length","line","startsWith","slice","JSON","stringify","transaction","commitment","_recentBlockhash","_disableBlockhashCaching","recentBlockhash","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","args","encoding","_rpcRequest","res","message","result","queryStatus","status","confirmations","subId","Promise","resolve","reject","setTimeout","warn","onSignature","context","e","getSignatureStatuses","signatureStatuses","console","_signatureSubscriptions","removeSignatureListener","ENDPOINTS","name","endpoint","ChainId","MainnetBeta","Devnet","DEFAULT","ConnectionContext","React","createContext","setEndpoint","Connection","env","tokens","tokenMap","Map","ConnectionProvider","children","undefined","useLocalStorageState","useMemo","find","end","useState","setTokens","setTokenMap","useEffect","TokenListProvider","then","container","list","excludeByTag","filterByChainId","getList","knownMints","reduce","map","item","set","address","id","onAccountChange","Keypair","generate","publicKey","removeAccountChangeListener","onSlotChange","removeSlotChangeListener","Provider","useConnection","useContext","useConnectionConfig","SequenceType","getErrorForTransaction","confirmTransaction","getParsedConfirmedTransaction","tx","errors","meta","logMessages","forEach","m","regex","exec","index","lastIndex","push","sendTransactionWithRetry","wallet","instructions","signers","includesFeePayer","block","beforeSend","WalletNotConnectedError","Transaction","instruction","add","getRecentBlockhash","blockhash","setSigners","s","partialSign","signTransaction","MerkleTree","leafs","layers","this","hashes","nodeHash","acc","cur","idx","arr","nxt","internalHash","Array","proof","layer","sibling","Math","floor","getRoot","getProof","el","root","pair","equals","data","Buffer","from","keccak_256","digest","first","second","sort","compare","fst","snd","leaf","programIds","token","TOKEN_PROGRAM_ID","associatedToken","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","bpf_upgrade_loader","BPF_UPGRADE_LOADER_ID","system","SYSTEM","memo","MEMO_ID","DefaultModal","props","bodyStyle","closeIcon","width","rest","style","background","borderRadius","display","flexDirection","alignItems","footer","AccountsContext","pendingCalls","genericCache","pendingMintCalls","mintCache","getMintInfo","pubKey","getAccountInfo","info","deserializeMint","TokenAccountParser","buffer","deserializeAccount","pubkey","account","keyToAccountParser","cache","emitter","EventEmitter","query","parser","PublicKey","toBase58","get","obj","isActive","deserialize","registerParser","delete","Function","isNew","has","raiseCacheUpdated","key","raiseCacheDeleted","byParser","keys","queryMint","mint","getMint","addMint","UseNativeAccount","useWallet","nativeAccount","setNativeAccount","updateCache","useCallback","wrapped","WRAPPED_SOL_MINT","owner","amount","u64","lamports","delegate","delegatedAmount","isInitialized","isFrozen","isNative","rentExemptReserve","closeAuthority","wrapNativeAccount","updateAccount","PRECACHED_OWNERS","Set","precacheUserTokenAccounts","getTokenAccountsByOwner","programId","AccountsProvider","tokenAccounts","setTokenAccounts","userAccounts","setUserAccounts","walletKey","selectUserAccounts","filter","accounts","subs","onCache","tokenSubID","onProgramAccountChange","accountId","accountInfo","AccountLayout","span","removeProgramAccountChangeListener","decode","fromBuffer","delegateOption","state","isNativeOption","closeAuthorityOption","MintLayout","mintInfo","mintAuthorityOption","mintAuthority","supply","freezeAuthorityOption","freezeAuthority","CacheUpdateEvent","type","CacheDeleteEvent","MarketUpdateEvent","ids","Emitter","callback","on","removeListener","emit","Settings","additionalSettings","connected","disconnect","setVisible","useWalletModal","open","setModal","useModal","theme","useTheme","colorModeCtx","useColorMode","handleConnect","ModalEnum","WALLET","spacing","direction","sx","height","justifyContent","marginRight","marginBottom","onChange","target","variant","onClick","navigator","clipboard","writeText","notify","description","shortenAddress","color","catch","ml","toggleColorMode","palette","mode","ColorModeContext","ColorModeContextProvider","setMode","prevMode","idl","require","coder","Coder","placement","notification","opacity","backgroundColor","BinaryReader","prototype","readPubkey","array","readFixedArray","BinaryWriter","writePubkey","writeFixedArray","toBuffer","readPubkeyAsString","base58","encode","writePubkeyAsString","TOKEN_METADATA_PROGRAM_ID","CANDY_MACHINE_ID","GUMDROP_DISTRIBUTOR_ID","GUMDROP_TEMPORAL_SIGNER","walletKeyOrPda","handle","pin","seed","seeds","toArray","findProgramAddress","chunk","claimantPda","buildMintClaim","distributorKey","distributorInfo","tokenAcc","tokenAccKey","distTokenAccount","tokenAccountInfo","secret","pdaSeeds","BN","verifyClaim","claimStatus","cbump","walletTokenKey","setup","Token","createAssociatedTokenAccountInstruction","temporalSigner","temporal","default","claimAirdrop","TransactionInstruction","isSigner","isWritable","SystemProgram","sha256","concat","buildCandyClaim","candyConfig","candyUUID","configKey","claimCount","distributorWalletKey","wbump","claimCountAccount","nftsAlreadyMinted","claimAccountInfo","count","claimant","claimantStr","nftsAvailable","getCandyMachineAddress","candyMachineKey","getCandyMachine","candyMachine","candyMachineMints","buildSingleCandyMint","instrs","candyMachineWallet","candyMachineMint","getMetadata","candyMachineMetadata","getEdition","candyMachineMaster","createMintAndAccount","SYSVAR_RENT_PUBKEY","SYSVAR_CLOCK_PUBKEY","getMinimumBalanceForRentExemption","fromPubkey","newAccountPubkey","space","createAccount","createInitMintInstruction","createMintToInstruction","buildEditionClaim","masterMint","edition","masterMintKey","newMint","newMetadataKey","masterMetadataKey","newEdition","masterEdition","distributorTokenKey","getEditionMarkerPda","editionMarkKey","fetchDistributor","distributorStr","ownerStr","fetchNeedsTemporalSigner","indexStr","claimMethod","Number","Claim","params","queryString","parse","location","search","distributor","setDistributor","config","master","setClaimMethod","setTokenAcc","setCandyConfig","uuid","setCandyUUID","setMasterMint","editionStr","setEditionStr","setHandle","amountStr","setAmount","setIndex","pinStr","setPin","proofStr","setProof","allFieldsPopulated","editable","setEditable","setTransaction","OTPStr","setOTPStr","asyncNeedsTemporalSigner","setNeedsTemporalSigner","wrap","lambdaAPIEndpoint","sendOTP","preventDefault","isNaN","split","b","ret","bs58","extraSigners","feePayer","instr","signatures","some","method","headers","body","fetch","response","json","MessageId","verifyOTP","OTP","FunctionName","otp","blob","sig","addSignature","fullySigned","claimResult","href","loading","setLoading","loadingProgress","size","position","top","left","marginTop","marginLeft","claimData","Fragment","label","disabled","steps","inner","fullWidth","labelId","textAlign","multiline","needsTemporalSigner","activeStep","setActiveStep","stepToUse","min","stepper","prev","WalletModalContext","WalletModal","wallets","selected","select","visible","setShowWallets","close","onCancel","verticalAlign","fontWeight","fontSize","lineHeight","icon","alt","src","float","WalletModalProvider","setConnected","keyToDisplay","substring","WalletProvider","getPhantomWallet","getSolflareWallet","getTorusWallet","options","clientId","uxMode","redirectUrl","getLedgerWallet","getSolongWallet","getMathWallet","getSolletWallet","onError","Object","getOwnPropertyNames","autoConnect","ModalContext","removeModal","mintKey","mintAccount","mintOwner","getCreatorTokenAccount","totalClaim","creatorTokenKey","creatorTokenAccount","creatorTokenInfo","toNumber","fetchCoder","anchor","fetchIdl","getCandyConfig","configAccount","candyMachineCoder","candyMachineAccount","editionPageNumber","div","String","Header","Box","bgcolor","overflow","minWidth","Stack","Link","underline","Button","flexGrow","Close","baseKey","setBaseKey","localStorage","getItem","submit","base","fromSecretKey","Uint8Array","closeGumdrop","closeResult","TextField","FormControl","InputLabel","Select","setItem","MenuItem","formatDropMessage","drop","html","url","text","subject","distributeAwsSes","auth","source","claimants","accessKeyId","secretAccessKey","client","SESv2Client","region","credentials","single","formatted","Destination","ToAddresses","Content","Simple","Subject","Data","Charset","Body","Html","FromEmailAddress","ListManagementOptions","ContactListName","TopicName","send","SendEmailCommand","messageId","responses","c","distributeManual","distributeWallet","urlAndHandleFor","DragAndDrop","dropRef","useRef","dragCounter","setDragCounter","dragging","setDragging","handleDrag","stopPropagation","handleDragIn","dataTransfer","items","handleDragOut","remainingDrags","handleDrop","files","clearData","node","current","addEventListener","removeEventListener","shade","ref","randomBytes","buf","window","crypto","getRandomValues","WHITESPACE","distribute","reactModal","renderModal","document","createElement","appendChild","destroyModal","ReactDOM","unmountComponentAtNode","removeChild","onSubmit","onDismiss","render","show","displayModal","finally","hideModal","resendOnlyRender","click","opt","hyperLinkData","encoded","encodeURIComponent","shouldSendRender","needsPin","claimInfo","limit","TableContainer","maxHeight","Table","TableHead","TableRow","TableCell","TableBody","border","component","scope","pow","decimals","secretKey","download","Create","setMint","filename","setFilename","setText","claimURLs","setClaimURLs","setResponses","otpAuth","setOtpAuth","commMethod","setCommMethod","commAuth","setCommAuth","commSource","setCommSource","awsAccessKeyId","setAwsAccessKeyId","awsSecretKey","setAwsSecretKey","distributeClaims","parseClaimants","dropInfo","dropInfoFor","mightHaveExisting","resendOnly","validateTransferClaims","validateCandyClaims","validateEditionClaims","buildGumdrop","origin","pathname","createResult","handleFiles","file","reader","FileReader","onload","readAsText","fileUpload","alignContent","padding","hidden","createAirdrop","CircularProgress","otpAuthC","rel","commAuthorization","About","to","getWindowDimensions","innerWidth","innerHeight","App","createTheme","windowDimensions","setWindowDimensions","handleResize","useWindowDimensions","className","ThemeProvider","CssBaseline","path","reportWebVitals","onPerfEntry","getCLS","getFID","getFCP","getLCP","getTTFB","StrictMode","getElementById","TEN","Intl","NumberFormat","minimumFractionDigits","maximumFractionDigits","defaultState","storedState","setState","setLocalStorageState","newState","removeItem","chars","chunks","apply","ceil","_","currency","ms","input","extension","strData","objPattern","RegExp","arrMatches","arrData","replace","csvStringToArray","foundIdx","findIndex","includes","numbers","n","explorerUrlFor","integration","tokenMint","mintStr","total","candyUuid","remaining","itemsAvailable","itemsRedeemed","authority","getIndex","offsetFromStart","getOffsetFromRight","sub","mod","getIndexAndMask","getOffsetFromStart","mask","shln","editionTaken","marker","setEditionTaken","masterMintStr","masterTokenAccount","masterEditionKey","currentSupply","maxSupply","editions","editionMarkers","markerKey","markerData","pm","markerAcc","len","claimIntegration","host","extra","tree","dbump","verifyProof","join","createApproveInstruction","createTransferInstruction","extraKeys"],"mappings":"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","file":"static/js/main.9488b7ae.chunk.js","sourcesContent":["import {\n  Blockhash,\n  Commitment,\n  Connection,\n  FeeCalculator,\n  Keypair,\n  RpcResponseAndContext,\n  SignatureStatus,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n} from '@solana/web3.js';\nimport { sleep } from \"../utils/utils\";\nimport log from 'loglevel';\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport const DEFAULT_TIMEOUT = 15000;\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nexport const envFor = (\n  connection: Connection\n) : string => {\n  const endpoint = (connection as any)._rpcEndpoint;\n  const regex = /https:\\/\\/api.([^.]*).solana.com/;\n  const match = endpoint.match(regex);\n  if (match[1]) {\n    return match[1];\n  }\n  return \"mainnet-beta\";\n}\n\nexport const explorerLinkFor = (\n  txid: TransactionSignature,\n  connection: Connection\n) : string => {\n  return `https://explorer.solana.com/tx/${txid}?cluster=${envFor(connection)}`;\n}\n\nexport const sendTransactionWithRetryWithKeypair = async (\n  connection: Connection,\n  wallet: Keypair,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void,\n) => {\n  const transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.sign(...[wallet, ...signers]);\n  } else {\n    transaction.sign(wallet);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const { txid, slot } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction,\n  });\n\n  return { txid, slot };\n};\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    },\n  );\n\n  log.debug('Started awaiting confirmation for', txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      'confirmed',\n      true,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      log.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err) {\n    log.error('Timeout Error caught', err);\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, 'single')\n      ).value;\n    } catch (e) {\n      log.error('Simulate Transaction error', e);\n    }\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith('Program log: ')) {\n            throw new Error(\n              'Transaction failed: ' + line.slice('Program log: '.length),\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  log.debug('Latency (ms)', txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment,\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching,\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config: any = { encoding: 'base64', commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest('simulateTransaction', args);\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n  return res.result;\n}\n\nexport async function awaitTransactionSignatureConfirmation(\n  txid: TransactionSignature,\n  timeout: number,\n  connection: Connection,\n  commitment: Commitment = 'recent',\n  queryStatus = false,\n): Promise<SignatureStatus | null | void> {\n  let done = false;\n  let status: SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  // eslint-disable-next-line no-async-promise-executor\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      log.warn('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            log.warn('Rejected via websocket', result.err);\n            reject(status);\n          } else {\n            log.debug('Resolved via websocket', result);\n            resolve(status);\n          }\n        },\n        commitment,\n      );\n    } catch (e) {\n      done = true;\n      log.error('WS error in setup', txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          console.log(explorerLinkFor(txid, connection));\n          if (!done) {\n            if (!status) {\n              log.debug('REST null result for', txid, status);\n            } else if (status.err) {\n              log.error('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              log.error('REST no confirmations for', txid, status);\n            } else {\n              log.debug('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            log.error('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  log.debug('Returning status', status);\n  return status;\n}\n","import { useLocalStorageState } from \"../utils/utils\";\nimport {\n  Keypair,\n  Commitment,\n  Connection,\n  Transaction,\n  TransactionInstruction,\n  Blockhash,\n  FeeCalculator,\n} from \"@solana/web3.js\";\nimport React, { useContext, useEffect, useMemo, useState } from \"react\";\nimport {\n  sendSignedTransaction,\n} from \"../utils/transactions\";\nimport {\n  TokenInfo,\n  TokenListProvider,\n  ENV as ChainId,\n} from \"@solana/spl-token-registry\";\nimport { WalletSigner } from \"./WalletContext/WalletContext\";\nimport { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport type ENV = \"mainnet-beta\" | \"testnet\" | \"devnet\" | \"localnet\";\n\nexport const ENDPOINTS = [\n  {\n    name: \"mainnet-beta\" as ENV,\n    endpoint: \"https://api.mainnet-beta.solana.com\",\n    ChainId: ChainId.MainnetBeta,\n  },\n  {\n    name: \"devnet\" as ENV,\n    endpoint: \"https://api.devnet.solana.com\",\n    ChainId: ChainId.Devnet,\n  },\n];\n\nconst DEFAULT = ENDPOINTS[0].endpoint;\n\ninterface ConnectionConfig {\n  connection: Connection;\n  endpoint: string;\n  env: ENV;\n  setEndpoint: (val: string) => void;\n  tokens: TokenInfo[];\n  tokenMap: Map<string, TokenInfo>;\n}\n\nconst ConnectionContext = React.createContext<ConnectionConfig>({\n  endpoint: DEFAULT,\n  setEndpoint: () => {},\n  connection: new Connection(DEFAULT, \"recent\"),\n  env: ENDPOINTS[0].name,\n  tokens: [],\n  tokenMap: new Map<string, TokenInfo>(),\n});\n\nexport function ConnectionProvider({ children = undefined as any }) {\n  const [endpoint, setEndpoint] = useLocalStorageState(\n    \"connectionEndpoint\",\n    ENDPOINTS[0].endpoint\n  );\n\n  const connection = useMemo(\n    () => new Connection(endpoint, \"recent\"),\n    [endpoint]\n  );\n\n  const env =\n    ENDPOINTS.find((end) => end.endpoint === endpoint)?.name ||\n    ENDPOINTS[0].name;\n\n  const [tokens, setTokens] = useState<TokenInfo[]>([]);\n  const [tokenMap, setTokenMap] = useState<Map<string, TokenInfo>>(new Map());\n  useEffect(() => {\n    // fetch token files\n    new TokenListProvider().resolve().then((container) => {\n      const list = container\n        .excludeByTag(\"nft\")\n        .filterByChainId(\n          ENDPOINTS.find((end) => end.endpoint === endpoint)?.ChainId ||\n            ChainId.MainnetBeta\n        )\n        .getList();\n\n      const knownMints = [...list].reduce((map, item) => {\n        map.set(item.address, item);\n        return map;\n      }, new Map<string, TokenInfo>());\n\n      setTokenMap(knownMints);\n      setTokens(list);\n    });\n  }, [env, endpoint]);\n\n  // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n  // This is a hack to prevent the list from every getting empty\n  useEffect(() => {\n    const id = connection.onAccountChange(\n      Keypair.generate().publicKey,\n      () => {}\n    );\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    const id = connection.onSlotChange(() => null);\n    return () => {\n      connection.removeSlotChangeListener(id);\n    };\n  }, [connection]);\n\n  return (\n    <ConnectionContext.Provider\n      value={{\n        endpoint,\n        setEndpoint,\n        connection,\n        tokens,\n        tokenMap,\n        env,\n      }}\n    >\n      {children}\n    </ConnectionContext.Provider>\n  );\n}\n\nexport function useConnection() {\n  return useContext(ConnectionContext).connection as Connection;\n}\n\nexport function useConnectionConfig() {\n  const context = useContext(ConnectionContext);\n  return {\n    endpoint: context.endpoint,\n    setEndpoint: context.setEndpoint,\n    env: context.env,\n    tokens: context.tokens,\n    tokenMap: context.tokenMap,\n  };\n}\n\nexport const getErrorForTransaction = async (\n  connection: Connection,\n  txid: string\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, \"max\");\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach((log) => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport enum SequenceType {\n  Sequential,\n  Parallel,\n  StopOnFailure,\n}\n\nexport const sendTransactionWithRetry = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = \"singleGossip\",\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void\n) : Promise<string| { txid: string; slot: number }> => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach((instruction) => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map((s) => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    try {\n      transaction = await wallet.signTransaction(transaction);\n    } catch {\n      return \"Failed to sign transaction\";\n    }\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n  console.log(\"About to send\");\n  try {\n    const { txid, slot } = await sendSignedTransaction({\n      connection,\n      signedTransaction: transaction,\n    });\n\n    return { txid, slot };\n  } catch (error) {\n    console.error(error);\n    return \"See console logs\";\n  }\n};\n\n","import { keccak_256 } from \"js-sha3\";\n\nexport class MerkleTree {\n  leafs: Array<Buffer>;\n  layers: Array<Array<Buffer>>;\n\n  constructor(leafs : Array<Buffer>) {\n    this.leafs = leafs.slice();\n    this.layers = [];\n\n    let hashes = this.leafs.map(MerkleTree.nodeHash);\n    while (hashes.length > 0) {\n      console.log(\"Hashes\", this.layers.length, hashes);\n      this.layers.push(hashes.slice());\n      if (hashes.length === 1) break;\n      hashes = hashes.reduce((acc, cur, idx, arr) => {\n        if (idx % 2 === 0) {\n          const nxt = arr[idx + 1];\n          acc.push(MerkleTree.internalHash(cur, nxt));\n        }\n        return acc;\n      }, Array<Buffer>());\n    }\n  }\n\n  static nodeHash(\n    data : Buffer,\n  ) : Buffer {\n    return Buffer.from(keccak_256.digest([0x00, ...data]));\n  }\n\n\n  static internalHash(\n    first : Buffer,\n    second : Buffer | undefined,\n  ) : Buffer {\n    if (!second) return first;\n    const [fst, snd] = [first, second].sort(Buffer.compare)\n    return Buffer.from(\n      keccak_256.digest([0x01, ...fst, ...snd])\n    );\n  }\n\n  getRoot() : Buffer {\n    return this.layers[this.layers.length - 1][0];\n  }\n\n  getProof(idx : number) : Buffer[] {\n    return this.layers.reduce((proof, layer) => {\n      const sibling = idx ^ 1;\n      if (sibling < layer.length) {\n        proof.push(layer[sibling]);\n      }\n\n      idx = Math.floor(idx / 2);\n\n      return proof;\n    }, []);\n  }\n\n  getHexRoot(): string {\n    return this.getRoot().toString(\"hex\");\n  }\n\n  getHexProof(idx : number) : string[] {\n    return this.getProof(idx).map((el) => el.toString(\"hex\"));\n  }\n\n  verifyProof(\n    idx : number,\n    proof : Buffer[],\n    root : Buffer\n  ): boolean {\n    let pair = MerkleTree.nodeHash(this.leafs[idx]);\n    for (const item of proof) {\n      pair = MerkleTree.internalHash(pair, item);\n    }\n\n    return pair.equals(root);\n  }\n\n  static verifyClaim(\n    leaf : Buffer,\n    proof : Buffer[],\n    root : Buffer\n  ): boolean {\n    let pair = MerkleTree.nodeHash(leaf);\n    for (const item of proof) {\n      pair = MerkleTree.internalHash(pair, item);\n    }\n\n    return pair.equals(root);\n  }\n\n}\n","import {\n  TOKEN_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  BPF_UPGRADE_LOADER_ID,\n  SYSTEM,\n  MEMO_ID,\n} from './ids';\n\nexport const setProgramIds = async () => {};\n\nexport const programIds = () => {\n  return {\n    token: TOKEN_PROGRAM_ID,\n    associatedToken: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    bpf_upgrade_loader: BPF_UPGRADE_LOADER_ID,\n    system: SYSTEM,\n    memo: MEMO_ID,\n    // store: STORE,\n  };\n};\n","import React from \"react\";\nimport { Modal } from \"antd\";\n\nimport \"./index.css\";\n\nexport const DefaultModal = (props: any) => {\n  const { children, closeIcon, bodyStyle, width, style, ...rest } = props;\n\n  return (\n    <Modal\n      style={{ background: \"transparent\", borderRadius: 16 }}\n      bodyStyle={{\n        background: \"#333333\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        ...bodyStyle,\n      }}\n      footer={null}\n      width={\n        width || 400\n      }\n      {...rest}\n    >\n      {children}\n    </Modal>\n  );\n};\n","import React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useState,\n} from 'react';\nimport { useConnection } from './ConnectionContext';\nimport { useWallet } from '@solana/wallet-adapter-react';\nimport { AccountInfo, Connection, PublicKey } from '@solana/web3.js';\nimport { AccountLayout, MintInfo, MintLayout, u64 } from '@solana/spl-token';\nimport { TokenAccount } from '../models';\nimport { chunks } from '../utils/utils';\nimport { EventEmitter } from '../utils/eventEmitter';\nimport { StringPublicKey, WRAPPED_SOL_MINT } from '../utils/ids';\nimport { programIds } from '../utils/programIds';\n\nconst AccountsContext = React.createContext<any>(null);\n\nconst pendingCalls = new Map<string, Promise<ParsedAccountBase>>();\nconst genericCache = new Map<string, ParsedAccountBase>();\nconst pendingMintCalls = new Map<string, Promise<MintInfo>>();\nconst mintCache = new Map<string, MintInfo>();\n\nexport interface ParsedAccountBase {\n  pubkey: StringPublicKey;\n  account: AccountInfo<Buffer>;\n  info: any; // TODO: change to unknown\n}\n\nexport type AccountParser = (\n  pubkey: StringPublicKey,\n  data: AccountInfo<Buffer>,\n) => ParsedAccountBase | undefined;\n\nexport interface ParsedAccount<T> extends ParsedAccountBase {\n  info: T;\n}\n\nconst getMintInfo = async (connection: Connection, pubKey: PublicKey) => {\n  const info = await connection.getAccountInfo(pubKey);\n  if (info === null) {\n    throw new Error('Failed to find mint account');\n  }\n\n  const data = Buffer.from(info.data);\n\n  return deserializeMint(data);\n};\n\nexport const MintParser = (pubKey: string, info: AccountInfo<Buffer>) => {\n  const buffer = Buffer.from(info.data);\n\n  const data = deserializeMint(buffer);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: data,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const TokenAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  // Sometimes a wrapped sol account gets closed, goes to 0 length,\n  // triggers an update over wss which triggers this guy to get called\n  // since your UI already logged that pubkey as a token account. Check for length.\n  if (info.data.length > 0) {\n    const buffer = Buffer.from(info.data);\n    const data = deserializeAccount(buffer);\n\n    const details = {\n      pubkey: pubKey,\n      account: {\n        ...info,\n      },\n      info: data,\n    } as TokenAccount;\n\n    return details;\n  }\n};\n\nexport const GenericAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  const buffer = Buffer.from(info.data);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: buffer,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const keyToAccountParser = new Map<string, AccountParser>();\n\nexport const cache = {\n  emitter: new EventEmitter(),\n  query: async (\n    connection: Connection,\n    pubKey: string | PublicKey,\n    parser?: AccountParser,\n  ) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n\n    let account = genericCache.get(address);\n    if (account) {\n      return account;\n    }\n\n    let query = pendingCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    // TODO: refactor to use multiple accounts query with flush like behavior\n    query = connection.getAccountInfo(id).then(data => {\n      if (!data) {\n        throw new Error('Account not found');\n      }\n\n      return cache.add(id, data, parser);\n    }) as Promise<TokenAccount>;\n    pendingCalls.set(address, query as any);\n\n    return query;\n  },\n  add: (\n    id: PublicKey | string,\n    obj: AccountInfo<Buffer>,\n    parser?: AccountParser,\n    isActive?: boolean | undefined | ((parsed: any) => boolean),\n  ) => {\n    const address = typeof id === 'string' ? id : id?.toBase58();\n    const deserialize = parser ? parser : keyToAccountParser.get(address);\n    if (!deserialize) {\n      throw new Error(\n        'Deserializer needs to be registered or passed as a parameter',\n      );\n    }\n\n    cache.registerParser(id, deserialize);\n    pendingCalls.delete(address);\n    const account = deserialize(address, obj);\n    if (!account) {\n      return;\n    }\n\n    if (isActive === undefined) isActive = true;\n    else if (isActive instanceof Function) isActive = isActive(account);\n\n    const isNew = !genericCache.has(address);\n\n    genericCache.set(address, account);\n    cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);\n    return account;\n  },\n  get: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return genericCache.get(key);\n  },\n  delete: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    if (genericCache.get(key)) {\n      genericCache.delete(key);\n      cache.emitter.raiseCacheDeleted(key);\n      return true;\n    }\n    return false;\n  },\n\n  byParser: (parser: AccountParser) => {\n    const result: string[] = [];\n    for (const id of keyToAccountParser.keys()) {\n      if (keyToAccountParser.get(id) === parser) {\n        result.push(id);\n      }\n    }\n\n    return result;\n  },\n  registerParser: (pubkey: PublicKey | string, parser: AccountParser) => {\n    if (pubkey) {\n      const address = typeof pubkey === 'string' ? pubkey : pubkey?.toBase58();\n      keyToAccountParser.set(address, parser);\n    }\n\n    return pubkey;\n  },\n  queryMint: async (connection: Connection, pubKey: string | PublicKey) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    let mint = mintCache.get(address);\n    if (mint) {\n      return mint;\n    }\n\n    let query = pendingMintCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    query = getMintInfo(connection, id).then(data => {\n      pendingMintCalls.delete(address);\n\n      mintCache.set(address, data);\n      return data;\n    }) as Promise<MintInfo>;\n    pendingMintCalls.set(address, query as any);\n\n    return query;\n  },\n  getMint: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return mintCache.get(key);\n  },\n  addMint: (pubKey: PublicKey, obj: AccountInfo<Buffer>) => {\n    const mint = deserializeMint(obj.data);\n    const id = pubKey.toBase58();\n    mintCache.set(id, mint);\n    return mint;\n  },\n};\n\nexport const useAccountsContext = () => {\n  const context = useContext(AccountsContext);\n\n  return context;\n};\n\nfunction wrapNativeAccount(\n  pubkey: string,\n  account?: AccountInfo<Buffer>,\n): TokenAccount | undefined {\n  if (!account) {\n    return undefined;\n  }\n\n  const key = new PublicKey(pubkey);\n\n  return {\n    pubkey: pubkey,\n    account,\n    info: {\n      address: key,\n      mint: WRAPPED_SOL_MINT,\n      owner: key,\n      amount: new u64(account.lamports),\n      delegate: null,\n      delegatedAmount: new u64(0),\n      isInitialized: true,\n      isFrozen: false,\n      isNative: true,\n      rentExemptReserve: null,\n      closeAuthority: null,\n    },\n  };\n}\n\nexport const getCachedAccount = (\n  predicate: (account: TokenAccount) => boolean,\n) => {\n  for (const account of genericCache.values()) {\n    if (predicate(account)) {\n      return account as TokenAccount;\n    }\n  }\n};\n\nconst UseNativeAccount = () => {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n\n  const [nativeAccount, setNativeAccount] = useState<AccountInfo<Buffer>>();\n\n  const updateCache = useCallback(\n    account => {\n      if (publicKey) {\n        const wrapped = wrapNativeAccount(publicKey.toBase58(), account);\n        if (wrapped !== undefined) {\n          const id = publicKey.toBase58();\n          cache.registerParser(id, TokenAccountParser);\n          genericCache.set(id, wrapped as TokenAccount);\n          cache.emitter.raiseCacheUpdated(id, false, TokenAccountParser, true);\n        }\n      }\n    },\n    [publicKey],\n  );\n\n  useEffect(() => {\n    let subId = 0;\n    const updateAccount = (account: AccountInfo<Buffer> | null) => {\n      if (account) {\n        updateCache(account);\n        setNativeAccount(account);\n      }\n    };\n\n    (async () => {\n      if (!connection || !publicKey) {\n        return;\n      }\n\n      try {\n        const account = await connection.getAccountInfo(publicKey);\n        updateAccount(account);\n      } catch {\n        return;\n      }\n\n      subId = connection.onAccountChange(publicKey, updateAccount);\n    })();\n\n    return () => {\n      if (subId) {\n        connection.removeAccountChangeListener(subId);\n      }\n    };\n  }, [setNativeAccount, publicKey, connection, updateCache]);\n\n  return { nativeAccount };\n};\n\nconst PRECACHED_OWNERS = new Set<string>();\nconst precacheUserTokenAccounts = async (\n  connection: Connection,\n  owner?: PublicKey,\n) => {\n  if (!owner) {\n    return;\n  }\n\n  // used for filtering account updates over websocket\n  PRECACHED_OWNERS.add(owner.toBase58());\n\n  // user accounts are updated via ws subscription\n  const accounts = await connection.getTokenAccountsByOwner(owner, {\n    programId: programIds().token,\n  });\n\n  accounts.value.forEach(info => {\n    cache.add(info.pubkey.toBase58(), info.account, TokenAccountParser);\n  });\n};\n\nexport function AccountsProvider({ children = null as any }) {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n  const [tokenAccounts, setTokenAccounts] = useState<TokenAccount[]>([]);\n  const [userAccounts, setUserAccounts] = useState<TokenAccount[]>([]);\n  const { nativeAccount } = UseNativeAccount();\n  const walletKey = publicKey?.toBase58();\n\n  const selectUserAccounts = useCallback(() => {\n    return cache\n      .byParser(TokenAccountParser)\n      .map(id => cache.get(id))\n      .filter(a => a && a.info.owner.toBase58() === walletKey)\n      .map(a => a as TokenAccount);\n  }, [walletKey]);\n\n  useEffect(() => {\n    const accounts = selectUserAccounts().filter(\n      a => a !== undefined,\n    ) as TokenAccount[];\n    setUserAccounts(accounts);\n  }, [nativeAccount, tokenAccounts, selectUserAccounts]);\n\n  useEffect(() => {\n    const subs: number[] = [];\n    cache.emitter.onCache(args => {\n      if (args.isNew && args.isActive) {\n        let id = args.id;\n        let deserialize = args.parser;\n        connection.onAccountChange(new PublicKey(id), info => {\n          cache.add(id, info, deserialize);\n        });\n      }\n    });\n\n    return () => {\n      subs.forEach(id => connection.removeAccountChangeListener(id));\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    if (!connection || !publicKey) {\n      setTokenAccounts([]);\n    } else {\n      precacheUserTokenAccounts(connection, publicKey).then(() => {\n        setTokenAccounts(selectUserAccounts());\n      });\n\n      // This can return different types of accounts: token-account, mint, multisig\n      // TODO: web3.js expose ability to filter.\n      // this should use only filter syntax to only get accounts that are owned by user\n      const tokenSubID = connection.onProgramAccountChange(\n        programIds().token,\n        info => {\n          // TODO: fix type in web3.js\n          const id = info.accountId as unknown as string;\n          // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\n          if (info.accountInfo.data.length === AccountLayout.span) {\n            const data = deserializeAccount(info.accountInfo.data);\n\n            if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\n              cache.add(id, info.accountInfo, TokenAccountParser);\n              setTokenAccounts(selectUserAccounts());\n            }\n          }\n        },\n        'singleGossip',\n      );\n\n      return () => {\n        connection.removeProgramAccountChangeListener(tokenSubID);\n      };\n    }\n  }, [connection, publicKey, selectUserAccounts]);\n\n  return (\n    <AccountsContext.Provider\n      value={{\n        userAccounts,\n        nativeAccount,\n      }}\n    >\n      {children}\n    </AccountsContext.Provider>\n  );\n}\n\nexport function useNativeAccount() {\n  const context = useContext(AccountsContext);\n  return {\n    account: context.nativeAccount as AccountInfo<Buffer>,\n  };\n}\n\nexport const getMultipleAccounts = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const result = await Promise.all(\n    chunks(keys, 99).map(chunk =>\n      getMultipleAccountsCore(connection, chunk, commitment),\n    ),\n  );\n\n  const array = result\n    .map(\n      a =>\n        a.array.map(acc => {\n          if (!acc) {\n            return undefined;\n          }\n\n          const { data, ...rest } = acc;\n          const obj = {\n            ...rest,\n            data: Buffer.from(data[0], 'base64'),\n          } as AccountInfo<Buffer>;\n          return obj;\n        }) as AccountInfo<Buffer>[],\n    )\n    .flat();\n  return { keys, array };\n};\n\nconst getMultipleAccountsCore = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const args = connection._buildArgs([keys], commitment, 'base64');\n\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\n  if (unsafeRes.error) {\n    throw new Error(\n      'failed to get info about account ' + unsafeRes.error.message,\n    );\n  }\n\n  if (unsafeRes.result.value) {\n    const array = unsafeRes.result.value as AccountInfo<string[]>[];\n    return { keys, array };\n  }\n\n  // TODO: fix\n  throw new Error();\n};\n\nexport function useMint(key?: string | PublicKey) {\n  const connection = useConnection();\n  const [mint, setMint] = useState<MintInfo>();\n\n  const id = typeof key === 'string' ? key : key?.toBase58();\n\n  useEffect(() => {\n    if (!id) {\n      return;\n    }\n\n    cache\n      .query(connection, id, MintParser)\n      .then(acc => setMint(acc.info as any))\n      .catch(err => console.log(err));\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === id) {\n        cache\n          .query(connection, id, MintParser)\n          .then(mint => setMint(mint.info as any));\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, id]);\n\n  return mint;\n}\n\nexport function useAccount(pubKey?: PublicKey) {\n  const connection = useConnection();\n  const [account, setAccount] = useState<TokenAccount>();\n\n  const key = pubKey?.toBase58();\n  useEffect(() => {\n    const query = async () => {\n      try {\n        if (!key) {\n          return;\n        }\n\n        const acc = await cache\n          .query(connection, key, TokenAccountParser)\n          .catch(err => console.log(err));\n        if (acc) {\n          setAccount(acc);\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    query();\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === key) {\n        query();\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, key]);\n\n  return account;\n}\n\n// TODO: expose in spl package\nexport const deserializeAccount = (data: Buffer) => {\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n};\n\n// TODO: expose in spl package\nexport const deserializeMint = (data: Buffer) => {\n  if (data.length !== MintLayout.span) {\n    throw new Error('Not a valid Mint');\n  }\n\n  const mintInfo = MintLayout.decode(data);\n\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n\n  return mintInfo as MintInfo;\n};\n","import { EventEmitter as Emitter } from 'eventemitter3';\n\nexport class CacheUpdateEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  parser: any;\n  isNew: boolean;\n  isActive: boolean;\n  constructor(id: string, isNew: boolean, parser: any, isActive: boolean) {\n    this.id = id;\n    this.parser = parser;\n    this.isNew = isNew;\n    this.isActive = isActive;\n  }\n}\n\nexport class CacheDeleteEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  constructor(id: string) {\n    this.id = id;\n  }\n}\n\nexport class MarketUpdateEvent {\n  static type = 'MarketUpdate';\n  ids: Set<string>;\n  constructor(ids: Set<string>) {\n    this.ids = ids;\n  }\n}\n\nexport class EventEmitter {\n  private emitter = new Emitter();\n\n  onMarket(callback: (args: MarketUpdateEvent) => void) {\n    this.emitter.on(MarketUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(MarketUpdateEvent.type, callback);\n  }\n\n  onCache(callback: (args: CacheUpdateEvent) => void) {\n    this.emitter.on(CacheUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(CacheUpdateEvent.type, callback);\n  }\n\n  raiseMarketUpdated(ids: Set<string>) {\n    this.emitter.emit(MarketUpdateEvent.type, new MarketUpdateEvent(ids));\n  }\n\n  raiseCacheUpdated(\n    id: string,\n    isNew: boolean,\n    parser: any,\n    isActive: boolean,\n  ) {\n    this.emitter.emit(\n      CacheUpdateEvent.type,\n      new CacheUpdateEvent(id, isNew, parser, isActive),\n    );\n  }\n\n  raiseCacheDeleted(id: string) {\n    this.emitter.emit(CacheDeleteEvent.type, new CacheDeleteEvent(id));\n  }\n}\n","import { useCallback } from \"react\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { ENDPOINTS, useColorMode, useConnectionConfig } from \"../../contexts\";\nimport { notify, shortenAddress } from \"../../utils\";\nimport { CopyOutlined } from \"@ant-design/icons\";\nimport { ModalEnum, useModal, useWalletModal } from \"../../contexts\";\nimport {\n  Button,\n  FormControl,\n  NativeSelect,\n  Stack,\n} from \"@mui/material\";\nimport { useTheme } from \"@mui/material/styles\";\nimport IconButton from \"@mui/material/IconButton\";\nimport Brightness4Icon from \"@mui/icons-material/Brightness4\";\nimport Brightness7Icon from \"@mui/icons-material/Brightness7\";\n\nexport const Settings = ({\n  additionalSettings,\n}: {\n  additionalSettings?: JSX.Element;\n}) => {\n  const { connected, disconnect, publicKey } = useWallet();\n  const { setEndpoint, env, endpoint } = useConnectionConfig();\n  const { setVisible } = useWalletModal();\n  const open = useCallback(() => setVisible(true), [setVisible]);\n  const { setModal } = useModal();\n  const theme = useTheme();\n  const colorModeCtx = useColorMode();\n\n  const handleConnect = useCallback(() => {\n    setModal(ModalEnum.WALLET);\n    setVisible(true);\n  }, [setModal, setVisible]);\n\n  return (\n    <>\n      <Stack\n        spacing={2}\n        direction=\"row\"\n        sx={{\n          display: \"flex\",\n          height: \"62px\",\n          justifyContent: \"flex-end\",\n          alignItems: \"center\",\n          marginRight: \"36px\",\n        }}\n      >\n        {!connected && (\n          <>\n            <FormControl>\n              <NativeSelect\n                style={{ marginBottom: 5 }}\n                onChange={(e) => {\n                  setEndpoint(e.target.value);\n                }}\n                value={endpoint}\n              >\n                {ENDPOINTS.map(({ name, endpoint }) => (\n                  <option key={name} value={endpoint}>{name}</option>\n                ))}\n              </NativeSelect>\n            </FormControl>\n            <Button\n              variant=\"contained\"\n              onClick={handleConnect}\n            >\n              Connect\n            </Button>\n          </>\n        )}\n        {connected && (\n          <>\n            {publicKey && (\n              <Button\n                variant=\"outlined\"\n                onClick={async () => {\n                  if (publicKey) {\n                    await navigator.clipboard.writeText(publicKey.toBase58());\n                    notify({\n                      message: \"Wallet update\",\n                      description: \"Address copied to clipboard\",\n                    });\n                  }\n                }}\n              >\n                <CopyOutlined />\n                {shortenAddress(publicKey.toBase58())}\n              </Button>\n            )}\n            <Button\n              variant=\"outlined\"\n              onClick={open}\n            >\n              Change{\"\\u00A0\"}Wallet\n            </Button>\n            <Button\n              variant=\"contained\"\n              color=\"error\"\n              onClick={() => disconnect().catch()}\n            >\n              Disconnect{\"\\u00A0\"}({env})\n            </Button>\n          </>\n        )}\n        <IconButton\n          sx={{ ml: 1 }}\n          onClick={colorModeCtx.toggleColorMode}\n          color=\"inherit\"\n        >\n          {theme.palette.mode === \"dark\" ? (\n            <Brightness7Icon />\n          ) : (\n            <Brightness4Icon />\n          )}\n        </IconButton>\n        {additionalSettings}\n      </Stack>\n    </>\n  );\n};\n","import { useTheme } from \"@mui/material\";\nimport React, { useContext } from \"react\";\n\nexport const ColorModeContext = React.createContext({});\n\nexport const ColorModeContextProvider = ({children=null as any }) => {\n  const [mode, setMode] = React.useState<'light' | 'dark'>('dark'); \n  const theme = useTheme();\n  const toggleColorMode = () => {\n    setMode((prevMode) => (prevMode === 'light' ? 'dark' : 'light'));\n  }\n  return (\n    <ColorModeContext.Provider\n      value={{\n        toggleColorMode,\n        mode,\n        theme,\n      }}\n    >\n      {children}\n    </ColorModeContext.Provider>\n  );\n};\n\nexport const useColorMode = (): any => {\n  const context = useContext(ColorModeContext);\n  return context;\n};\n","import {\n  Coder,\n} from \"@project-serum/anchor\"\n\nconst idl = require(\"./merkle_distributor.json\");\nexport const coder = new Coder(idl);\n\n","import React from 'react';\nimport { notification } from 'antd';\n// import Link from '../components/Link';\n\nexport function notify({\n  message = '',\n  description = undefined as any,\n  txid = '',\n  type = 'info',\n  placement = 'bottomLeft',\n}) {\n  if (txid) {\n    //   <Link\n    //     external\n    //     to={'https://explorer.solana.com/tx/' + txid}\n    //     style={{ color: '#0000ff' }}\n    //   >\n    //     View transaction {txid.slice(0, 8)}...{txid.slice(txid.length - 8)}\n    //   </Link>\n\n    description = <></>;\n  }\n  (notification as any)[type]({\n    message: <span style={{ color: 'black' }}>{message}</span>,\n    description: (\n      <span style={{ color: 'black', opacity: 0.5 }}>{description}</span>\n    ),\n    placement,\n    style: {\n      backgroundColor: 'white',\n    },\n  });\n}\n","import { PublicKey } from '@solana/web3.js';\nimport { BinaryReader, BinaryWriter } from 'borsh';\nimport base58 from 'bs58';\nimport { StringPublicKey } from './ids';\n\nexport const extendBorsh = () => {\n  (BinaryReader.prototype as any).readPubkey = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return new PublicKey(array);\n  };\n\n  (BinaryWriter.prototype as any).writePubkey = function (value: PublicKey) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(value.toBuffer());\n  };\n\n  (BinaryReader.prototype as any).readPubkeyAsString = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return base58.encode(array) as StringPublicKey;\n  };\n\n  (BinaryWriter.prototype as any).writePubkeyAsString = function (\n    value: StringPublicKey,\n  ) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(base58.decode(value));\n  };\n};\n\nextendBorsh();\n","import { PublicKey, AccountInfo } from '@solana/web3.js';\n\nexport type StringPublicKey = string;\n\nexport class LazyAccountInfoProxy<T> {\n  executable: boolean = false;\n  owner: StringPublicKey = '';\n  lamports: number = 0;\n\n  get data() {\n    //\n    return undefined as unknown as T;\n  }\n}\n\nexport interface LazyAccountInfo {\n  executable: boolean;\n  owner: StringPublicKey;\n  lamports: number;\n  data: [string, string];\n}\n\nconst PubKeysInternedMap = new Map<string, PublicKey>();\n\nexport const toPublicKey = (key: string | PublicKey) => {\n  if (typeof key !== 'string') {\n    return key;\n  }\n\n  let result = PubKeysInternedMap.get(key);\n  if (!result) {\n    result = new PublicKey(key);\n    PubKeysInternedMap.set(key, result);\n  }\n\n  return result;\n};\n\nexport interface PublicKeyStringAndAccount<T> {\n  pubkey: string;\n  account: AccountInfo<T>;\n}\n\nexport const WRAPPED_SOL_MINT = new PublicKey('So11111111111111111111111111111111111111112');\n\nexport const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n\nexport const BPF_UPGRADE_LOADER_ID = new PublicKey('BPFLoaderUpgradeab1e11111111111111111111111');\n\nexport const MEMO_ID = new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');\n\nexport const SYSTEM = new PublicKey('11111111111111111111111111111111');\n\nexport const TOKEN_METADATA_PROGRAM_ID = new PublicKey(\"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\");\n\nexport const CANDY_MACHINE_ID = new PublicKey('cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ');\n\nexport const GUMDROP_DISTRIBUTOR_ID = new PublicKey(\"561gX85SDR4hYF2L7P4LcvdXsWSxWuY7Z1yGgznPwSXG\");\n\nexport const GUMDROP_TEMPORAL_SIGNER = new PublicKey(\"MSv9H2sMceAzccBganUXwGq3GXgqYAstmZAbFDZYbAV\");\n\n","import React from \"react\";\nimport { RouteComponentProps, } from \"react-router-dom\";\nimport queryString from 'query-string';\n\nimport {\n  Box,\n  Button,\n  CircularProgress,\n  FormControl,\n  Link as HyperLink,\n  InputLabel,\n  MenuItem,\n  Select,\n  Stack,\n  Step,\n  StepLabel,\n  Stepper,\n  TextField,\n} from \"@mui/material\";\n\nimport {\n  useWallet,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  Connection as RPCConnection,\n  Keypair,\n  PublicKey,\n  SystemProgram,\n  SYSVAR_RENT_PUBKEY,\n  SYSVAR_CLOCK_PUBKEY,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport {\n  AccountLayout,\n  MintLayout,\n  Token,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport { sha256 } from \"js-sha256\";\nimport BN from 'bn.js';\nimport * as bs58 from \"bs58\";\n\nimport {\n  useConnection,\n} from \"../contexts\";\nimport {\n  CANDY_MACHINE_ID,\n  GUMDROP_DISTRIBUTOR_ID,\n  GUMDROP_TEMPORAL_SIGNER,\n  TOKEN_METADATA_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  getCandyMachine,\n  getCandyMachineAddress,\n  getEdition,\n  getEditionMarkerPda,\n  getMetadata,\n  notify,\n} from \"../utils\";\nimport { MerkleTree } from \"../utils/merkleTree\";\nimport {\n  explorerLinkFor,\n  sendSignedTransaction,\n} from \"../utils/transactions\";\nimport {\n  chunk,\n} from \"../utils/claimant\";\nimport { coder } from \"../utils/merkleDistributor\";\n\nconst walletKeyOrPda = async (\n  walletKey : PublicKey,\n  handle : string,\n  pin : BN | null,\n  seed : PublicKey,\n) : Promise<[PublicKey, Array<Buffer>]> => {\n  if (pin === null) {\n    try {\n      const key = new PublicKey(handle);\n      if (!key.equals(walletKey)) {\n        throw new Error(\"Claimant wallet handle does not match connected wallet\");\n      }\n      return [key, []];\n    } catch (err) {\n      throw new Error(`Invalid claimant wallet handle ${err}`);\n    }\n  } else {\n    const seeds = [\n      seed.toBuffer(),\n      Buffer.from(handle),\n      Buffer.from(pin.toArray(\"le\", 4)),\n    ];\n\n    const [claimantPda, ] = await PublicKey.findProgramAddress(\n      [\n        seeds[0],\n        ...chunk(seeds[1], 32),\n        seeds[2],\n      ],\n      GUMDROP_DISTRIBUTOR_ID\n    );\n    return [claimantPda, seeds];\n  }\n}\n\n\nconst buildMintClaim = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  distributorKey : PublicKey,\n  distributorInfo : any,\n  tokenAcc : string,\n  proof : Array<Buffer>,\n  handle : string,\n  amount : number,\n  index : number,\n  pin : BN | null,\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\n  let tokenAccKey: PublicKey;\n  try {\n    tokenAccKey = new PublicKey(tokenAcc);\n  } catch (err) {\n    throw new Error(`Invalid tokenAcc key ${err}`);\n  }\n  const distTokenAccount = await connection.getAccountInfo(tokenAccKey);\n  if (distTokenAccount === null) {\n    throw new Error(`Could not fetch distributor token account`);\n  }\n\n  const tokenAccountInfo = AccountLayout.decode(distTokenAccount.data);\n  const mint = new PublicKey(tokenAccountInfo.mint);\n\n  console.log(mint.toBase58());\n\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, mint);\n\n  // TODO: since it's in the PDA do we need it to be in the leaf?\n  const leaf = Buffer.from(\n    [...new BN(index).toArray(\"le\", 8),\n     ...secret.toBuffer(),\n     ...mint.toBuffer(),\n     ...new BN(amount).toArray(\"le\", 8),\n    ]\n  );\n\n  const matches = MerkleTree.verifyClaim(\n    leaf, proof, Buffer.from(distributorInfo.root)\n  );\n\n  if (!matches) {\n    throw new Error(\"Gumdrop merkle proof does not match\");\n  }\n\n  const [claimStatus, cbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"ClaimStatus\"),\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  const [walletTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      walletKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      mint.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n\n  const setup : Array<TransactionInstruction> = [];\n\n  if (await connection.getAccountInfo(walletTokenKey) === null) {\n    setup.push(Token.createAssociatedTokenAccountInstruction(\n        SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n        TOKEN_PROGRAM_ID,\n        mint,\n        walletTokenKey,\n        walletKey,\n        walletKey\n      ));\n  }\n\n  const temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\n      ? walletKey : distributorInfo.temporal;\n\n  const claimAirdrop = new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: distributorKey          , isSigner: false , isWritable: true  } ,\n          { pubkey: claimStatus             , isSigner: false , isWritable: true  } ,\n          { pubkey: tokenAccKey             , isSigner: false , isWritable: true  } ,\n          { pubkey: walletTokenKey          , isSigner: false , isWritable: true  } ,\n          { pubkey: temporalSigner          , isSigner: true  , isWritable: false } ,\n          { pubkey: walletKey               , isSigner: true  , isWritable: false } ,  // payer\n          { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_PROGRAM_ID        , isSigner: false , isWritable: false } ,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:claim\")).slice(0, 8),\n        ...new BN(cbump).toArray(\"le\", 1),\n        ...new BN(index).toArray(\"le\", 8),\n        ...new BN(amount).toArray(\"le\", 8),\n        ...secret.toBuffer(),\n        ...new BN(proof.length).toArray(\"le\", 4),\n        ...Buffer.concat(proof),\n      ])\n  })\n\n  return [[...setup, claimAirdrop], pdaSeeds, []];\n}\n\nconst buildCandyClaim = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  distributorKey : PublicKey,\n  distributorInfo : any,\n  candyConfig : string,\n  candyUUID : string,\n  proof : Array<Buffer>,\n  handle : string,\n  amount : number,\n  index : number,\n  pin : BN | null,\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\n\n  let configKey : PublicKey;\n  try {\n    configKey = new PublicKey(candyConfig);\n  } catch (err) {\n    throw new Error(`Invalid candy config key ${err}`);\n  }\n\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, configKey);\n\n  // TODO: since it's in the PDA do we need it to be in the leaf?\n  const leaf = Buffer.from(\n    [...new BN(index).toArray(\"le\", 8),\n     ...secret.toBuffer(),\n     ...configKey.toBuffer(),\n     ...new BN(amount).toArray(\"le\", 8),\n    ]\n  );\n\n  const matches = MerkleTree.verifyClaim(\n    leaf, proof, Buffer.from(distributorInfo.root)\n  );\n\n  if (!matches) {\n    throw new Error(\"Gumdrop merkle proof does not match\");\n  }\n\n  const [claimCount, cbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"ClaimCount\"),\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  const [distributorWalletKey, wbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"Wallet\"),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  // atm the contract has a special case for when the temporal key is defaulted\n  // (aka always passes temporal check)\n  // TODO: more flexible\n  let temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\n      ? walletKey : distributorInfo.temporal;\n\n  const setup : Array<TransactionInstruction> = [];\n\n  const claimCountAccount = await connection.getAccountInfo(claimCount);\n  let nftsAlreadyMinted = 0;\n  if (claimCountAccount === null) {\n  } else {\n    // TODO: subtract already minted?...\n    const claimAccountInfo = coder.accounts.decode(\n      \"ClaimCount\", claimCountAccount.data);\n    nftsAlreadyMinted = claimAccountInfo.count;\n    if (claimAccountInfo.claimant.equals(walletKey)) {\n      // we already proved this claim and verified the OTP once, contract knows\n      // that this wallet is OK\n      temporalSigner = walletKey;\n    } else {\n      // need to claim with the first wallet...\n      const claimantStr = claimAccountInfo.claimant.toBase58();\n      throw new Error(`This wallet does not match existing claimant ${claimantStr}`);\n    }\n  }\n\n  const nftsAvailable = amount;\n  if (nftsAlreadyMinted >= nftsAvailable) {\n    throw new Error(`Cannot mint another NFT. ${nftsAvailable} NFT(s) were originally allocated`\n      + (nftsAlreadyMinted > 0 ? ` and ${nftsAlreadyMinted} NFT(s) were already minted` : \"\"));\n  }\n\n\n  const [candyMachineKey, ] = await getCandyMachineAddress(configKey, candyUUID);\n  const candyMachine = await getCandyMachine(connection, candyMachineKey);\n  console.log(\"Candy Machine\", candyMachine);\n\n  const candyMachineMints : Array<Keypair> = [];\n\n  const [instrs, mint] = await buildSingleCandyMint(\n    connection,\n    walletKey,\n    distributorKey,\n    distributorWalletKey,\n    claimCount,\n    temporalSigner,\n    configKey,\n    candyMachineKey,\n    candyMachine.wallet,\n    Buffer.from([\n      ...new BN(wbump).toArray(\"le\", 1),\n      ...new BN(cbump).toArray(\"le\", 1),\n      ...new BN(index).toArray(\"le\", 8),\n      ...new BN(amount).toArray(\"le\", 8),\n      ...secret.toBuffer(),\n      ...new BN(proof.length).toArray(\"le\", 4),\n      ...Buffer.concat(proof),\n    ]),\n  );\n  candyMachineMints.push(mint);\n  setup.push(...instrs);\n\n  return [setup, pdaSeeds, candyMachineMints];\n}\n\nconst buildSingleCandyMint = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  distributorKey : PublicKey,\n  distributorWalletKey : PublicKey,\n  claimCount : PublicKey,\n  temporalSigner : PublicKey,\n  configKey : PublicKey,\n  candyMachineKey : PublicKey,\n  candyMachineWallet : PublicKey,\n  data : Buffer,\n) : Promise<[Array<TransactionInstruction>, Keypair]> => {\n  const candyMachineMint = Keypair.generate();\n  const candyMachineMetadata = await getMetadata(candyMachineMint.publicKey);\n  const candyMachineMaster = await getEdition(candyMachineMint.publicKey);\n\n  const setup : Array<TransactionInstruction> = [];\n  await createMintAndAccount(connection, walletKey, candyMachineMint.publicKey, setup);\n  setup.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: distributorKey            , isSigner: false , isWritable: true  } ,\n          { pubkey: distributorWalletKey      , isSigner: false , isWritable: true  } ,\n          { pubkey: claimCount                , isSigner: false , isWritable: true  } ,\n          { pubkey: temporalSigner            , isSigner: true  , isWritable: false } ,\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // payer\n\n          { pubkey: configKey                 , isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineKey           , isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineWallet        , isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineMint.publicKey, isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineMetadata      , isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineMaster        , isSigner: false , isWritable: true  } ,\n\n          { pubkey: SystemProgram.programId   , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_PROGRAM_ID          , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_METADATA_PROGRAM_ID , isSigner: false , isWritable: false } ,\n          { pubkey: CANDY_MACHINE_ID          , isSigner: false , isWritable: false } ,\n          { pubkey: SYSVAR_RENT_PUBKEY        , isSigner: false , isWritable: false } ,\n          { pubkey: SYSVAR_CLOCK_PUBKEY       , isSigner: false , isWritable: false } ,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:claim_candy\")).slice(0, 8),\n        ...data,\n      ])\n  }));\n\n  return [setup, candyMachineMint];\n}\n\nconst createMintAndAccount = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  mint : PublicKey,\n  setup : Array<TransactionInstruction>,\n) => {\n  const [walletTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      walletKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      mint.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n\n  setup.push(SystemProgram.createAccount({\n    fromPubkey: walletKey,\n    newAccountPubkey: mint,\n    space: MintLayout.span,\n    lamports:\n      await connection.getMinimumBalanceForRentExemption(\n        MintLayout.span,\n      ),\n    programId: TOKEN_PROGRAM_ID,\n  }));\n\n  setup.push(Token.createInitMintInstruction(\n    TOKEN_PROGRAM_ID,\n    mint,\n    0,\n    walletKey,\n    walletKey,\n  ));\n\n  setup.push(Token.createAssociatedTokenAccountInstruction(\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    mint,\n    walletTokenKey,\n    walletKey,\n    walletKey\n  ));\n\n  setup.push(Token.createMintToInstruction(\n    TOKEN_PROGRAM_ID,\n    mint,\n    walletTokenKey,\n    walletKey,\n    [],\n    1,\n  ));\n\n}\n\nconst buildEditionClaim = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  distributorKey : PublicKey,\n  distributorInfo : any,\n  masterMint : string,\n  edition : number,\n  proof : Array<Buffer>,\n  handle : string,\n  amount : number,\n  index : number,\n  pin : BN | null,\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\n\n  let masterMintKey : PublicKey;\n  try {\n    masterMintKey = new PublicKey(masterMint);\n  } catch (err) {\n    throw new Error(`Invalid master mint key ${err}`);\n  }\n\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, masterMintKey);\n\n  // should we assert that the amount is 1?\n  const leaf = Buffer.from(\n    [...new BN(index).toArray(\"le\", 8),\n     ...secret.toBuffer(),\n     ...masterMintKey.toBuffer(),\n     ...new BN(amount).toArray(\"le\", 8),\n     ...new BN(edition).toArray(\"le\", 8),\n    ]\n  );\n\n  const matches = MerkleTree.verifyClaim(\n    leaf, proof, Buffer.from(distributorInfo.root)\n  );\n\n  if (!matches) {\n    throw new Error(\"Gumdrop merkle proof does not match\");\n  }\n\n  const [claimCount, cbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"ClaimCount\"),\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  // atm the contract has a special case for when the temporal key is defaulted\n  // (aka always passes temporal check)\n  // TODO: more flexible\n  let temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\n      ? walletKey : distributorInfo.temporal;\n\n  const claimCountAccount = await connection.getAccountInfo(claimCount);\n  if (claimCountAccount !== null) {\n    throw new Error(`This edition was already claimed`);\n  }\n\n  const setup : Array<TransactionInstruction> = [];\n\n  const newMint = Keypair.generate();\n  const newMetadataKey = await getMetadata(newMint.publicKey);\n  const masterMetadataKey = await getMetadata(masterMintKey);\n  const newEdition = await getEdition(newMint.publicKey);\n  const masterEdition = await getEdition(masterMintKey);\n\n  await createMintAndAccount(connection, walletKey, newMint.publicKey, setup);\n\n  const [distributorTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      distributorKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      masterMintKey.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n\n  const editionMarkKey = await getEditionMarkerPda(masterMintKey, new BN(edition));\n\n  setup.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: distributorKey            , isSigner: false , isWritable: true  } ,\n          { pubkey: claimCount                , isSigner: false , isWritable: true  } ,\n          { pubkey: temporalSigner            , isSigner: true  , isWritable: false } ,\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // payer\n\n          { pubkey: newMetadataKey            , isSigner: false , isWritable: true  } ,\n          { pubkey: newEdition                , isSigner: false , isWritable: true  } ,\n          { pubkey: masterEdition             , isSigner: false , isWritable: true  } ,\n          { pubkey: newMint.publicKey         , isSigner: false , isWritable: true  } ,\n          { pubkey: editionMarkKey            , isSigner: false , isWritable: true  } ,\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // `newMint` auth\n          { pubkey: distributorTokenKey       , isSigner: false , isWritable: false } ,\n          { pubkey: walletKey                 , isSigner: false , isWritable: false } , // new update auth\n          { pubkey: masterMetadataKey         , isSigner: false , isWritable: false } ,\n          { pubkey: masterMintKey             , isSigner: false , isWritable: false } ,\n\n          { pubkey: SystemProgram.programId   , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_PROGRAM_ID          , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_METADATA_PROGRAM_ID , isSigner: false , isWritable: false } ,\n          { pubkey: SYSVAR_RENT_PUBKEY        , isSigner: false , isWritable: false } ,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:claim_edition\")).slice(0, 8),\n        ...new BN(cbump).toArray(\"le\", 1),\n        ...new BN(index).toArray(\"le\", 8),\n        ...new BN(amount).toArray(\"le\", 8),\n        ...new BN(edition).toArray(\"le\", 8),\n        ...secret.toBuffer(),\n        ...new BN(proof.length).toArray(\"le\", 4),\n        ...Buffer.concat(proof),\n      ])\n  }));\n\n  return [setup, pdaSeeds, [newMint]];\n}\n\nconst fetchDistributor = async (\n  connection : RPCConnection,\n  distributorStr : string,\n) => {\n  let key;\n  try {\n    key = new PublicKey(distributorStr);\n  } catch (err) {\n    throw new Error(`Invalid distributor key ${err}`);\n  }\n  const account = await connection.getAccountInfo(key);\n  if (account === null) {\n    throw new Error(`Could not fetch distributor ${distributorStr}`);\n  }\n  if (!account.owner.equals(GUMDROP_DISTRIBUTOR_ID)) {\n    const ownerStr = account.owner.toBase58();\n    throw new Error(`Invalid distributor owner ${ownerStr}`);\n  }\n  const info = coder.accounts.decode(\"MerkleDistributor\", account.data);\n  return [key, info];\n};\n\nconst fetchNeedsTemporalSigner = async (\n  connection : RPCConnection,\n  distributorStr : string,\n  indexStr : string,\n  claimMethod : string,\n) => {\n  const [key, info] = await fetchDistributor(connection, distributorStr);\n  if (!info.temporal.equals(GUMDROP_TEMPORAL_SIGNER)) {\n    // default pubkey or program itself (distribution through wallets)\n    return false;\n  } else if (claimMethod === \"candy\") {\n    const [claimCount, ] = await PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"ClaimCount\"),\n        Buffer.from(new BN(Number(indexStr)).toArray(\"le\", 8)),\n        key.toBuffer(),\n      ],\n      GUMDROP_DISTRIBUTOR_ID\n    );\n    // if someone (maybe us) has already claimed this, the contract will\n    // not check the existing temporal signer anymore since presumably\n    // they have already verified the OTP. So we need to fetch the temporal\n    // signer if it is null\n    const claimCountAccount = await connection.getAccountInfo(claimCount);\n    return claimCountAccount === null;\n  } else {\n    // default to need one\n    return true;\n  }\n};\n\nexport type ClaimProps = {};\n\nexport const Claim = (\n  props : RouteComponentProps<ClaimProps>,\n) => {\n  const connection = useConnection();\n  const wallet = useWallet();\n\n  let params = queryString.parse(props.location.search);\n  const [distributor, setDistributor] = React.useState(params.distributor as string || \"\");\n  const [claimMethod, setClaimMethod] = React.useState(\n        params.tokenAcc ? \"transfer\"\n      : params.config   ? \"candy\"\n      : params.master   ? \"edition\"\n      :                   \"\");\n  const [tokenAcc, setTokenAcc] = React.useState(params.tokenAcc as string || \"\");\n  const [candyConfig, setCandyConfig] = React.useState(params.config as string || \"\");\n  const [candyUUID, setCandyUUID] = React.useState(params.uuid as string || \"\");\n  const [masterMint, setMasterMint] = React.useState(params.master as string || \"\");\n  const [editionStr, setEditionStr] = React.useState(params.edition as string || \"\");\n  const [handle, setHandle] = React.useState(params.handle as string || \"\");\n  const [amountStr, setAmount] = React.useState(params.amount as string || \"\");\n  const [indexStr, setIndex] = React.useState(params.index as string || \"\");\n  const [pinStr, setPin] = React.useState(params.pin as string || \"\");\n  const [proofStr, setProof] = React.useState(params.proof as string || \"\");\n\n  const allFieldsPopulated =\n    distributor.length > 0\n    && ( claimMethod === \"transfer\" ? tokenAcc.length > 0\n       : claimMethod === \"candy\"    ? candyConfig.length > 0 && candyUUID.length > 0\n       : claimMethod === \"edition\"  ? masterMint.length > 0 && editionStr.length > 0\n       :                              false\n       )\n    && handle.length > 0\n    && amountStr.length > 0\n    && indexStr.length > 0;\n    // NB: pin can be empty if handle is a public-key and we are claiming through wallets\n    // NB: proof can be empty!\n\n  const [editable, setEditable] = React.useState(!allFieldsPopulated);\n\n  // temporal verification\n  const [transaction, setTransaction] = React.useState<Transaction | null>(null);\n  const [OTPStr, setOTPStr] = React.useState(\"\");\n\n  // async computed\n  const [asyncNeedsTemporalSigner, setNeedsTemporalSigner] = React.useState<boolean>(true);\n\n  React.useEffect(() => {\n    const wrap = async () => {\n      try {\n        setNeedsTemporalSigner(await fetchNeedsTemporalSigner(\n          connection, distributor, indexStr, claimMethod));\n      } catch {\n        // TODO: log?\n      }\n    };\n    wrap();\n  }, [connection, distributor, indexStr, claimMethod]);\n\n  const lambdaAPIEndpoint = \"https://n82bm4ts81.execute-api.us-east-2.amazonaws.com/send-OTP\";\n\n  const skipAWSWorkflow = false;\n\n  const sendOTP = async (e : React.SyntheticEvent) => {\n    e.preventDefault();\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const index = Number(indexStr);\n    const amount = Number(amountStr);\n    let pin : BN | null = null;\n\n    if (isNaN(amount)) {\n      throw new Error(`Could not parse amount ${amountStr}`);\n    }\n    if (isNaN(index)) {\n      throw new Error(`Could not parse index ${indexStr}`);\n    }\n    if (params.pin !== \"NA\") {\n      try {\n        pin = new BN(pinStr);\n      } catch (err) {\n        throw new Error(`Could not parse pin ${pinStr}: ${err}`);\n      }\n    }\n\n    // TODO: use cached?\n    const [distributorKey, distributorInfo] =\n        await fetchDistributor(connection, distributor);\n\n    console.log(\"Distributor\", distributorInfo);\n\n    const proof = proofStr === \"\" ? [] : proofStr.split(\",\").map(b => {\n      const ret = Buffer.from(bs58.decode(b))\n      if (ret.length !== 32)\n        throw new Error(`Invalid proof hash length`);\n      return ret;\n    });\n\n    let instructions, pdaSeeds, extraSigners;\n    if (claimMethod === \"candy\") {\n      console.log(\"Building candy claim\");\n      [instructions, pdaSeeds, extraSigners] = await buildCandyClaim(\n        connection, wallet.publicKey, distributorKey, distributorInfo,\n        candyConfig, candyUUID,\n        proof, handle, amount, index, pin\n      );\n    } else if (claimMethod === \"transfer\") {\n      [instructions, pdaSeeds, extraSigners] = await buildMintClaim(\n        connection, wallet.publicKey, distributorKey, distributorInfo,\n        tokenAcc,\n        proof, handle, amount, index, pin\n      );\n    } else if (claimMethod === \"edition\") {\n      const edition = Number(editionStr);\n      if (isNaN(edition)) {\n        throw new Error(`Could not parse edition ${editionStr}`);\n      }\n      [instructions, pdaSeeds, extraSigners] = await buildEditionClaim(\n        connection, wallet.publicKey, distributorKey, distributorInfo,\n        masterMint, edition,\n        proof, handle, amount, index, pin\n      );\n    } else {\n      throw new Error(`Unknown claim method ${claimMethod}`);\n    }\n\n    // NB: if we're claiming through wallets then pdaSeeds should be empty\n    // since the secret is the wallet key (which is also a signer)\n    if (pin === null && pdaSeeds.length > 0) {\n      throw new Error(`Internal error: PDA generated when distributing to wallet directly`);\n    }\n\n    let transaction = new Transaction({\n      feePayer: wallet.publicKey,\n      recentBlockhash: (await connection.getRecentBlockhash(\"singleGossip\")).blockhash,\n    });\n\n    const signers = new Set<PublicKey>();\n    for (const instr of instructions) {\n      transaction.add(instr);\n      for (const key of instr.keys)\n        if (key.isSigner)\n          signers.add(key.pubkey);\n    }\n    console.log(`Expecting the following signers: ${[...signers].map(s => s.toBase58())}`);\n    transaction.setSigners(...signers);\n\n    if (extraSigners.length > 0) {\n      transaction.partialSign(...extraSigners);\n    }\n\n    const txnNeedsTemporalSigner =\n        transaction.signatures.some(s => s.publicKey.equals(GUMDROP_TEMPORAL_SIGNER));\n    if (txnNeedsTemporalSigner && !skipAWSWorkflow) {\n      const params = {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          method: \"send\",\n          transaction: bs58.encode(transaction.serializeMessage()),\n          seeds: pdaSeeds,\n        }),\n      };\n\n      const response = await fetch(lambdaAPIEndpoint, params);\n      console.log(response);\n\n      if (response.status !== 200) {\n        throw new Error(`Failed to send AWS OTP`);\n      }\n\n      let data;\n      try {\n        data = await response.json();\n      } catch {\n        throw new Error(`Could not parse AWS OTP response`);\n      }\n\n      console.log(\"AWS OTP response data:\", data);\n\n      if (!data.MessageId) {\n        throw new Error(`Failed to send AWS OTP`);\n      }\n\n      notify({\n        message: \"OTP sent\",\n        description: `Please check ${handle} for a OTP`,\n      });\n    }\n\n    return transaction;\n  };\n\n  const verifyOTP = async (\n    e : React.SyntheticEvent,\n    transaction : Transaction | null,\n  ) => {\n    e.preventDefault();\n\n    if (!transaction) {\n      throw new Error(`Transaction not available for OTP verification`);\n    }\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const txnNeedsTemporalSigner =\n        transaction.signatures.some(s => s.publicKey.equals(GUMDROP_TEMPORAL_SIGNER));\n    if (txnNeedsTemporalSigner && !skipAWSWorkflow) {\n      // TODO: distinguish between OTP failure and transaction-error. We can try\n      // again on the former but not the latter\n      const OTP = Number(OTPStr);\n      if (isNaN(OTP) || OTPStr.length === 0) {\n        throw new Error(`Could not parse OTP ${OTPStr}`);\n      }\n\n      const params = {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        FunctionName: \"send-OTP\",\n        body: JSON.stringify({\n          method: \"verify\",\n          otp: OTP,\n          handle: handle,  // TODO?\n        }),\n      };\n\n      const response = await fetch(lambdaAPIEndpoint, params);\n      console.log(response);\n\n      if (response.status !== 200) {\n        const blob = JSON.stringify(response);\n        throw new Error(`Failed to verify AWS OTP. ${blob}`);\n      }\n\n      let data;\n      try {\n        data = await response.json();\n      } catch {\n        throw new Error(`Could not parse AWS OTP verification response`);\n      }\n\n      console.log(\"AWS verify response data:\", data);\n\n      let sig;\n      try {\n        sig = bs58.decode(data);\n      } catch {\n        throw new Error(`Could not decode transaction signature ${data.body}`);\n      }\n\n      transaction.addSignature(GUMDROP_TEMPORAL_SIGNER, sig);\n    }\n\n    let fullySigned;\n    try {\n      fullySigned = await wallet.signTransaction(transaction);\n    } catch {\n      throw new Error(\"Failed to sign transaction\");\n    }\n\n    const claimResult = await sendSignedTransaction({\n      connection,\n      signedTransaction: fullySigned,\n    });\n\n    console.log(claimResult);\n    notify({\n      message: \"Claim succeeded\",\n      description: (\n        <HyperLink href={explorerLinkFor(claimResult.txid, connection)}>\n          View transaction on explorer\n        </HyperLink>\n      ),\n    });\n    setTransaction(null);\n    try {\n      setNeedsTemporalSigner(await fetchNeedsTemporalSigner(\n        connection, distributor, indexStr, claimMethod));\n    } catch {\n      // TODO: log?\n    }\n  };\n\n  const [loading, setLoading] = React.useState(false);\n  const loadingProgress = () => (\n    <CircularProgress\n      size={24}\n      sx={{\n        position: 'absolute',\n        top: '50%',\n        left: '50%',\n        marginTop: '-12px',\n        marginLeft: '-12px',\n      }}\n    />\n  );\n\n  const verifyOTPC = (onClick) => (\n    <React.Fragment>\n      <TextField\n        style={{width: \"60ch\"}}\n        id=\"otp-text-field\"\n        label=\"OTP\"\n        value={OTPStr}\n        onChange={(e) => setOTPStr(e.target.value)}\n      />\n      <Box />\n\n      <Box sx={{ position: \"relative\" }}>\n      <Button\n        disabled={!wallet.connected || !OTPStr || loading}\n        variant=\"contained\"\n        color=\"success\"\n        style={{ width: \"100%\" }}\n        onClick={(e) => {\n          setLoading(true);\n          const wrap = async () => {\n            try {\n              await verifyOTP(e, transaction);\n              setLoading(false);\n              onClick();\n            } catch (err) {\n              notify({\n                message: \"Claim failed\",\n                description: `${err}`,\n              });\n              setLoading(false);\n            }\n          };\n          wrap();\n        }}\n      >\n        Claim Gumdrop\n      </Button>\n      {loading && loadingProgress()}\n      </Box>\n    </React.Fragment>\n  );\n\n  const claimData = (claimMethod) => {\n    if (claimMethod === \"candy\") {\n      return (\n        <React.Fragment>\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"config-text-field\"\n            label=\"Candy Config\"\n            value={candyConfig}\n            onChange={e => setCandyConfig(e.target.value)}\n            disabled={!editable}\n          />\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"config-uuid-text-field\"\n            label=\"Candy UUID\"\n            value={candyUUID}\n            onChange={e => setCandyUUID(e.target.value)}\n            disabled={!editable}\n          />\n        </React.Fragment>\n      );\n    } else if (claimMethod === \"transfer\") {\n      return (\n        <React.Fragment>\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"token-acc-text-field\"\n            label=\"Source Token Account\"\n            value={tokenAcc}\n            onChange={(e) => setTokenAcc(e.target.value)}\n            disabled={!editable}\n          />\n        </React.Fragment>\n      );\n    } else if (claimMethod === \"edition\") {\n      return (\n        <React.Fragment>\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"master-mint-text-field\"\n            label=\"Master Mint\"\n            value={masterMint}\n            onChange={(e) => setMasterMint(e.target.value)}\n            disabled={!editable}\n          />\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"edition-text-field\"\n            label=\"Edition\"\n            value={editionStr}\n            onChange={(e) => setEditionStr(e.target.value)}\n            disabled={!editable}\n          />\n        </React.Fragment>\n      );\n    }\n  };\n\n  const populateClaimC = (onClick) => (\n    <React.Fragment>\n      <TextField\n        style={{width: \"60ch\"}}\n        id=\"distributor-text-field\"\n        label=\"Distributor\"\n        value={distributor}\n        onChange={(e) => setDistributor(e.target.value)}\n        disabled={!editable}\n      />\n      <FormControl fullWidth>\n        <InputLabel\n          id=\"claim-method-label\"\n          disabled={!editable}\n        >\n          Claim Method\n        </InputLabel>\n        <Select\n          labelId=\"claim-method-label\"\n          id=\"claim-method-select\"\n          value={claimMethod}\n          label=\"Claim Method\"\n          onChange={(e) => { setClaimMethod(e.target.value); }}\n          style={{textAlign: \"left\"}}\n          disabled={!editable}\n        >\n          <MenuItem value={\"transfer\"}>Token Transfer</MenuItem>\n          <MenuItem value={\"candy\"}>Candy Machine</MenuItem>\n          <MenuItem value={\"edition\"}>Limited Edition</MenuItem>\n        </Select>\n      </FormControl>\n      {claimMethod !== \"\" && claimData(claimMethod)}\n      {claimMethod !== \"edition\" && <TextField\n        style={{width: \"60ch\"}}\n        id=\"amount-text-field\"\n        label=\"Amount\"\n        value={amountStr}\n        onChange={(e) => setAmount(e.target.value)}\n        disabled={!editable}\n      />}\n      <TextField\n        style={{width: \"60ch\"}}\n        id=\"handle-text-field\"\n        label=\"Handle\"\n        value={handle}\n        onChange={(e) => setHandle(e.target.value)}\n        disabled={!editable}\n      />\n      <TextField\n        style={{width: \"60ch\"}}\n        id=\"index-text-field\"\n        label=\"Index\"\n        value={indexStr}\n        onChange={(e) => setIndex(e.target.value)}\n        disabled={!editable}\n      />\n      {params.pin !== \"NA\" && <TextField\n        style={{width: \"60ch\"}}\n        id=\"pin-text-field\"\n        label=\"Pin\"\n        value={pinStr}\n        onChange={(e) => setPin(e.target.value)}\n        disabled={!editable}\n      />}\n      <TextField\n        style={{width: \"60ch\"}}\n        id=\"proof-text-field\"\n        label=\"Proof\"\n        multiline\n        value={proofStr}\n        onChange={(e) => setProof(e.target.value)}\n        disabled={!editable}\n      />\n      <Button\n        color=\"info\"\n        onClick={(e) => setEditable(!editable)}\n      >\n        {!editable ? \"Edit Claim\" : \"Stop Editing\"}\n      </Button>\n      <Box />\n\n      <Box sx={{ position: \"relative\" }}>\n      <Button\n        disabled={!wallet.connected || !allFieldsPopulated || loading}\n        variant=\"contained\"\n        style={{ width: \"100%\" }}\n        color={asyncNeedsTemporalSigner ? \"primary\" : \"success\"}\n        onClick={(e) => {\n          setLoading(true);\n          const wrap = async () => {\n            try {\n              const needsTemporalSigner = await fetchNeedsTemporalSigner(\n                  connection, distributor, indexStr, claimMethod);\n              const transaction = await sendOTP(e);\n              if (!needsTemporalSigner) {\n                await verifyOTP(e, transaction);\n              } else {\n                setTransaction(transaction);\n              }\n              setLoading(false);\n              onClick();\n            } catch (err) {\n              notify({\n                message: \"Claim failed\",\n                description: `${err}`,\n              });\n              setLoading(false);\n            }\n          };\n          wrap();\n        }}\n      >\n        {asyncNeedsTemporalSigner ? \"Next\" : \"Claim Gumdrop\"}\n      </Button>\n      {loading && loadingProgress()}\n      </Box>\n    </React.Fragment>\n  );\n\n  const steps = [\n    { name: \"Populate Claim\", inner: populateClaimC },\n  ];\n  if (asyncNeedsTemporalSigner) {\n    steps.push(\n    { name: \"Verify OTP\"    , inner: verifyOTPC     }\n    );\n  }\n\n  // TODO: better interaction between setting `asyncNeedsTemporalSigner` and\n  // the stepper... this is pretty jank\n  const [activeStep, setActiveStep] = React.useState(0);\n  const stepToUse = Math.min(activeStep, steps.length - 1);\n\n  const handleNext = () => {\n    // return to start if going past the end (claim succeeded)\n    setActiveStep(prev => {\n      if (prev === steps.length - 1) {\n        return 0;\n      } else {\n        return prev + 1;\n      }\n    });\n  };\n  const handleBack = () => {\n    setActiveStep(prev => prev - 1);\n  };\n\n  const stepper = (\n    <React.Fragment>\n      <Stepper activeStep={stepToUse}>\n        {steps.map((s, index) => {\n          return (\n            <Step key={s.name}>\n              <StepLabel>{s.name}</StepLabel>\n            </Step>\n          );\n        })}\n      </Stepper>\n      <Box />\n    </React.Fragment>\n  );\n\n  return (\n    <Stack spacing={2}>\n      {asyncNeedsTemporalSigner && stepper}\n      {steps[stepToUse].inner(handleNext)}\n      {stepToUse > 0 && (\n        <Button\n          color=\"info\"\n          onClick={handleBack}\n        >\n          Back\n        </Button>\n      )}\n    </Stack>\n  );\n};\n\n","import { WalletAdapter, WalletError } from \"@solana/wallet-adapter-base\";\nimport {\n  useWallet,\n  WalletProvider as BaseWalletProvider,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  getLedgerWallet,\n  getMathWallet,\n  getPhantomWallet,\n  getSolflareWallet,\n  getSolletWallet,\n  getSolongWallet,\n  getTorusWallet,\n} from \"@solana/wallet-adapter-wallets\";\nimport { Button } from \"antd\";\nimport React, {\n  createContext,\n  FC,\n  ReactNode,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\nimport { notify } from \"../../utils\";\nimport { DefaultModal } from \"../../components\";\n\nimport \"./wallet.less\";\n\nexport interface WalletModalContextState {\n  visible: boolean;\n  setVisible: (open: boolean) => void;\n}\n\nexport const WalletModalContext = createContext<WalletModalContextState>(\n  {} as WalletModalContextState\n);\n\nexport function useWalletModal(): WalletModalContextState {\n  return useContext(WalletModalContext);\n}\n\nexport const WalletModal: FC = () => {\n  const { wallets, wallet: selected, select } = useWallet();\n  const { visible, setVisible } = useWalletModal();\n  const [ , setShowWallets] = useState(false);\n  const close = useCallback(() => {\n    setVisible(false);\n    setShowWallets(false);\n  }, [setVisible, setShowWallets]);\n\n  return (\n    <DefaultModal visible={visible} onCancel={close}>\n      <div\n        style={{\n          background:\n            \"linear-gradient(180deg, #D329FC 0%, #8F6DDE 49.48%, #19E6AD 100%)\",\n          borderRadius: 36,\n          width: 50,\n          height: 50,\n          textAlign: \"center\",\n          verticalAlign: \"middle\",\n          fontWeight: 700,\n          fontSize: \"1.3rem\",\n          lineHeight: 2.4,\n          marginBottom: 10,\n        }}\n      ></div>\n      <h2\n        style={{\n          color: \"white\",\n          fontWeight: \"bold\",\n          fontSize: 20,\n        }}\n      >\n        {selected ? \"Change provider\" : \"\"}\n      </h2>\n      <p style={{ color: \"white\", fontSize: 14 }}>\n        {selected\n          ? \"Choose from the following options:\"\n          : \"Please sign into your wallet\"}\n      </p>\n\n      <br />\n      {wallets.map((wallet) => {\n        return (\n          <Button\n            key={wallet.name}\n            size=\"large\"\n            type={wallet === selected ? \"primary\" : \"ghost\"}\n            onClick={() => {\n              select(wallet.name);\n              close();\n            }}\n            icon={\n              <img\n                alt={`${wallet.name}`}\n                width={20}\n                height={20}\n                src={wallet.icon}\n                style={{ marginRight: 30, float: \"left\" }}\n              />\n            }\n            style={{\n              display: \"block\",\n              width: \"100%\",\n              textAlign: \"left\",\n              marginBottom: 8,\n              color: \"white\",\n            }}\n          >\n            {wallet.name}\n          </Button>\n        );\n      })}\n    </DefaultModal>\n  );\n};\n\nexport const WalletModalProvider: FC<{ children: ReactNode }> = ({\n  children,\n}) => {\n  const { publicKey } = useWallet();\n  const [connected, setConnected] = useState(!!publicKey);\n  const [visible, setVisible] = useState(false);\n\n  useEffect(() => {\n    if (publicKey) {\n      const base58 = publicKey.toBase58();\n      const keyToDisplay =\n        base58.length > 20\n          ? `${base58.substring(0, 7)}.....${base58.substring(\n              base58.length - 7,\n              base58.length\n            )}`\n          : base58;\n\n      notify({\n        message: \"Wallet update\",\n        description: \"Connected to wallet \" + keyToDisplay,\n      });\n    }\n  }, [publicKey]);\n\n  useEffect(() => {\n    if (!publicKey && connected) {\n      notify({\n        message: \"Wallet update\",\n        description: \"Disconnected from wallet\",\n      });\n    }\n    setConnected(!!publicKey);\n  }, [publicKey, connected, setConnected]);\n\n  return (\n    <WalletModalContext.Provider\n      value={{\n        visible,\n        setVisible,\n      }}\n    >\n      {children}\n      <WalletModal />\n    </WalletModalContext.Provider>\n  );\n};\n\nexport const WalletProvider: FC<{ children: ReactNode }> = ({ children }) => {\n  const wallets = useMemo(\n    () => [\n      getPhantomWallet(),\n      getSolflareWallet(),\n      getTorusWallet({\n        options: {\n          clientId:\n            \"BEB_D44HovHuXH0Ace97QVqSu1ahCKndjpGhzhVcMy_9XmDTbHyqTbzQTufcyaN0kFwtlVbfPzJwpJXg94gWJqE\",\n          uxMode: \"redirect\",\n          redirectUrl: \"https://lwus.github.io/gumdrop/#\",\n        },\n      }),\n      getLedgerWallet(),\n      getSolongWallet(),\n      getMathWallet(),\n      getSolletWallet(),\n    ],\n    []\n  );\n\n  const onError = useCallback((error: WalletError) => {\n    console.error(error);\n    notify({\n      message: \"Wallet error\",\n      description: JSON.stringify(error, Object.getOwnPropertyNames(error)),\n    });\n  }, []);\n\n  return (\n    <BaseWalletProvider wallets={wallets} onError={onError} autoConnect>\n      <WalletModalProvider>{children}</WalletModalProvider>\n    </BaseWalletProvider>\n  );\n};\n\nexport type WalletSigner = Pick<\n  WalletAdapter,\n  \"publicKey\" | \"signTransaction\" | \"signAllTransactions\"\n>;\n","export default __webpack_public_path__ + \"static/media/wallet.c746d144.less\";","import React, { useState, useContext, useCallback } from 'react';\n\nimport { WalletModal } from './WalletContext/WalletContext';\n\nexport enum ModalEnum {\n  WALLET = 'wallet',\n}\n\ntype ModalContextProps = {\n  setModal: (modal: ModalEnum | undefined) => void;\n  removeModal: () => void;\n};\n\nexport const ModalContext = React.createContext<ModalContextProps>({\n  setModal: () => null,\n  removeModal: () => null,\n});\n\nexport const ModalProvider: React.FC = ({ children }) => {\n  const [modal, setModal] = useState<ModalEnum | undefined>(undefined);\n\n  const removeModal = useCallback(() => {\n    setModal(undefined);\n  }, [setModal]);\n\n  return (\n    <ModalContext.Provider\n      value={{\n        setModal,\n        removeModal,\n      }}\n    >\n      {children}\n      {modal === ModalEnum.WALLET && <WalletModal />}\n    </ModalContext.Provider>\n  );\n};\n\nexport const useModal = (): ModalContextProps => {\n  const context = useContext(ModalContext);\n  if (context === undefined) {\n    throw new Error('useModal must be used within a ModalProvider');\n  }\n  return context;\n};\n","import * as anchor from '@project-serum/anchor';\nimport { Connection, PublicKey } from '@solana/web3.js';\nimport {\n  AccountLayout,\n  MintInfo,\n  MintLayout,\n} from \"@solana/spl-token\";\nimport BN from 'bn.js';\n\nimport {\n  CANDY_MACHINE_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  TOKEN_METADATA_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n} from \"./ids\";\n\nexport const getMintInfo = async (\n  connection : Connection,\n  mint : string\n) : Promise<{ key: PublicKey, info: MintInfo }> => {\n  let mintKey : PublicKey;\n  try {\n    mintKey = new PublicKey(mint);\n  } catch (err) {\n    throw new Error(`Invalid mint key ${err}`);\n  }\n  const mintAccount = await connection.getAccountInfo(mintKey);\n  if (mintAccount === null) {\n    throw new Error(`Could not fetch mint`);\n  }\n  if (!mintAccount.owner.equals(TOKEN_PROGRAM_ID)) {\n    const mintOwner = mintAccount.owner.toBase58();\n    throw new Error(`Invalid mint owner ${mintOwner}`);\n  }\n  if (mintAccount.data.length !== MintLayout.span) {\n    throw new Error(`Invalid mint size ${mintAccount.data.length}`);\n  }\n  const mintInfo = MintLayout.decode(Buffer.from(mintAccount.data));\n  return {\n    key: mintKey,\n    info: mintInfo,\n  };\n};\n\nexport const getCreatorTokenAccount = async (\n  walletKey : PublicKey,\n  connection : Connection,\n  mintKey : PublicKey,\n  totalClaim : number,\n) => {\n  const [creatorTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      walletKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      mintKey.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n  const creatorTokenAccount = await connection.getAccountInfo(creatorTokenKey);\n  if (creatorTokenAccount === null) {\n    throw new Error(`Could not fetch creator token account`);\n  }\n  if (creatorTokenAccount.data.length !== AccountLayout.span) {\n    throw new Error(`Invalid token account size ${creatorTokenAccount.data.length}`);\n  }\n  const creatorTokenInfo = AccountLayout.decode(Buffer.from(creatorTokenAccount.data));\n  if (new BN(creatorTokenInfo.amount, 8, \"le\").toNumber() < totalClaim) {\n    throw new Error(`Creator token account does not have enough tokens`);\n  }\n  return creatorTokenKey;\n};\n\nexport const fetchCoder = async (\n  address : anchor.Address,\n  connection : Connection,\n) : Promise<anchor.Coder | null> => {\n  return new anchor.Coder(await anchor.Program.fetchIdl(\n      address, { connection: connection } as anchor.Provider));\n}\n\nexport const getCandyConfig = async (\n  connection : Connection,\n  config : string\n) : Promise<PublicKey> => {\n  let configKey : PublicKey;\n  try {\n    configKey = new PublicKey(config);\n  } catch (err) {\n    throw new Error(`Invalid config key ${err}`);\n  }\n  const configAccount = await connection.getAccountInfo(configKey);\n  if (configAccount === null) {\n    throw new Error(`Could not fetch config`);\n  }\n  if (!configAccount.owner.equals(CANDY_MACHINE_ID)) {\n    throw new Error(`Invalid config owner ${configAccount.owner.toBase58()}`);\n  }\n  return configKey;\n};\n\nexport const getCandyMachineAddress = async (\n  config: PublicKey,\n  uuid: string,\n) => {\n  return await PublicKey.findProgramAddress(\n    [Buffer.from(\"candy_machine\"), config.toBuffer(), Buffer.from(uuid)],\n    CANDY_MACHINE_ID,\n  );\n};\n\nexport const getCandyMachine = async (\n  connection : Connection,\n  candyMachineKey : PublicKey,\n) => {\n  const candyMachineCoder = await fetchCoder(CANDY_MACHINE_ID, connection);\n  if (candyMachineCoder === null) {\n    throw new Error(`Could not fetch candy machine IDL`);\n  }\n  const candyMachineAccount = await connection.getAccountInfo(candyMachineKey);\n  if (candyMachineAccount === null) {\n    throw new Error(`Could not fetch candy machine`);\n  }\n  return candyMachineCoder.accounts.decode(\n      \"CandyMachine\", candyMachineAccount.data);\n}\n\nexport const getMetadata = async (\n  mint: PublicKey,\n): Promise<PublicKey> => {\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const getEdition = async (\n  mint: PublicKey,\n): Promise<PublicKey> => {\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('edition'),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const getEditionMarkerPda = async (\n  mint: PublicKey,\n  edition: BN,\n) : Promise<PublicKey> => {\n  // editions are divided into pages of 31-bytes (248-bits) for more efficient\n  // packing to check if an edition is occupied. The offset is determined from\n  // the edition passed in through data\n  const editionPageNumber = edition.div(new BN(248)).toNumber();\n\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('edition'),\n        Buffer.from(String(editionPageNumber)),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n}\n","import React from \"react\";\nimport {\n  Box,\n  Button,\n  Link,\n  Stack,\n} from \"@mui/material\";\nimport HomeIcon from '@mui/icons-material/Home';\n\nimport { Settings } from \"../Settings\";\n\nexport const Header: React.FC = () => {\n  return (\n    <Box\n      sx={{\n        display: \"flex\",\n        bgcolor: \"action.disabledBackground\",\n        overflow: \"auto\",\n      }}\n      minWidth=\"60ch\"\n    >\n      <Stack\n        direction=\"row\"\n        spacing={2}\n        sx={{\n          display: \"flex\",\n          height: \"62px\",\n          justifyContent: \"flex-start\",\n          alignItems: \"center\",\n          marginLeft: \"36px\",\n        }}\n      >\n        <Link href=\"#/\" underline=\"none\">\n          <Button variant=\"outlined\">\n            <HomeIcon />\n          </Button>\n        </Link>\n        <Link href=\"#/create\" underline=\"none\">\n          <Button variant=\"outlined\">\n            Create\n          </Button>\n        </Link>\n        <Link href=\"#/claim\" underline=\"none\">\n          <Button variant=\"outlined\">\n            Claim\n          </Button>\n        </Link>\n        <Link href=\"#/close\" underline=\"none\">\n          <Button variant=\"outlined\">\n            Close\n          </Button>\n        </Link>\n      </Stack>\n      <Box sx={{flexGrow: 1, minWidth: \"36px\"}}></Box>\n      <Settings />\n    </Box>\n  );\n};\n\nexport default Header;\n","import React from \"react\";\n\nimport {\n  Button,\n  FormControl,\n  InputLabel,\n  Link as HyperLink,\n  MenuItem,\n  Stack,\n  Select,\n  TextField,\n} from \"@mui/material\";\n\nimport {\n  useWallet,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  Keypair,\n} from \"@solana/web3.js\";\n\nimport {\n  useConnection,\n  Connection,\n} from \"../contexts\";\nimport {\n  notify,\n} from \"../utils\";\nimport {\n  closeGumdrop,\n} from \"../utils/claimant\";\nimport {\n  explorerLinkFor,\n} from \"../utils/transactions\";\n\nexport const Close = () => {\n  const connection = useConnection();\n  const wallet = useWallet();\n\n  const [baseKey, setBaseKey] = React.useState(\"\");\n  const [claimMethod, setClaimMethod] = React.useState(localStorage.getItem(\"claimMethod\") || \"transfer\");\n  const [candyConfig, setCandyConfig] = React.useState(localStorage.getItem(\"candyConfig\") || \"\");\n  const [candyUUID, setCandyUUID] = React.useState(localStorage.getItem(\"candyUUID\") || \"\");\n  const [masterMint, setMasterMint] = React.useState(localStorage.getItem(\"masterMint\") || \"\");\n\n  const submit = async (e : React.SyntheticEvent) => {\n    e.preventDefault();\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const base = Keypair.fromSecretKey(\n      new Uint8Array(JSON.parse(baseKey)));\n\n    const instructions = await closeGumdrop(\n      connection,\n      wallet.publicKey,\n      base,\n      claimMethod,\n      candyConfig,\n      candyUUID,\n      masterMint,\n    );\n\n    const closeResult = await Connection.sendTransactionWithRetry(\n      connection,\n      wallet,\n      instructions,\n      [base]\n    );\n\n    console.log(closeResult);\n    if (typeof closeResult === \"string\") {\n      notify({\n        message: \"Close failed\",\n        description: closeResult,\n      });\n    } else {\n      notify({\n        message: \"Close succeeded\",\n        description: (\n          <HyperLink href={explorerLinkFor(closeResult.txid, connection)}>\n            View transaction on explorer\n          </HyperLink>\n        ),\n      });\n    }\n  };\n\n  const claimData = (claimMethod) => {\n    if (claimMethod === \"candy\") {\n      return (\n        <React.Fragment>\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"config-text-field\"\n            label=\"Candy Config\"\n            value={candyConfig}\n            onChange={e => setCandyConfig(e.target.value)}\n          />\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"config-uuid-text-field\"\n            label=\"Candy UUID\"\n            value={candyUUID}\n            onChange={e => setCandyUUID(e.target.value)}\n          />\n        </React.Fragment>\n      );\n    } else if (claimMethod === \"transfer\") {\n      return null;\n    } else if (claimMethod === \"edition\") {\n      return (\n        <React.Fragment>\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"master-mint-text-field\"\n            label=\"Master Mint\"\n            value={masterMint}\n            onChange={(e) => setMasterMint(e.target.value)}\n          />\n        </React.Fragment>\n      );\n    }\n  };\n\n  return (\n    <Stack spacing={2}>\n      <TextField\n        style={{width: \"60ch\"}}\n        id=\"base-text-field\"\n        label=\"Base Private Key\"\n        value={baseKey}\n        onChange={(e) => setBaseKey(e.target.value)}\n      />\n      <FormControl fullWidth>\n        <InputLabel id=\"claim-method-label\">Claim Method</InputLabel>\n        <Select\n          labelId=\"claim-method-label\"\n          id=\"claim-method-select\"\n          value={claimMethod}\n          label=\"Claim Method\"\n          onChange={(e) => {\n            localStorage.setItem(\"claimMethod\", e.target.value);\n            setClaimMethod(e.target.value);\n          }}\n          style={{textAlign: \"left\"}}\n        >\n          <MenuItem value={\"transfer\"}>Token Transfer</MenuItem>\n          <MenuItem value={\"candy\"}>Candy Machine</MenuItem>\n          <MenuItem value={\"edition\"}>Limited Edition</MenuItem>\n        </Select>\n      </FormControl>\n      {claimMethod !== \"\" && claimData(claimMethod)}\n      <Button\n        disabled={!wallet.connected || !baseKey}\n        variant=\"contained\"\n        onClick={(e) => {\n          const wrap = async () => {\n            try {\n              await submit(e);\n            } catch (err) {\n              notify({\n                message: \"Close failed\",\n                description: `${err}`,\n              });\n            }\n          };\n          wrap();\n        }}\n      >\n        Close Gumdrop\n      </Button>\n    </Stack>\n  );\n};\n","import log from 'loglevel';\nimport { SESv2Client, SendEmailCommand } from \"@aws-sdk/client-sesv2\"\nimport { SNSClient, PublishCommand } from \"@aws-sdk/client-sns\";\n\nimport {\n  ClaimantInfo,\n  Claimants,\n} from \"./claimant\"\n\nexport type AuthKeys = { [key: string] : string }\nexport type Response = { [key: string] : any }\n\nexport type DropInfo = {\n  type : string,\n  meta : string,\n};\n\nexport const formatDropMessage = (\n  info : ClaimantInfo,\n  drop : DropInfo,\n  html : boolean,\n) => {\n  const wrap = (url, text) => {\n    if (html) {\n      return `<a href=\"${url}\">${text}</a>`;\n    } else {\n      return `${text} ${url}`;\n    }\n  }\n  if (drop.type === \"Token\") {\n    return {\n      subject: \"Gumdrop Token Drop\",\n      message: `You received ${info.amount} token(s) `\n             + `(click ${wrap(drop.meta, \"here\")} to view more information about the token mint). `\n             +  wrap(info.url, \"Click here to claim them!\"),\n    };\n  } else if (drop.type === \"Candy\") {\n    return {\n      subject: \"Gumdrop NFT Drop\",\n      message: `You received ${info.amount} Candy Machine pre-sale mint(s) `\n             + `(click ${wrap(drop.meta, \"here\")} to view the candy machine configuration on explorer). `\n             +  wrap(info.url, \"Click here to claim them!\"),\n    };\n  } else if (drop.type === \"Edition\") {\n    return {\n      subject: \"Gumdrop NFT Drop\",\n      message: `You received ${info.amount} limited-edition print(s) `\n             + `(click ${wrap(drop.meta, \"here\")} to view the master edition mint on explorer). `\n             +  wrap(info.url, \"Click here to claim them!\"),\n    };\n  } else {\n    throw new Error(`Internal Error: Unknown drop type ${drop.type}`);\n  }\n};\n\nexport const distributeAwsSns = async (\n  auth : AuthKeys,\n  source : string,\n  claimants : Claimants,\n  drop : DropInfo,\n) => {\n  if (!auth.accessKeyId || !auth.secretAccessKey) {\n    throw new Error(\"AWS SES auth keys not supplied\");\n  }\n  if (claimants.length === 0) return [];\n\n  log.debug(\"SES auth\", auth);\n  const client = new SNSClient({\n    region: \"us-east-2\",\n    credentials: {\n      accessKeyId: auth.accessKeyId,\n      secretAccessKey: auth.secretAccessKey,\n    },\n  });\n\n  const single = async (\n    info : ClaimantInfo,\n    drop : DropInfo,\n  ) => {\n    const formatted = formatDropMessage(info, drop, true);\n    const message = {\n      Message: formatted.message,\n      PhoneNumber: info.handle,\n    };\n\n    try {\n      const response = await client.send(new PublishCommand(message));\n      return {\n        status: \"success\",\n        handle: info.handle,\n        messageId: response.MessageId,\n      };\n    } catch (err) {\n      return {\n        status: \"error\",\n        handle: info.handle,\n        error: err,\n      };\n    }\n  };\n\n  const responses = Array<Response>();\n  for (const c of claimants) {\n    responses.push(await single(c, drop));\n  }\n  return responses;\n}\n\nexport const distributeAwsSes = async (\n  auth : AuthKeys,\n  source : string,\n  claimants : Claimants,\n  drop : DropInfo,\n) => {\n  if (!auth.accessKeyId || !auth.secretAccessKey) {\n    throw new Error(\"AWS SES auth keys not supplied\");\n  }\n  if (claimants.length === 0) return [];\n\n  log.debug(\"SES auth\", auth);\n  const client = new SESv2Client({\n    region: \"us-east-2\",\n    credentials: {\n      accessKeyId: auth.accessKeyId,\n      secretAccessKey: auth.secretAccessKey,\n    },\n  });\n\n  // TODO: move to template + bulk message?\n  const single = async (\n    info : ClaimantInfo,\n    drop : DropInfo,\n  ) => {\n    const formatted = formatDropMessage(info, drop, true);\n    const message = {\n      Destination: {\n        ToAddresses: [\n          info.handle,\n        ]\n      },\n      Content: {\n        Simple: {\n          Subject: {\n            Data: formatted.subject,\n            Charset: \"utf-8\",\n          },\n          Body: {\n            Html: {\n              Data: formatted.message\n                + \"<br><br>\"\n                + \"<div>\"\n                +   \"If you would like to unsubscribe from new Gumdrops, \"\n                +   \"change your subscription preferences here: \"\n                +   \"<a href='{{amazonSESUnsubscribeUrl}}'>AWS subscription preferences</a>\"\n                + \"</div>\",\n              Charset: \"utf-8\",\n            },\n          },\n        },\n      },\n      FromEmailAddress: source,\n      ListManagementOptions: {\n        ContactListName: \"Gumdrop\",\n        TopicName: drop.type,\n      },\n    };\n\n    try {\n      const response = await client.send(new SendEmailCommand(message));\n      return {\n        status: \"success\",\n        handle: info.handle,\n        messageId: response.MessageId,\n      };\n    } catch (err) {\n      return {\n        status: \"error\",\n        handle: info.handle,\n        error: err,\n      };\n    }\n  };\n\n  const responses = Array<Response>();\n  for (const c of claimants) {\n    responses.push(await single(c, drop));\n  }\n  return responses;\n}\n\nexport const distributeManual = async (\n  auth : AuthKeys,\n  source : string,\n  claimants : Claimants,\n  drop : DropInfo,\n) => {\n  return Array<Response>();\n}\n\nexport const distributeWallet = async (\n  auth : AuthKeys,\n  source : string,\n  claimants : Claimants,\n  drop : DropInfo,\n) => {\n  return Array<Response>();\n}\n\nexport const urlAndHandleFor = (claimants : Array<ClaimantInfo>) => {\n  return claimants.map(info => {\n    return {\n      handle: info.handle,\n      amount: info.amount,\n      url: info.url,\n    };\n  });\n}\n","import React from \"react\"\nimport {\n  useColorMode,\n} from \"../contexts/ColorModeContext\";\n\nexport const DragAndDrop = (props) => {\n  const dropRef = React.useRef<HTMLDivElement>(null);\n  const [dragCounter, setDragCounter] = React.useState(0);\n  const [dragging, setDragging] = React.useState(false);\n\n  const handleDrag = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n  };\n\n  const handleDragIn = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    setDragCounter(dragCounter + 1);\n    if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {\n      setDragging(true);\n    }\n  };\n\n  const handleDragOut = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    const remainingDrags = dragCounter - 1;\n    setDragCounter(remainingDrags);\n    if (remainingDrags === 0) {\n      setDragging(false);\n    }\n  };\n\n  const handleDrop = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    setDragging(false);\n    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\n      props.handleDrop(e.dataTransfer.files);\n      e.dataTransfer.clearData();\n      setDragCounter(0);\n    }\n  };\n\n  React.useEffect(() => {\n    const node = dropRef.current;\n    if (node === null) return;\n    node.addEventListener(\"dragenter\" , handleDragIn);\n    node.addEventListener(\"dragleave\" , handleDragOut);\n    node.addEventListener(\"dragover\"  , handleDrag);\n    node.addEventListener(\"drop\"      , handleDrop);\n\n    return () => {\n      node.removeEventListener(\"dragenter\" , handleDragIn);\n      node.removeEventListener(\"dragleave\" , handleDragOut);\n      node.removeEventListener(\"dragover\"  , handleDrag);\n      node.removeEventListener(\"drop\"      , handleDrop);\n    };\n  });\n\n  const colorModeCtx = useColorMode();\n  const shade = colorModeCtx.mode === 'dark' ? \"rgba(255,255,255,.1)\" : \"rgba(0, 0, 0,.1)\";\n\n  return (\n    <div\n      ref={dropRef}\n      style={dragging ? { backgroundColor: shade} : {}}\n    >\n      {props.children}\n    </div>\n  );\n};\n\n\nexport default DragAndDrop;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport {\n  Box,\n  Button,\n  CircularProgress,\n  FormControl,\n  Link as HyperLink,\n  InputLabel,\n  MenuItem,\n  Stack,\n  Select,\n  Table,\n  TableBody,\n  TableCell,\n  TableContainer,\n  TableHead,\n  TableRow,\n  TextField,\n} from \"@mui/material\";\nimport FilePresentIcon from '@mui/icons-material/FilePresent';\n\nimport {\n  useWallet,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  Keypair,\n  PublicKey,\n} from \"@solana/web3.js\";\nimport {\n  MintInfo,\n} from \"@solana/spl-token\";\nimport BN from 'bn.js';\n\nimport {\n  useConnection,\n  Connection,\n} from \"../contexts\";\nimport {\n  GUMDROP_DISTRIBUTOR_ID,\n  GUMDROP_TEMPORAL_SIGNER,\n  notify,\n  shortenAddress,\n} from \"../utils\";\nimport {\n  ClaimantInfo,\n  Claimants,\n  buildGumdrop,\n  dropInfoFor,\n  parseClaimants,\n  validateTransferClaims,\n  validateCandyClaims,\n  validateEditionClaims,\n} from \"../utils/claimant\";\nimport {\n  AuthKeys,\n  DropInfo,\n  Response as DResponse,\n  distributeAwsSes,\n  distributeManual,\n  distributeWallet,\n  urlAndHandleFor,\n} from \"../utils/communication\";\nimport {\n  envFor,\n  explorerLinkFor,\n} from \"../utils/transactions\";\nimport { DragAndDrop } from \"./DragAndDrop\";\nimport { DefaultModal } from \"./DefaultModal\";\n\n// NB: assumes no overflow\nconst randomBytes = () : Uint8Array => {\n  // TODO: some predictable seed? sha256?\n  const buf = new Uint8Array(4);\n  window.crypto.getRandomValues(buf);\n  return buf;\n}\n\nconst WHITESPACE = \"\\u00A0\";\n\nconst distribute = (\n  method : string,\n  auth : AuthKeys,\n  source : string,\n  claimants : Claimants,\n  drop : DropInfo,\n) => {\n  if (method === \"AWS SES\") {\n    return distributeAwsSes(auth, source, claimants, drop);\n  } else if (method === \"Manual\") {\n    return distributeManual(auth, source, claimants, drop);\n  } else if (method === \"Wallets\") {\n    return distributeWallet(auth, source, claimants, drop);\n  } else {\n    throw new Error(`Unrecognized claim distribution method ${method}`);\n  }\n}\n\nconst reactModal = (renderModal) => {\n  const container = document.createElement('div');\n  document.body.appendChild(container);\n\n  const displayModal = ({ onSubmit, onDismiss }) => {\n    ReactDOM.render(renderModal({ onSubmit, onDismiss, show: true }), container);\n  };\n\n  const hideModal = ({ onSubmit, onDismiss }, callback) => {\n    ReactDOM.render(renderModal({ onSubmit, onDismiss, show: false }), container, callback);\n  };\n\n  const destroyModal = () => {\n    ReactDOM.unmountComponentAtNode(container);\n    document.body.removeChild(container);\n  };\n\n  const confirmation = new Promise((resolve) => {\n    const onSubmit = (value) => resolve(value);\n    const onDismiss = () => resolve(undefined);\n    displayModal({ onSubmit, onDismiss });\n  });\n\n  return confirmation.finally(() => {\n    const onSubmit = () => {};\n    const onDismiss = () => {};\n    hideModal({ onSubmit, onDismiss }, destroyModal);\n  });\n};\n\nconst resendOnlyRender = ({ show, onSubmit, onDismiss }) => {\n  const options = [\n    { click: () => onSubmit(\"create\"), name: \"Create and Send\" },\n    { click: () => onSubmit(\"send\")  , name: \"Send only\"       },\n  ];\n  return (\n    <DefaultModal visible={show} onCancel={onDismiss} width=\"70ch\">\n      <p style={{\n        color: \"white\",\n        fontSize: \"1rem\",\n        width: \"50ch\",\n        marginTop: 8,\n      }}>\n        Uploaded distribution list has URLs for all claimants.\n        Skip creation of airdrop and only re-send links?\n      </p>\n      <br />\n      <Stack direction=\"row\" spacing={2}>\n      {options.map((opt) => {\n        return (\n          <Button\n            key={opt.name}\n            style={{\n              width: \"30ch\",\n              color: \"white\",\n              marginBottom: 8,\n            }}\n            variant=\"outlined\"\n            onClick={opt.click}\n          >\n            {opt.name}\n          </Button>\n        );\n      })}\n      </Stack>\n    </DefaultModal>\n  );\n};\n\nconst displayMintTokens = (amount : number, mintInfo : MintInfo) : string => {\n  // TODO: better decimal rounding\n  return String(amount / Math.pow(10, mintInfo.decimals));\n};\n\nconst hyperLinkData = (data) => {\n  const encoded = encodeURIComponent(JSON.stringify(data));\n  return `data:text/plain;charset=utf-8,${encoded}`;\n};\n\nconst shouldSendRender = (claimants, needsPin, claimMethod, claimInfo, baseKey) => {\n  const limit = 1000;\n  return ({ show, onSubmit, onDismiss }) => {\n    return (\n      <DefaultModal visible={show} onCancel={onDismiss} width=\"70ch\">\n        <h2\n          style={{\n            color: \"white\",\n            fontWeight: \"bold\",\n            fontSize: 20,\n          }}\n        >\n          Claim Distribution Preview{claimants.length > limit ? ` (First ${limit})` : \"\"}\n        </h2>\n        <p style={{ color: \"white\", fontSize: 14, textAlign: \"center\" }}>\n          Approving will save the keypair authority generated for gumdrop\n          state. This keypair is necessary to close the gumdrop later!\n        </p>\n        <TableContainer\n          sx={{\n            \"td, th\": { color: \"white\" },\n            backgroundColor: \"#444444\",\n            borderRadius: \"5px\",\n            maxHeight: \"30ch\",\n          }}\n        >\n          <Table size=\"small\">\n            <TableHead>\n              <TableRow>\n                <TableCell>Handle</TableCell>\n                <TableCell>\n                  {claimMethod === \"edition\"\n                    ? \"Edition\"\n                    : \"Tokens\"\n                  }\n                </TableCell>\n                {needsPin && <TableCell>Pin</TableCell>}\n              </TableRow>\n            </TableHead>\n            <TableBody>\n              {claimants.slice(0, limit).map((c, idx) => (\n                <TableRow\n                  key={idx}\n                  sx={{ 'td, th': { border: 0 } }}\n                >\n                  <TableCell component=\"th\" scope=\"row\">{c.handle} </TableCell>\n                  <TableCell>\n                    { claimMethod === \"transfer\" ? displayMintTokens(c.amount, claimInfo.mint.info)\n                    : claimMethod === \"candy\"    ? c.amount\n                    : /* === \"edition\" */          c.edition\n                    }\n                  </TableCell>\n                  {needsPin && <TableCell>{c.pin.toNumber()}</TableCell>}\n                </TableRow>\n              ))}\n            </TableBody>\n          </Table>\n        </TableContainer>\n        <Box style={{ height: \"3ch\" }} />\n        <Stack direction=\"row\" spacing={2}>\n          <Button\n            style={{\n              width: \"30ch\",\n              color: \"white\",\n              marginBottom: 8,\n            }}\n            variant=\"outlined\"\n            onClick={() => onSubmit(false)}\n          >\n            Cancel\n          </Button>\n          <HyperLink\n            href={hyperLinkData(Array.from(baseKey.secretKey))}\n            download={`${baseKey.publicKey.toBase58()}.json`}\n            underline=\"none\"\n            style={{width: \"30ch\"}}\n          >\n            <Button\n              style={{\n                width: \"100%\",\n                color: \"white\",\n                marginBottom: 8,\n              }}\n              variant=\"outlined\"\n              onClick={() => onSubmit(true)}\n            >\n              Approve\n            </Button>\n          </HyperLink>\n        </Stack>\n      </DefaultModal>\n    );\n  }\n};\n\nexport type CreateProps = {};\n\nexport const Create = (\n  props : CreateProps,\n) => {\n  const connection = useConnection();\n  const wallet = useWallet();\n\n  // claim state\n  const [claimMethod, setClaimMethod] = React.useState(localStorage.getItem(\"claimMethod\") || \"\");\n  const [candyConfig, setCandyConfig] = React.useState(localStorage.getItem(\"candyConfig\") || \"\");\n  const [candyUUID, setCandyUUID] = React.useState(localStorage.getItem(\"candyUUID\") || \"\");\n  const [mint, setMint] = React.useState(localStorage.getItem(\"mint\") || \"\");\n  const [masterMint, setMasterMint] = React.useState(localStorage.getItem(\"masterMint\") || \"\");\n  const [filename, setFilename] = React.useState(\"\");\n  const [text, setText] = React.useState(\"\");\n\n  // response state\n  const [claimURLs, setClaimURLs] = React.useState<Array<{ [key: string]: any }>>([]);\n  const [responses, setResponses] = React.useState<Array<DResponse>>([]);\n\n  // auth state\n  const [otpAuth, setOtpAuth] = React.useState(localStorage.getItem(\"otpAuth\") || \"default\");\n  const [commMethod, setCommMethod] = React.useState(localStorage.getItem(\"commMethod\") || \"\");\n  const [commAuth, setCommAuth] = React.useState<AuthKeys>({});\n  const [commSource, setCommSource] = React.useState(localStorage.getItem(\"commSource\") || \"\");\n  const [awsAccessKeyId, setAwsAccessKeyId] = React.useState(\"\");\n  const [awsSecretKey, setAwsSecretKey] = React.useState(\"\");\n\n  const explorerUrlFor = (key : PublicKey) => {\n    return `https://explorer.solana.com/address/${key.toBase58()}?cluster=${envFor(connection)}`;\n  }\n\n  const distributeClaims = async (claimants, drop) => {\n    const responses = await distribute(\n      commMethod, commAuth, commSource, claimants, drop);\n\n    console.log(\"Responses\", responses);\n    setResponses(responses);\n\n    // notify if the above routine is actually supposed to do anything\n    // (manual and wallet do nothing atm)\n    if (commMethod === \"AWS SES\") {\n      notify({\n        message: \"Gumdrop email distribution completed\",\n      });\n    }\n  }\n\n  const submit = async (e : React.SyntheticEvent) => {\n    e.preventDefault();\n\n    setClaimURLs([]);\n    setResponses([]);\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const claimants = parseClaimants(text, filename, commMethod);\n    if (claimants.length === 0) {\n      throw new Error(`No claimants provided`);\n    }\n\n    const dropInfo = dropInfoFor(envFor(connection), claimMethod, mint, candyConfig, masterMint);\n    // check that auth is correct...\n    await distribute(\n      commMethod, commAuth, commSource, [], dropInfo);\n\n    const mightHaveExisting = (info : ClaimantInfo) => {\n      return info.url !== undefined && info.url !== null;\n    };\n    if (claimants.reduce((acc, c) => acc && mightHaveExisting(c), true)) {\n      const resendOnly = await reactModal(resendOnlyRender);\n      console.log(\"Resend only\", resendOnly);\n      if (resendOnly === \"send\") {\n        setClaimURLs(urlAndHandleFor(claimants));\n        await distributeClaims(claimants, dropInfo);\n        return;\n      } else if (resendOnly === \"create\") {\n        // fallthrough to full create\n      } else {\n        // dismissed. don't use exceptions for control flow?\n        throw new Error(\"Dismissed\");\n      }\n    }\n\n\n    let claimInfo;\n    switch (claimMethod) {\n      case \"transfer\": {\n        claimInfo = await validateTransferClaims(\n          connection,\n          wallet.publicKey,\n          claimants,\n          mint,\n        );\n        break;\n      }\n      case \"candy\": {\n        claimInfo = await validateCandyClaims(\n          connection,\n          wallet.publicKey,\n          claimants,\n          candyConfig,\n          candyUUID,\n        );\n        break;\n      }\n      case \"edition\": {\n        claimInfo = await validateEditionClaims(\n          connection,\n          wallet.publicKey,\n          claimants,\n          masterMint,\n        );\n        break;\n      }\n      default:\n        throw new Error(`Unknown claim method ${claimMethod}`);\n    }\n    console.log(\"Claims info\", claimInfo);\n\n    claimants.forEach(c => {\n      c.pin = new BN(randomBytes());\n      c.seed = claimMethod === \"transfer\" ? claimInfo.mint.key\n             : claimMethod === \"candy\"    ? claimInfo.config\n             : /* === edition */            claimInfo.masterMint.key;\n    });\n\n    // temporal auth is the AWS signer by 'default' and a no-op key otherwise\n    let temporalSigner;\n    if (commMethod === \"Wallets\") {\n      // TODO: this is a bit jank. There should be no form option to set the\n      // OTP auth if we are using a wallet but there's still a defaulted value\n      // atm...\n      // NB: We also need this to not be 'none' since there is a special check\n      // for claimant_secret==accounts.temporal\n      temporalSigner = GUMDROP_DISTRIBUTOR_ID;\n    } else if (otpAuth === \"default\") {\n      temporalSigner = GUMDROP_TEMPORAL_SIGNER;\n    } else if (otpAuth === \"none\") {\n      temporalSigner = PublicKey.default;\n    } else {\n      throw new Error(`Unknown OTP authorization type ${otpAuth}`);\n    }\n\n    console.log(`Temporal signer: ${temporalSigner.toBase58()}`);\n\n    const base = Keypair.generate();\n    console.log(`Base ${base.publicKey.toBase58()}`);\n\n    const needsPin = commMethod !== \"Wallets\";\n    const instructions = await buildGumdrop(\n      connection,\n      wallet.publicKey,\n      needsPin,\n      claimMethod,\n      `${window.location.origin}${window.location.pathname}`,\n      base.publicKey,\n      temporalSigner,\n      claimants,\n      claimInfo\n    );\n\n    const shouldSend = await reactModal(\n      shouldSendRender(claimants, needsPin, claimMethod, claimInfo, base)\n    ) as boolean | undefined;\n    if (shouldSend === true) {\n    } else {\n      // dismissed. don't use exceptions for control flow?\n      throw new Error(\"Claim distribution preview not approved\");\n    }\n\n\n    setClaimURLs(urlAndHandleFor(claimants));\n\n    const createResult = await Connection.sendTransactionWithRetry(\n      connection,\n      wallet,\n      instructions,\n      [base]\n    );\n\n    console.log(createResult);\n    if (typeof createResult === \"string\") {\n      throw new Error(createResult);\n    } else {\n      notify({\n        message: \"Gumdrop creation succeeded\",\n        description: (\n          <HyperLink href={explorerLinkFor(createResult.txid, connection)}>\n            View transaction on explorer\n          </HyperLink>\n        ),\n      });\n    }\n\n    console.log(\"Distributing claim URLs\");\n    await distributeClaims(claimants, dropInfo);\n  };\n\n  const handleFiles = (files) => {\n    if (files.length !== 1) {\n      notify({\n        message: \"File upload failed\",\n        description: `Received ${files.length} files`,\n      });\n      return;\n    }\n\n    const file = files[0];\n    const reader = new FileReader();\n    reader.onload = (e) => {\n      if (e !== null && e.target !== null) {\n        if (typeof e.target.result === \"string\") {\n          try {\n            parseClaimants(e.target.result, file.name, commMethod);\n          } catch {\n            notify({\n              message: `File upload failed for: ${file.name}`,\n              description: (\n                <span>\n                  Could not parse uploaded file.{WHITESPACE}\n                  <HyperLink href=\"#/\">\n                    Does it follow the JSON scheme?\n                  </HyperLink>\n                </span>\n              ),\n            });\n            setFilename(\"\");\n            setText(\"\");\n            return;\n          }\n          setFilename(file.name);\n          setText(e.target.result);\n        } else {\n          notify({\n            message: `File upload failed for: ${file.name}`,\n            description: \"Could not read uploaded file\",\n          });\n        }\n      }\n    };\n    reader.readAsText(file);\n  };\n\n  const claimData = (claimMethod) => {\n    if (claimMethod === \"candy\") {\n      return (\n        <React.Fragment>\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"config-text-field\"\n            label=\"Candy Config\"\n            value={candyConfig}\n            onChange={e => {\n              setCandyConfig(e.target.value);\n              localStorage.setItem(\"candyConfig\", e.target.value);\n            }}\n          />\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"config-uuid-text-field\"\n            label=\"Candy UUID\"\n            value={candyUUID}\n            onChange={e => {\n              setCandyUUID(e.target.value);\n              localStorage.setItem(\"candyUUID\", e.target.value);\n            }}\n          />\n        </React.Fragment>\n      );\n    } else if (claimMethod === \"transfer\") {\n      return (\n        <TextField\n          style={{width: \"60ch\"}}\n          id=\"mint-text-field\"\n          label=\"Mint\"\n          value={mint}\n          onChange={(e) => {\n            localStorage.setItem(\"mint\", e.target.value);\n            setMint(e.target.value);\n          }}\n        />\n      );\n    } else if (claimMethod === \"edition\") {\n      // transfers master mint token from this account to the distributor\n      // wallet ATA\n      return (\n        <TextField\n          style={{width: \"60ch\"}}\n          id=\"master-mint-text-field\"\n          label=\"Master Mint\"\n          value={masterMint}\n          onChange={(e) => {\n            localStorage.setItem(\"masterMint\", e.target.value);\n            setMasterMint(e.target.value);\n          }}\n        />\n      );\n    }\n  };\n\n  const commAuthorization = (commMethod) => {\n    if (commMethod === \"AWS SES\") {\n      return (\n        <React.Fragment>\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"comm-access-key-id-field\"\n            label={`${commMethod} Access Key Id`}\n            value={awsAccessKeyId}\n            onChange={(e) => {\n              setCommAuth(prev => ({...prev, accessKeyId: e.target.value}));\n              setAwsAccessKeyId(e.target.value)\n            }}\n          />\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"comm-secret-access-key-field\"\n            label={`${commMethod} Secret Access Key`}\n            value={awsSecretKey}\n            onChange={(e) => {\n              setCommAuth(prev => ({...prev, secretAccessKey: e.target.value}));\n              setAwsSecretKey(e.target.value)\n            }}\n          />\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"comm-source-field\"\n            label={`${commMethod} Source`}\n            value={commSource}\n            onChange={(e) => {\n              localStorage.setItem(\"commSource\", e.target.value);\n              setCommSource(e.target.value)\n            }}\n          />\n        </React.Fragment>\n      );\n    }\n\n    // commMethod === \"Manual\" || commMethod === \"Wallets\"\n    return null;\n  };\n\n  const fileUpload = (\n    <React.Fragment>\n      <DragAndDrop handleDrop={handleFiles} >\n        <Stack\n          direction=\"row\"\n          style={{\n            width: \"60ch\",\n            height: \"15ch\",\n          }}\n          sx={{\n            border: '1px dashed grey',\n            justifyContent: \"center\",\n            alignContent: \"center\",\n          }}\n        >\n          <Button\n            variant=\"text\"\n            component=\"label\"\n            style={{\n              padding: 0,\n              // don't make the button click field too large...\n              marginTop: \"5ch\",\n              marginBottom: \"5ch\",\n            }}\n          >\n            Upload a {filename === \"\" ? \"distribution\" : \"different\"} list\n            <input\n              type=\"file\"\n              onChange={(e) => {\n                handleFiles(e.target.files);\n                // re-parse every time...\n                e.target.value = '';\n              }}\n              hidden\n            />\n          </Button>\n          {WHITESPACE}\n          {/*For display alignment...*/}\n          <Button\n            variant=\"text\"\n            component=\"label\"\n            disabled={true}\n            style={{\n              padding: 0,\n              color: \"#eee\",\n            }}\n          >\n            or drag it here\n          </Button>\n        </Stack>\n      </DragAndDrop>\n      {filename !== \"\"\n      ? (<Button\n            variant=\"text\"\n            component=\"label\"\n            disabled={true}\n            style={{\n              padding: 0,\n              color: \"#eee\",\n            }}\n          >\n            <FilePresentIcon />\n            <span>{WHITESPACE} Uploaded {filename}</span>\n          </Button>\n        )\n      : (<Box/>)}\n    </React.Fragment>\n  );\n\n  const [loading, setLoading] = React.useState(false);\n  const loadingProgress = () => (\n    <CircularProgress\n      size={24}\n      sx={{\n        position: 'absolute',\n        top: '50%',\n        left: '50%',\n        marginTop: '-12px',\n        marginLeft: '-12px',\n      }}\n    />\n  );\n  const createAirdrop = (\n    <Box sx={{ position: \"relative\" }}>\n    <Button\n      disabled={!wallet.connected || !commMethod || !filename || loading}\n      variant=\"contained\"\n      style={{ width: \"100%\" }}\n      onClick={(e) => {\n        setLoading(true);\n        const wrap = async () => {\n          try {\n            await submit(e);\n            setLoading(false);\n          } catch (err) {\n            notify({\n              message: \"Create failed\",\n              description: `${err}`,\n            });\n            setLoading(false);\n          }\n        };\n        wrap();\n      }}\n    >\n      Create{claimURLs.length > 0 ? \" Another \" : \" \"}Gumdrop\n    </Button>\n    {loading && loadingProgress()}\n    </Box>\n  );\n\n  const otpAuthC = (\n    <React.Fragment>\n      <FormControl fullWidth>\n        <InputLabel id=\"otp-auth-label\">OTP Authorization</InputLabel>\n        <Select\n          labelId=\"otp-auth-label\"\n          id=\"otp-auth-select\"\n          value={otpAuth}\n          label=\"OTP Authorization\"\n          onChange={(e) => {\n            localStorage.setItem(\"otpAuth\", e.target.value);\n            setOtpAuth(e.target.value);\n          }}\n          style={{textAlign: \"left\"}}\n        >\n          <MenuItem value={\"default\"}>\n            Default{WHITESPACE}\n            <HyperLink\n              href={explorerUrlFor(GUMDROP_TEMPORAL_SIGNER)}\n              underline=\"none\"\n              target=\"_blank\" rel=\"noopener noreferrer\"\n            >\n              ({shortenAddress(GUMDROP_TEMPORAL_SIGNER.toBase58())})\n            </HyperLink>\n          </MenuItem>\n          <MenuItem value={\"none\"}>None</MenuItem>\n        </Select>\n      </FormControl>\n    </React.Fragment>\n  );\n\n  return (\n    <Stack spacing={2}>\n      <FormControl fullWidth>\n        <InputLabel id=\"claim-method-label\">Claim Method</InputLabel>\n        <Select\n          labelId=\"claim-method-label\"\n          id=\"claim-method-select\"\n          value={claimMethod}\n          label=\"Claim Method\"\n          onChange={(e) => {\n            localStorage.setItem(\"claimMethod\", e.target.value);\n            setClaimMethod(e.target.value);\n          }}\n          style={{textAlign: \"left\"}}\n        >\n          <MenuItem value={\"transfer\"}>Token Transfer</MenuItem>\n          <MenuItem value={\"candy\"}>Candy Machine</MenuItem>\n          <MenuItem value={\"edition\"}>Limited Edition</MenuItem>\n        </Select>\n      </FormControl>\n      {claimMethod !== \"\" && claimData(claimMethod)}\n      <FormControl fullWidth>\n        <InputLabel id=\"comm-method-label\">Distribution Method</InputLabel>\n        <Select\n          labelId=\"comm-method-label\"\n          id=\"comm-method-select\"\n          value={commMethod}\n          label=\"Distribution Method\"\n          onChange={(e) => {\n            if (e.target.value === \"Discord\") {\n              notify({\n                message: \"Discord distribution unavailable\",\n                description: \"Please use the CLI for this. Discord does not support browser-connection requests\",\n              });\n              return;\n            }\n            localStorage.setItem(\"commMethod\", e.target.value);\n            setCommMethod(e.target.value);\n          }}\n          style={{textAlign: \"left\"}}\n        >\n          <MenuItem value={\"AWS SES\"}>AWS SES</MenuItem>\n          <MenuItem value={\"Discord\"}>Discord</MenuItem>\n          <MenuItem value={\"Wallets\"}>Wallets</MenuItem>\n          <MenuItem value={\"Manual\"}>Manual</MenuItem>\n        </Select>\n      </FormControl>\n      {commMethod !== \"\" && commAuthorization(commMethod)}\n      {commMethod !== \"\" && commMethod !== \"Wallets\" && otpAuthC}\n      {commMethod !== \"\" && fileUpload}\n      {createAirdrop}\n      {claimURLs.length > 0 && (\n        <HyperLink\n          href={hyperLinkData(claimURLs)}\n          download=\"claimURLs.json\"\n          underline=\"none\"\n          style={{width: \"100%\"}}\n        >\n          <Button\n            variant=\"contained\"\n            style={{width: \"100%\"}}\n          >\n            Download claim URLs\n          </Button>\n        </HyperLink>\n      )}\n      {responses.length > 0 && (\n        <HyperLink\n          href={hyperLinkData(responses)}\n          download=\"responses.json\"\n          underline=\"none\"\n          style={{width: \"100%\"}}\n        >\n          <Button\n            variant=\"contained\"\n            style={{width: \"100%\"}}\n          >\n            Download distribution responses\n          </Button>\n        </HyperLink>\n      )}\n    </Stack>\n  );\n};\n","import React from \"react\";\nimport {\n  HashRouter,\n  Link,\n  Route,\n  Switch,\n} from \"react-router-dom\";\n\nimport { createTheme, ThemeProvider } from \"@mui/material/styles\";\nimport CssBaseline from \"@mui/material/CssBaseline\";\nimport {\n  Box,\n  Link as HyperLink,\n  Stack,\n} from \"@mui/material\";\n\nimport \"./App.css\";\nimport {\n  useColorMode,\n} from \"./contexts\";\nimport Header from \"./components/Header/Header\";\nimport { Claim } from \"./components/Claim\";\nimport { Close } from \"./components/Close\";\nimport { Create } from \"./components/Create\";\n\nconst WHITESPACE = \"\\u00A0\";\n\ntype AboutProps = {};\n\nconst About = (\n  props : AboutProps,\n) => {\n  const summary = (\n    <Stack spacing={1}>\n      <div>\n      The Gumdrop program leverages the Solana blockchain and merkle trees to\n      facilitate airdrops to a large number of whitelisted users at a low cost\n      to creators.\n      </div>\n\n      <div>\n      In the Solana ecosystem, the cost of token airdrops is currently largely\n      due to rent costs being{WHITESPACE}\n      <HyperLink\n        href=\"https://docs.solana.com/implemented-proposals/rent\"\n        underline=\"none\"\n      >\n        \"fixed at the genesis\"\n      </HyperLink>\n      . With the large increase in SOLUSD since genesis, rent costs when\n      creating accounts for thousands of users have duly skyrocketed.\n      </div>\n\n      <div>\n      Simultaneously, NFT projects often have a presale to early project\n      followers and contributors. However, the candy-machine doesn't have the\n      ability to grant early minting to a whitelisted subset of wallets while\n      also using the same asset configuration for open launch.\n      </div>\n\n      <div>\n      Gumdrop (originally pioneered for token airdrops by{\" \"}\n      <HyperLink\n        href=\"https://github.com/Uniswap/merkle-distributor\"\n        underline=\"none\"\n      >\n        Uniswap\n      </HyperLink>\n      {\" \"}and ported to Solana by{WHITESPACE}\n      <HyperLink\n        href=\"https://github.com/saber-hq/merkle-distributor\"\n        underline=\"none\"\n      >\n        Saber\n      </HyperLink>) solves both these issues by building a space-efficient hash\n      structure (the merkle tree) such that an on-chain program can validate\n      whether the user is part of a whitelist. Moreover, Gumdrop\n      allows creators to directly send whitelisted users an airdrop reclamation\n      link by building the tree with off-chain handles (e.g email, discord,\n      etc) and allowing the user to redeem into any wallet.\n      </div>\n    </Stack>\n  );\n\n  const create= (\n    <Stack spacing={1}>\n      <Link to=\"/create\">\n        CREATION\n      </Link>\n\n      <div>\n      Creation builds a whitelist of users that can claim either existing\n      fungible tokens or directly mint from a pre-sale candy-machine.\n      </div>\n\n      <div>\n      Creators must choose a mint or a candy-machine config and UUID, an\n      off-chain notification method (based on the handles supplied below, e.g\n      email, discord, etc), and supply a list of recipients and balances with\n      the following JSON schema{WHITESPACE}\n      <HyperLink\n        href={`data:text/plain;charset=utf-8,${JSON.stringify(require(\"./example.json\"))}`}\n        download=\"example.json\"\n        underline=\"none\"\n      >\n      (Click here for an example)\n      </HyperLink>\n      </div>\n\n      <pre style={{ fontSize: 14 }}>{`\n[\n  {\n    \"handle\": \"<DISTRIBUTION-SPECIFIC-HANDLE>\"\n    \"amount\": <#-TOKENS-OR-CANDY-MINTS>\n  },\n  ...\n]`}</pre>\n\n      <div>\n      NB: When a candy-machine is supplied, update authority for the\n      candy-machine will be transferred to the Gumdrop state. This can\n      be reclaimed by closing the Gumdrop.\n      </div>\n    </Stack>\n  );\n\n  const claim = (\n    <Stack spacing={1}>\n      <Link to=\"/claim\">\n        CLAIMS\n      </Link>\n\n      <div>\n      Claims are redeemed through a URL with query parameters holding\n      claim-specific keys. Claimants will need to verify ownership of the\n      specified handle by answering a OTP challenge and pay the rent and\n      minting fees if applicable.\n      </div>\n    </Stack>\n  );\n\n  const close = (\n    <Stack spacing={1}>\n      <Link to=\"/close\">\n        CLOSING\n      </Link>\n\n      <div>\n      Closing the Gumdrop cleans up the on-chain state and allows\n      creators to recycle any lamports held for rent-exemption after the\n      airdrop is complete.\n      </div>\n\n      <div>\n      When closing a candy-machine-integrated distributor, update authority\n      will be transferred back to the wallet owner.\n      </div>\n    </Stack>\n  );\n\n  const steps = [\n    { name: \"summary\" , inner: summary } ,\n    { name: \"create\"  , inner: create  } ,\n    { name: \"claim\"   , inner: claim   } ,\n    { name: \"close\"   , inner: close   } ,\n  ];\n  return (\n    <Stack\n      alignContent=\"left\"\n      textAlign=\"left\"\n      spacing={2}\n    >\n      {steps.map(s => s.inner)}\n    </Stack>\n  );\n};\n\nconst getWindowDimensions = () => {\n  const { innerWidth: width, innerHeight: height } = window;\n  return {\n    width,\n    height,\n  };\n};\n\n// eslint-disable-next-line\nconst useWindowDimensions = () => {\n  const [windowDimensions, setWindowDimensions] = React.useState(\n    getWindowDimensions()\n  );\n\n  React.useEffect(() => {\n    const handleResize = () => {\n      setWindowDimensions(getWindowDimensions());\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []);\n\n  return windowDimensions;\n};\n\nfunction App() {\n  const colorModeCtx = useColorMode();\n\n  React.useEffect(() => {}, [colorModeCtx.mode]);\n\n  const theme = React.useMemo(\n    () => {\n      let mode;\n      if (colorModeCtx.mode === \"dark\" || !colorModeCtx.mode) {\n        mode = \"dark\";\n      } else {\n        mode = \"light\";\n      }\n\n      return createTheme({\n        palette: {\n          mode,\n        },\n      })\n    },\n    [colorModeCtx.mode]\n  );\n\n  const { height } = useWindowDimensions();\n\n  return (\n    <div className=\"App\" style={{ backgroundColor: \"transparent\" }}>\n      <ThemeProvider theme={theme}>\n        <CssBaseline />\n        <Header />\n        <Box\n          height={ `${height * 0.8}px` }\n          width=\"60ch\"\n          style={{\n            marginLeft: \"auto\",\n            marginRight: \"auto\",\n          }}\n        >\n          <Box height=\"60px\" />\n          <HashRouter>\n            <Switch>\n              <Route path=\"/create\" component={Create} />\n              <Route path=\"/claim\" component={Claim} />\n              <Route path=\"/close\" component={Close} />\n              <Route path=\"/\" component={About} />\n            </Switch>\n          </HashRouter>\n          <Box height=\"80px\" />\n        </Box>\n      </ThemeProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport {\n  AccountsProvider,\n  WalletProvider,\n  ConnectionProvider,\n  ColorModeContextProvider,\n} from \"./contexts\";\n\nimport \"antd/dist/antd.css\";\nimport \"@fontsource/open-sans\";\nimport \"@fontsource/roboto\";\nimport \"@fontsource/sora\";\n\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <ConnectionProvider>\n      <WalletProvider>\n        <AccountsProvider>\n          <ColorModeContextProvider>\n            <App />\n          </ColorModeContextProvider>\n        </AccountsProvider>\n      </WalletProvider>\n    </ConnectionProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\nreportWebVitals();\n","import BN from 'bn.js';\n\nexport const TEN = new BN(10);\nexport const HALF_WAD = TEN.pow(new BN(18));\nexport const WAD = TEN.pow(new BN(18));\nexport const RAY = TEN.pow(new BN(27));\nexport const ZERO = new BN(0);\n","import { useCallback, useState } from 'react';\nimport { MintInfo } from '@solana/spl-token';\n\nimport { TokenAccount } from './../models';\nimport { PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport { WAD, ZERO } from '../constants';\nimport { TokenInfo } from '@solana/spl-token-registry';\n\nexport type KnownTokenMap = Map<string, TokenInfo>;\n\nexport const formatPriceNumber = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 8,\n});\n\nexport function useLocalStorageState(key: string, defaultState?: string) {\n  const [state, setState] = useState(() => {\n    // NOTE: Not sure if this is ok\n    const storedState = localStorage.getItem(key);\n    if (storedState) {\n      return JSON.parse(storedState);\n    }\n    return defaultState;\n  });\n\n  const setLocalStorageState = useCallback(\n    newState => {\n      const changed = state !== newState;\n      if (!changed) {\n        return;\n      }\n      setState(newState);\n      if (newState === null) {\n        localStorage.removeItem(key);\n      } else {\n        try {\n          localStorage.setItem(key, JSON.stringify(newState));\n        } catch {\n          // ignore\n        }\n      }\n    },\n    [state, key],\n  );\n\n  return [state, setLocalStorageState];\n}\n\nexport const findProgramAddress = async (\n  seeds: (Buffer | Uint8Array)[],\n  programId: PublicKey,\n) => {\n  const key =\n    'pda-' +\n    seeds.reduce((agg, item) => agg + item.toString('hex'), '') +\n    programId.toString();\n  let cached = localStorage.getItem(key);\n  if (cached) {\n    const value = JSON.parse(cached);\n\n    return [value.key, parseInt(value.nonce)] as [string, number];\n  }\n\n  const result = await PublicKey.findProgramAddress(seeds, programId);\n\n  try {\n    localStorage.setItem(\n      key,\n      JSON.stringify({\n        key: result[0].toBase58(),\n        nonce: result[1],\n      }),\n    );\n  } catch {\n    // ignore\n  }\n\n  return [result[0].toBase58(), result[1]] as [string, number];\n};\n\n// shorten the checksummed version of the input address to have 4 characters at start and end\nexport function shortenAddress(address: string, chars = 4): string {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n}\n\nexport function getTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownSymbol = map.get(mintAddress)?.symbol;\n  if (knownSymbol) {\n    return knownSymbol;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\nexport function getVerboseTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownName = map.get(mintAddress)?.name;\n  if (knownName) {\n    return knownName;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\n\nexport function getTokenByName(tokenMap: KnownTokenMap, name: string) {\n  let token: TokenInfo | null = null;\n  for (const val of tokenMap.values()) {\n    if (val.symbol === name) {\n      token = val;\n      break;\n    }\n  }\n  return token;\n}\n\nexport function getTokenIcon(\n  map: KnownTokenMap,\n  mintAddress?: string | PublicKey,\n): string | undefined {\n  const address =\n    typeof mintAddress === 'string' ? mintAddress : mintAddress?.toBase58();\n  if (!address) {\n    return;\n  }\n\n  return map.get(address)?.logoURI;\n}\n\nexport function isKnownMint(map: KnownTokenMap, mintAddress: string) {\n  return !!map.get(mintAddress);\n}\n\nexport const STABLE_COINS = new Set(['USDC', 'wUSDC', 'USDT']);\n\nexport function chunks<T>(array: T[], size: number): T[][] {\n  return Array.apply<number, T[], T[][]>(\n    0,\n    new Array(Math.ceil(array.length / size)),\n  ).map((_, index) => array.slice(index * size, (index + 1) * size));\n}\n\nexport function toLamports(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  return Math.floor(amount * precision);\n}\n\nexport function wadToLamports(amount?: BN): BN {\n  return amount?.div(WAD) || ZERO;\n}\n\nexport function fromLamports(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount = Math.floor(\n    typeof account === 'number'\n      ? account\n      : BN.isBN(account)\n      ? account.toNumber()\n      : account.info.amount.toNumber(),\n  );\n\n  const precision = Math.pow(10, mint?.decimals || 9);\n  return (amount / precision) * rate;\n}\n\nexport const tryParseKey = (key: string): PublicKey | null => {\n  try {\n    return new PublicKey(key);\n  } catch (error) {\n    return null;\n  }\n};\n\nvar SI_SYMBOL = ['', 'k', 'M', 'G', 'T', 'P', 'E'];\n\nconst abbreviateNumber = (number: number, precision: number) => {\n  let tier = (Math.log10(number) / 3) | 0;\n  let scaled = number;\n  let suffix = SI_SYMBOL[tier];\n  if (tier !== 0) {\n    let scale = Math.pow(10, tier * 3);\n    scaled = number / scale;\n  }\n\n  return scaled.toFixed(precision) + suffix;\n};\n\nexport const formatAmount = (\n  val: number,\n  precision: number = 2,\n  abbr: boolean = true,\n) => (abbr ? abbreviateNumber(val, precision) : val.toFixed(precision));\n\nexport function formatTokenAmount(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n  prefix = '',\n  suffix = '',\n  precision = 2,\n  abbr = false,\n): string {\n  if (!account) {\n    return '';\n  }\n\n  return `${[prefix]}${formatAmount(\n    fromLamports(account, mint, rate),\n    precision,\n    abbr,\n  )}${suffix}`;\n}\n\nexport const formatUSD = new Intl.NumberFormat('en-US', {\n  style: 'currency',\n  currency: 'USD',\n});\n\nconst numberFormater = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport const formatNumber = {\n  format: (val?: number) => {\n    if (!val) {\n      return '--';\n    }\n\n    return numberFormater.format(val);\n  },\n};\n\nexport const formatPct = new Intl.NumberFormat('en-US', {\n  style: 'percent',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport function convert(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  let result = (amount / precision) * rate;\n\n  return result;\n}\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n","import {\n  Connection as RPCConnection,\n  Keypair,\n  PublicKey,\n  SystemProgram,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport {\n  Token,\n} from \"@solana/spl-token\";\nimport { sha256 } from \"js-sha256\";\nimport BN from 'bn.js';\nimport * as bs58 from \"bs58\";\n\nimport {\n  getCandyConfig,\n  getCandyMachineAddress,\n  getCandyMachine,\n  getCreatorTokenAccount,\n  getEdition,\n  getEditionMarkerPda,\n  getMintInfo,\n} from \"./accounts\";\nimport {\n  CANDY_MACHINE_ID,\n  GUMDROP_DISTRIBUTOR_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n} from \"./ids\";\nimport {\n  MerkleTree,\n} from \"./merkleTree\";\n\nexport type ClaimantInfo = {\n  handle : string,\n  amount : number,\n  edition : number,\n\n  pin    : BN,\n  url    : string,\n\n  seed   : PublicKey,\n  secret : PublicKey,\n};\n\nconst csvStringToArray = (strData) => {\n  const objPattern = new RegExp((\"(\\\\,|\\\\r?\\\\n|\\\\r|^)(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|([^\\\\,\\\\r\\\\n]*))\"),\"gi\");\n  let arrMatches : RegExpExecArray | null = null;\n  let arrData : Array<Array<string>> = [[]];\n  while (!!(arrMatches = objPattern.exec(strData))) {\n    if (arrMatches[1].length && arrMatches[1] !== \",\")\n      arrData.push([]);\n    arrData[arrData.length - 1].push(\n      arrMatches[2]\n        ? arrMatches[2].replace(new RegExp( \"\\\"\\\"\", \"g\" ), \"\\\"\")\n        : arrMatches[3]);\n  }\n  return arrData;\n}\n\nexport type Claimants = Array<ClaimantInfo>;\nexport const parseClaimants = (\n  input : string,\n  filename : string,\n  method : string,\n) : Claimants => {\n  const extension = filename.match(/\\.[0-9a-z]+$/i);\n  if (extension === null) {\n    throw new Error(`Could not parse file extension from ${filename}`);\n  }\n  switch (extension[0]) {\n    case \".csv\": {\n      const arr = csvStringToArray(input);\n      // TODO: more robust\n      let search;\n      if (method === \"aws-sms\") {\n        search = \"phone number\";\n      } else if (method === \"aws-email\") {\n        search = \"email\";\n      } else {\n        throw new Error(`Cannot parse csv for ${search}`);\n      }\n      const foundIdx = arr[0].findIndex(s => s.includes(search));\n      if (foundIdx === -1)\n        throw new Error(`Could not find ${search} index`);\n\n      const numbers = new Set(\n        arr.slice(1)\n           .filter(arr => arr[foundIdx].length > 0)\n           .map(arr => arr[foundIdx])\n      );\n\n      return [...numbers].map((n, idx) => {\n        return {\n          handle : n,\n          amount : 1,\n          edition : idx,\n        } as any;\n      });\n    }\n    case \".json\": {\n      const json = JSON.parse(input);\n      return json.map(obj => {\n        return {\n          handle : obj.handle,\n          amount : obj.amount,\n          edition: obj.edition,\n          url    : obj.url,\n        };\n      });\n    }\n    default: {\n      throw new Error(`Cannot parse file format ${extension} from ${filename}`);\n    }\n  }\n};\n\nconst explorerUrlFor = (env : string, key : string) => {\n  return `https://explorer.solana.com/address/${key}?cluster=${env}`;\n}\n\nexport type ClaimInfo = { [key: string]: any };\n\nexport const dropInfoFor = (\n  env : string,\n  integration : string,\n  tokenMint : string,\n  candyConfig : string,\n  masterMint : string,\n) => {\n  switch (integration) {\n    case \"transfer\":\n      return { type: \"Token\", meta: explorerUrlFor(env, tokenMint) };\n    case \"candy\":\n      return { type: \"Candy\", meta: explorerUrlFor(env, candyConfig) };\n    case \"edition\":\n      return { type: \"Edition\", meta: explorerUrlFor(env, masterMint) };\n    default:\n      throw new Error(`Unknown claim integration method ${integration}`);\n  }\n}\n\nexport const validateTransferClaims = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  claimants : Claimants,\n  mintStr : string,\n) : Promise<ClaimInfo> => {\n  claimants.forEach((c, idx) => {\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\n    if (!c.amount) throw new Error(`Claimant ${idx} doesn't have amount`);\n    if (c.amount === 0) throw new Error(`Claimant ${idx} amount is 0`);\n  });\n\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\n  const mint = await getMintInfo(connection, mintStr);\n  const source = await getCreatorTokenAccount(\n    walletKey,\n    connection,\n    mint.key,\n    total\n  );\n\n  return {\n    total: total,\n    mint: mint,\n    source: source,\n  };\n}\n\nexport const validateCandyClaims = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  claimants : Claimants,\n  candyConfig : string,\n  candyUuid : string,\n) : Promise<ClaimInfo> => {\n  claimants.forEach((c, idx) => {\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\n    if (!c.amount) throw new Error(`Claimant ${idx} doesn't have amount`);\n    if (c.amount === 0) throw new Error(`Claimant ${idx} amount is 0`);\n  });\n\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\n  const configKey = await getCandyConfig(connection, candyConfig);\n  const [candyMachineKey, ] = await getCandyMachineAddress(configKey, candyUuid);\n\n  const candyMachine = await getCandyMachine(connection, candyMachineKey);\n\n  const remaining = candyMachine.data.itemsAvailable.toNumber() - candyMachine.itemsRedeemed.toNumber();\n  if (isNaN(remaining)) {\n    // TODO: should this have an override?\n    throw new Error(`Could not calculate how many candy machine items are remaining`);\n  }\n  if (remaining < total) {\n    throw new Error(`Distributor is allocated more mints (${total}) `\n                  + `than the candy machine has remaining (${remaining})`);\n  }\n  if (!candyMachine.authority.equals(walletKey)) {\n    throw new Error(`Candy machine authority does not match wallet public key`);\n  }\n\n  return {\n    total: total,\n    config: configKey,\n    uuid: candyUuid,\n    candyMachineKey: candyMachineKey,\n  };\n}\n\nconst getOffsetFromStart = (edition: BN) => {\n  return edition.mod(new BN(31 * 8));\n};\n\nconst getIndex = (offsetFromStart: BN) => {\n  return offsetFromStart.div(new BN(8));\n};\n\nconst getOffsetFromRight = (offsetFromStart: BN) => {\n  return new BN(7).sub(offsetFromStart.mod(new BN(8)));\n};\n\nconst getIndexAndMask = (edition: BN) => {\n  const offsetFromStart = getOffsetFromStart(edition);\n  return {\n    index: getIndex(offsetFromStart).toNumber(),\n    mask: new BN(1).shln(getOffsetFromRight(offsetFromStart).toNumber()).toNumber(),\n  };\n};\n\nconst editionTaken = (marker : Array<number>, edition : BN) : boolean => {\n  let m = getIndexAndMask(edition);\n  return (marker[m.index] & m.mask) !== 0;\n}\n\nconst setEditionTaken = (marker : Array<number>, edition : BN) => {\n  let m = getIndexAndMask(edition);\n  marker[m.index] = marker[m.index] | m.mask;\n}\n\nexport const validateEditionClaims = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  claimants : Claimants,\n  masterMintStr : string,\n) : Promise<ClaimInfo> => {\n  claimants.forEach((c, idx) => {\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\n    if (c.amount !== 1) {\n      throw new Error(`Claimant ${idx} has amount ${c.amount}. Expected 1 for edition gumdrop`);\n    }\n  });\n\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\n  const masterMint = await getMintInfo(connection, masterMintStr);\n  const masterTokenAccount = await getCreatorTokenAccount(\n    walletKey,\n    connection,\n    masterMint.key,\n    1 // just check that the creator has the master mint\n  );\n\n  const masterEditionKey = await getEdition(masterMint.key);\n  const masterEdition = await connection.getAccountInfo(masterEditionKey);\n  if (masterEdition === null) {\n    throw new Error(`Could not fetch master edition`);\n  }\n  console.log(\"Master edition\", masterEdition);\n\n  // maxSupply is an option, 9 bytes, first is 0 means is none\n  const currentSupply = new BN(masterEdition.data.slice(1, 1+8), 8, \"le\").toNumber();\n  let maxSupply;\n  if (masterEdition.data[9] === 0) {\n      maxSupply = null;\n  } else {\n      maxSupply = new BN(masterEdition.data.slice(10, 10+8), 8, \"le\").toNumber();\n  }\n  console.log(\"Max supply\", maxSupply);\n  console.log(\"Current supply\", currentSupply);\n\n  if (maxSupply !== null && maxSupply < total) {\n    throw new Error(`Distributor is allocated more editions (${total}) `\n                  + `than the master has total (${maxSupply})`);\n  }\n\n  // Whether an edition has been claimed is a single bit in a paginated account\n  // (pda off of master mint). The following code does some sanity checks\n  // around max supply and internally whether the distribution list has\n  // duplicate editions, and also checks if the editions were already taken on\n  // chain.\n  //\n  // There is a race condition since the authority to mint is still currently\n  // the wallet but it seems like a user error to have other editions being\n  // minted while a gumdrop is being created\n  const editions : { [key: number]: number } = {};\n  const editionMarkers : Array<[PublicKey, Array<number>]> = [];\n  for (let idx = 0; idx < claimants.length; ++idx ) {\n    const c = claimants[idx];\n    if (c.edition === undefined) throw new Error(`Claimant ${idx} doesn't have edition`);\n    if (c.edition <= 0) {\n      throw new Error(`Claimant ${idx} assigned invalid edition ${c.edition}`);\n    }\n    if (c.edition > maxSupply) {\n      throw new Error(`Claimant ${idx} assigned edition ${c.edition} which is beyond the max supply`);\n    }\n    if (c.edition in editions) {\n      throw new Error(`Claimant ${idx} and ${editions[c.edition]} are both assigned to edition ${c.edition}`);\n    }\n    const edition = new BN(c.edition);\n    const markerKey = await getEditionMarkerPda(masterMint.key, edition);\n    let markerData = editionMarkers.find(pm => pm[0].equals(markerKey));\n    if (markerData === undefined) {\n      const markerAcc = await connection.getAccountInfo(markerKey);\n      if (markerAcc === null) {\n        editionMarkers.push([markerKey, Array<number>(31)]);\n      } else {\n        editionMarkers.push([markerKey, [...markerAcc.data.slice(1, 32)]]);\n      }\n      markerData = editionMarkers[editionMarkers.length - 1];\n    }\n\n    if (markerData === undefined) {\n      throw new Error(`Internal Error: Edition marker info still undefined ${c.edition}`);\n    }\n\n    if (editionTaken(markerData[1], edition)) {\n      throw new Error(`Claimant ${idx} is assigned to edition ${c.edition} which is already taken`);\n    }\n\n    setEditionTaken(markerData[1], edition);\n\n    editions[c.edition] = idx;\n  }\n\n  return {\n    total: total,\n    masterMint: masterMint,\n    masterTokenAccount: masterTokenAccount,\n  };\n}\n\nexport const chunk = (\n  arr : Buffer,\n  len : number,\n) : Array<Buffer> => {\n  let chunks : Array<Buffer> = [],\n      i = 0,\n      n = arr.length;\n\n  while (i < n) {\n    chunks.push(arr.slice(i, i += len));\n  }\n\n  return chunks;\n}\n\nexport const buildGumdrop = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  needsPin : boolean,\n  claimIntegration : string,\n  host : string,\n  baseKey : PublicKey,\n  temporalSigner : PublicKey,\n  claimants : Claimants,\n  claimInfo  : ClaimInfo,\n) : Promise<Array<TransactionInstruction>> => {\n\n  const leafs : Array<Buffer> = [];\n  for (let idx = 0; idx < claimants.length; ++idx ) {\n    const claimant = claimants[idx];\n    if (!needsPin) {\n      try {\n        claimant.secret = new PublicKey(claimant.handle);\n      } catch (err) {\n        throw new Error(`Invalid claimant wallet handle ${err}`);\n      }\n    } else {\n      const seeds = [\n        claimant.seed.toBuffer(),\n        ...chunk(Buffer.from(claimant.handle), 32),\n        Buffer.from(claimant.pin.toArray(\"le\", 4)),\n      ];\n      const [claimantPda, ] = await PublicKey.findProgramAddress(\n          seeds.map(s => s.slice(0, 32)), GUMDROP_DISTRIBUTOR_ID);\n      claimant.secret = claimantPda;\n    }\n    // TODO: get this clarified with jordan... we can either just assign some\n    // range of editions to a user or give them an amount and just keep a\n    // counter on the distributor... the latter is much less work but we lose\n    // the ability to use gumdrop for auction house winnings and such?\n    const extra = claimIntegration === \"edition\"\n      ? [...new BN(claimant.edition).toArray(\"le\", 8)]\n      : []\n    leafs.push(Buffer.from(\n      [...new BN(idx).toArray(\"le\", 8),\n       ...claimant.secret.toBuffer(),\n       ...claimant.seed.toBuffer(),\n       ...new BN(claimant.amount).toArray(\"le\", 8),\n       ...extra\n      ]\n    ));\n  }\n\n  const tree = new MerkleTree(leafs);\n  const root = tree.getRoot();\n\n  const [distributor, dbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"MerkleDistributor\"),\n      baseKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID);\n\n  for (let idx = 0; idx < claimants.length; ++idx) {\n    const proof = tree.getProof(idx);\n    const verified = tree.verifyProof(idx, proof, root);\n\n    if (!verified) {\n      throw new Error(\"Gumdrop merkle tree verification failed\");\n    }\n\n    const claimant = claimants[idx];\n    const params = [\n      `distributor=${distributor}`,\n      `handle=${encodeURIComponent(claimant.handle)}`,\n      `amount=${claimant.amount}`,\n      `index=${idx}`,\n      `proof=${proof.map(b => bs58.encode(b))}`,\n    ];\n    if (needsPin) {\n      params.push(`pin=${claimant.pin.toNumber()}`);\n    } else {\n      params.push(`pin=NA`);\n    }\n    if (claimIntegration === \"transfer\") {\n      params.push(`tokenAcc=${claimInfo.source}`);\n    } else if (claimIntegration === \"candy\") {\n      params.push(`config=${claimInfo.config}`);\n      params.push(`uuid=${claimInfo.uuid}`);\n    } else {\n      params.push(`master=${claimInfo.masterMint.key}`);\n      params.push(`edition=${claimant.edition}`);\n    }\n    const query = params.join(\"&\");\n\n    claimant.url = `${host}#/claim?${query}`;\n  }\n\n  // initial merkle-distributor state\n  const instructions = Array<TransactionInstruction>();\n  instructions.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: baseKey                 , isSigner: true  , isWritable: false } ,\n          { pubkey: distributor             , isSigner: false , isWritable: true  } ,\n          { pubkey: walletKey               , isSigner: true  , isWritable: false } ,\n          { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:new_distributor\")).slice(0, 8),\n        ...new BN(dbump).toArray(\"le\", 1),\n        ...root,\n        ...temporalSigner.toBuffer(),\n      ])\n  }));\n\n  if (claimIntegration === \"transfer\") {\n    instructions.push(Token.createApproveInstruction(\n      TOKEN_PROGRAM_ID,\n      claimInfo.source,\n      distributor,\n      walletKey,\n      [],\n      claimInfo.total\n    ));\n  } else if (claimIntegration === \"candy\") {\n    const [distributorWalletKey, ] = await PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"Wallet\"),\n        distributor.toBuffer(),\n      ],\n      GUMDROP_DISTRIBUTOR_ID\n    );\n\n    instructions.push(new TransactionInstruction({\n        programId: CANDY_MACHINE_ID,\n        keys: [\n            { pubkey: claimInfo.candyMachineKey,isSigner: false , isWritable: true  } ,\n            { pubkey: walletKey               , isSigner: true  , isWritable: false } ,\n        ],\n        data: Buffer.from([\n          ...Buffer.from(sha256.digest(\"global:update_authority\")).slice(0, 8),\n          ...new BN(1).toArray(\"le\", 1),  // optional exists...\n          ...distributorWalletKey.toBuffer(),\n        ])\n    }));\n  } else if (claimIntegration === \"edition\") {\n    // transfer master edition to distributor\n    const [distributorTokenKey, ] = await PublicKey.findProgramAddress(\n      [\n        distributor.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        claimInfo.masterMint.key.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    );\n\n    instructions.push(Token.createAssociatedTokenAccountInstruction(\n        SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n        TOKEN_PROGRAM_ID,\n        claimInfo.masterMint.key,\n        distributorTokenKey,\n        distributor,\n        walletKey,\n      ));\n\n    instructions.push(Token.createTransferInstruction(\n        TOKEN_PROGRAM_ID,\n        claimInfo.masterTokenAccount,\n        distributorTokenKey,\n        walletKey,\n        [],\n        1\n      ));\n  }\n\n  return instructions;\n}\n\nexport const closeGumdrop = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  base : Keypair,\n  claimMethod : string,\n  candyConfig : string,\n  candyUuid : string,\n  masterMint : string,\n) : Promise<Array<TransactionInstruction>> => {\n  const [distributorKey, dbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"MerkleDistributor\"),\n      base.publicKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID);\n\n  const [distributorWalletKey, wbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"Wallet\"),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  let extraKeys;\n  if (claimMethod === \"candy\") {\n    const configKey = await getCandyConfig(connection, candyConfig);\n    const [candyMachineKey, ] = await getCandyMachineAddress(\n      configKey, candyUuid);\n\n   extraKeys = [\n          { pubkey: candyMachineKey         , isSigner: false , isWritable: true  } ,\n          { pubkey: CANDY_MACHINE_ID        , isSigner: false , isWritable: false } ,\n    ];\n  } else {\n    extraKeys = [];\n  }\n\n  const instructions = Array<TransactionInstruction>();\n  if (claimMethod === \"edition\") {\n    let masterMintKey: PublicKey;\n    try {\n      masterMintKey = new PublicKey(masterMint);\n    } catch (err) {\n      throw new Error(`Invalid mint key ${err}`);\n    }\n    const [distributorTokenKey, ] = await PublicKey.findProgramAddress(\n      [\n        distributorKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        masterMintKey.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    );\n\n    const [walletTokenKey, ] = await PublicKey.findProgramAddress(\n      [\n        walletKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        masterMintKey.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    );\n\n    instructions.push(new TransactionInstruction({\n        programId: GUMDROP_DISTRIBUTOR_ID,\n        keys: [\n            { pubkey: base.publicKey          , isSigner: true  , isWritable: false } ,\n            { pubkey: distributorKey          , isSigner: false , isWritable: false } ,\n            { pubkey: distributorTokenKey     , isSigner: false , isWritable: true  } ,\n            { pubkey: walletTokenKey          , isSigner: false , isWritable: true  } ,\n            { pubkey: walletKey               , isSigner: false , isWritable: true  } ,\n            { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\n            { pubkey: TOKEN_PROGRAM_ID        , isSigner: false , isWritable: false } ,\n        ],\n        data: Buffer.from([\n          ...Buffer.from(sha256.digest(\"global:close_distributor_token_account\")).slice(0, 8),\n          ...new BN(dbump).toArray(\"le\", 1),\n        ])\n    }));\n  }\n\n  instructions.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: base.publicKey          , isSigner: true  , isWritable: false } ,\n          { pubkey: distributorKey          , isSigner: false , isWritable: true  } ,\n          { pubkey: distributorWalletKey    , isSigner: false , isWritable: true  } ,\n          { pubkey: walletKey               , isSigner: true  , isWritable: true  } ,\n          { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_PROGRAM_ID        , isSigner: false , isWritable: false } ,\n          ...extraKeys,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:close_distributor\")).slice(0, 8),\n        ...new BN(dbump).toArray(\"le\", 1),\n        ...new BN(wbump).toArray(\"le\", 1),\n      ])\n  }));\n\n  return instructions;\n}\n"],"sourceRoot":""}