{"version":3,"sources":["utils/claimant.ts","utils/transactions.ts","contexts/ConnectionContext.tsx","utils/merkleTree.ts","utils/programIds.ts","components/DefaultModal/index.tsx","contexts/AccountContext.tsx","utils/eventEmitter.ts","components/Settings/index.tsx","contexts/ColorModeContext.tsx","utils/notifications.tsx","utils/borsh.ts","utils/merkleDistributor.ts","utils/ids.ts","components/Claim.tsx","contexts/WalletContext/WalletContext.tsx","contexts/WalletContext/wallet.less","contexts/ModalContext.tsx","components/Header/Header.tsx","components/Close.tsx","utils/communication.ts","components/DragAndDrop.tsx","components/Create.tsx","App.tsx","reportWebVitals.ts","index.tsx","utils/accounts.ts","constants/math.ts","utils/utils.ts"],"names":["parseClaimants","input","filename","method","extension","match","Error","search","arr","strData","objPattern","RegExp","arrMatches","arrData","exec","length","push","replace","csvStringToArray","foundIdx","findIndex","s","includes","numbers","Set","slice","filter","map","n","idx","handle","amount","edition","JSON","parse","obj","url","explorerUrlFor","env","key","dropInfoFor","integration","tokenMint","candyConfig","masterMint","type","meta","validateTransferClaims","connection","walletKey","claimants","mintStr","a","forEach","c","total","reduce","acc","getMintInfo","mint","getCreatorTokenAccount","source","validateCandyClaims","candyUuid","getCandyConfig","configKey","getCandyMachineAddress","candyMachineKey","getCandyMachine","candyMachine","remaining","data","itemsAvailable","toNumber","itemsRedeemed","isNaN","authority","equals","config","uuid","getIndex","offsetFromStart","div","BN","getOffsetFromRight","sub","mod","getIndexAndMask","getOffsetFromStart","index","mask","shln","editionTaken","marker","m","setEditionTaken","validateEditionClaims","masterMintStr","masterTokenAccount","getEdition","masterEditionKey","getAccountInfo","masterEdition","console","log","currentSupply","maxSupply","editions","editionMarkers","undefined","getEditionMarkerPda","markerKey","markerData","find","pm","markerAcc","Array","chunk","len","chunks","i","buildGumdrop","needsPin","claimIntegration","host","baseKey","temporalSigner","claimInfo","extraParams","leafs","claimant","secret","PublicKey","seeds","seed","toBuffer","Buffer","from","pin","toArray","findProgramAddress","GUMDROP_DISTRIBUTOR_ID","claimantPda","extra","tree","MerkleTree","root","getRoot","distributor","dbump","proof","getProof","verifyProof","params","encodeURIComponent","b","bs58","query","join","instructions","TransactionInstruction","programId","keys","pubkey","isSigner","isWritable","SystemProgram","sha256","digest","Token","createApproveInstruction","TOKEN_PROGRAM_ID","distributorWalletKey","CANDY_MACHINE_ID","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","distributorTokenKey","createAssociatedTokenAccountInstruction","createTransferInstruction","closeGumdrop","base","claimMethod","publicKey","distributorKey","wbump","extraKeys","masterMintKey","walletTokenKey","getUnixTs","Date","getTime","envFor","_rpcEndpoint","explorerLinkFor","txid","sendSignedTransaction","signedTransaction","timeout","rawTransaction","serialize","startTime","slot","sendRawTransaction","skipPreflight","debug","done","sleep","awaitTransactionSignatureConfirmation","confirmation","err","error","simulateResult","simulateTransaction","value","logs","line","startsWith","stringify","transaction","commitment","_recentBlockhash","_disableBlockhashCaching","recentBlockhash","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","args","encoding","_rpcRequest","res","message","result","queryStatus","status","confirmations","subId","Promise","resolve","reject","setTimeout","warn","onSignature","context","e","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener","ENDPOINTS","name","endpoint","ChainId","MainnetBeta","Devnet","DEFAULT","ConnectionContext","React","createContext","setEndpoint","Connection","tokens","tokenMap","Map","ConnectionProvider","children","useLocalStorageState","useMemo","end","useState","setTokens","setTokenMap","useEffect","TokenListProvider","then","container","list","excludeByTag","filterByChainId","getList","knownMints","item","set","address","id","onAccountChange","Keypair","generate","removeAccountChangeListener","onSlotChange","removeSlotChangeListener","Provider","useConnection","useContext","useConnectionConfig","SequenceType","getErrorForTransaction","confirmTransaction","getParsedConfirmedTransaction","tx","errors","logMessages","regex","lastIndex","sendTransactionWithRetry","wallet","signers","includesFeePayer","block","beforeSend","WalletNotConnectedError","Transaction","instruction","add","getRecentBlockhash","blockhash","setSigners","partialSign","signTransaction","layers","this","hashes","nodeHash","cur","nxt","internalHash","layer","sibling","Math","floor","el","pair","keccak_256","first","second","sort","compare","fst","snd","leaf","programIds","token","associatedToken","bpf_upgrade_loader","BPF_UPGRADE_LOADER_ID","system","SYSTEM","memo","MEMO_ID","DefaultModal","props","bodyStyle","closeIcon","width","rest","style","background","borderRadius","display","flexDirection","alignItems","footer","AccountsContext","pendingCalls","genericCache","pendingMintCalls","mintCache","pubKey","info","deserializeMint","TokenAccountParser","buffer","deserializeAccount","account","keyToAccountParser","cache","emitter","EventEmitter","parser","toBase58","get","isActive","deserialize","registerParser","delete","Function","isNew","has","raiseCacheUpdated","raiseCacheDeleted","byParser","queryMint","getMint","addMint","UseNativeAccount","useWallet","nativeAccount","setNativeAccount","updateCache","useCallback","wrapped","WRAPPED_SOL_MINT","owner","u64","lamports","delegate","delegatedAmount","isInitialized","isFrozen","isNative","rentExemptReserve","closeAuthority","wrapNativeAccount","updateAccount","PRECACHED_OWNERS","precacheUserTokenAccounts","getTokenAccountsByOwner","AccountsProvider","tokenAccounts","setTokenAccounts","userAccounts","setUserAccounts","selectUserAccounts","accounts","subs","onCache","tokenSubID","onProgramAccountChange","accountId","accountInfo","AccountLayout","span","removeProgramAccountChangeListener","decode","fromBuffer","delegateOption","state","isNativeOption","closeAuthorityOption","MintLayout","mintInfo","mintAuthorityOption","mintAuthority","supply","freezeAuthorityOption","freezeAuthority","CacheUpdateEvent","CacheDeleteEvent","MarketUpdateEvent","ids","Emitter","callback","on","removeListener","emit","Settings","narrow","disconnect","setVisible","useWalletModal","open","setModal","useModal","theme","useTheme","colorModeCtx","useColorMode","handleConnect","ModalEnum","WALLET","connectedActions","click","navigator","clipboard","writeText","notify","description","innerNarrow","shortenAddress","inner","Fragment","catch","expandedExtra","color","variant","drawerOpen","setDrawerOpen","envCollapseOpen","setEnvCollapseOpen","hackySkipSet","toggleDrawer","event","target","classList","contains","drawerC","onClick","anchor","onClose","sx","role","onKeyDown","themeSwitch","ml","toggleColorMode","palette","mode","listHead","primary","primaryTypographyProps","fontSize","fontWeight","letterSpacing","className","in","unmountOnExit","component","disablePadding","p","selected","pl","direction","spacing","justifyContent","marginRight","minWidth","onChange","underline","ColorModeContext","ColorModeContextProvider","setMode","prevMode","placement","notification","opacity","backgroundColor","BinaryReader","prototype","readPubkey","array","readFixedArray","BinaryWriter","writePubkey","writeFixedArray","readPubkeyAsString","base58","encode","writePubkeyAsString","idl","require","coder","Coder","TOKEN_METADATA_PROGRAM_ID","GUMDROP_TEMPORAL_SIGNER","walletKeyOrPda","buildMintClaim","distributorInfo","tokenAcc","tokenAccKey","distTokenAccount","tokenAccountInfo","pdaSeeds","verifyClaim","claimStatus","cbump","setup","temporal","default","claimAirdrop","concat","buildCandyClaim","candyUUID","claimCount","claimCountAccount","nftsAlreadyMinted","claimAccountInfo","count","claimantStr","nftsAvailable","candyMachineMints","buildSingleCandyMint","instrs","candyMachineWallet","candyMachineMint","getMetadata","candyMachineMetadata","candyMachineMaster","createMintAndAccount","SYSVAR_RENT_PUBKEY","SYSVAR_CLOCK_PUBKEY","getMinimumBalanceForRentExemption","fromPubkey","newAccountPubkey","space","createAccount","createInitMintInstruction","createMintToInstruction","buildEditionClaim","newMint","newMetadataKey","masterMetadataKey","newEdition","editionMarkKey","fetchDistributor","distributorStr","ownerStr","fetchNeedsTemporalSigner","indexStr","Number","Claim","location","localStorage","setItem","stored","getItem","queryString","setDistributor","master","setClaimMethod","setTokenAcc","setCandyConfig","setCandyUUID","setMasterMint","editionStr","setEditionStr","setHandle","amountStr","setAmount","setIndex","pinStr","setPin","proofStr","setProof","discordGuild","guild","allFieldsPopulated","editable","setEditable","setTransaction","OTPStr","setOTPStr","asyncNeedsTemporalSigner","setNeedsTemporalSigner","wrap","lambdaAPIEndpoint","sendOTP","preventDefault","connected","split","ret","extraSigners","feePayer","instr","signatures","some","otpQuery","headers","body","fetch","response","json","succeeded","toCheck","MessageId","verifyOTP","OTP","FunctionName","otp","blob","sig","addSignature","fullySigned","claimResult","href","loading","setLoading","loadingProgress","size","position","top","left","marginTop","marginLeft","claimData","label","disabled","steps","fullWidth","labelId","textAlign","multiline","needsTemporalSigner","activeStep","setActiveStep","stepToUse","min","stepper","prev","WalletModalContext","WalletModal","wallets","select","visible","setShowWallets","close","onCancel","height","verticalAlign","lineHeight","marginBottom","icon","alt","src","float","WalletModalProvider","setConnected","keyToDisplay","substring","WalletProvider","getPhantomWallet","getSolflareWallet","getTorusWallet","options","clientId","uxMode","getLedgerWallet","getSolongWallet","getMathWallet","getSolletWallet","onError","autoConnect","ModalContext","removeModal","Header","navs","Box","bgcolor","overflow","Button","Drawer","List","ListItem","ListItemText","Divider","nav","to","ListItemButton","Stack","flexGrow","Close","setBaseKey","submit","fromSecretKey","Uint8Array","closeResult","TextField","FormControl","InputLabel","Select","MenuItem","CircularProgress","formatDropMessage","drop","html","text","subject","distributeAwsSes","auth","accessKeyId","secretAccessKey","client","SESv2Client","region","credentials","single","formatted","Destination","ToAddresses","Content","Simple","Subject","Data","Charset","Body","Html","FromEmailAddress","ListManagementOptions","ContactListName","TopicName","send","SendEmailCommand","messageId","responses","distributeManual","distributeWallet","urlAndHandleFor","DragAndDrop","dropRef","useRef","dragCounter","setDragCounter","dragging","setDragging","handleDrag","stopPropagation","handleDragIn","dataTransfer","items","handleDragOut","remainingDrags","handleDrop","files","clearData","node","current","addEventListener","removeEventListener","shade","ref","randomBytes","buf","window","crypto","getRandomValues","WHITESPACE","distribute","reactModal","renderModal","document","createElement","appendChild","destroyModal","ReactDOM","unmountComponentAtNode","removeChild","onSubmit","onDismiss","render","show","displayModal","finally","hideModal","resendOnlyRender","opt","hyperLinkData","encoded","shouldSendRender","limit","TableContainer","maxHeight","Table","TableHead","TableRow","TableCell","TableBody","border","scope","String","pow","decimals","secretKey","download","Create","setMint","setFilename","setText","claimURLs","setClaimURLs","setResponses","otpAuth","setOtpAuth","commMethod","setCommMethod","commAuth","setCommAuth","commSource","setCommSource","awsAccessKeyId","setAwsAccessKeyId","awsSecretKey","setAwsSecretKey","distributeClaims","dropInfo","mightHaveExisting","resendOnly","origin","createResult","handleFiles","file","reader","FileReader","onload","readAsText","fileUpload","alignContent","padding","hidden","createAirdrop","otpAuthC","rel","commAuthorization","About","getWindowDimensions","innerWidth","innerHeight","App","createTheme","windowDimensions","setWindowDimensions","handleResize","useWindowDimensions","ThemeProvider","CssBaseline","maxWidth","path","reportWebVitals","onPerfEntry","getCLS","getFID","getFCP","getLCP","getTTFB","StrictMode","getElementById","mintKey","mintAccount","mintOwner","totalClaim","creatorTokenKey","creatorTokenAccount","creatorTokenInfo","fetchCoder","fetchIdl","configAccount","candyMachineCoder","candyMachineAccount","editionPageNumber","TEN","Intl","NumberFormat","minimumFractionDigits","maximumFractionDigits","defaultState","storedState","setState","setLocalStorageState","newState","removeItem","chars","apply","ceil","_","currency","ms"],"mappings":"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","file":"static/js/main.7fefe743.chunk.js","sourcesContent":["import {\n  Connection as RPCConnection,\n  Keypair,\n  PublicKey,\n  SystemProgram,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport {\n  Token,\n} from \"@solana/spl-token\";\nimport { sha256 } from \"js-sha256\";\nimport BN from 'bn.js';\nimport * as bs58 from \"bs58\";\n\nimport {\n  getCandyConfig,\n  getCandyMachineAddress,\n  getCandyMachine,\n  getCreatorTokenAccount,\n  getEdition,\n  getEditionMarkerPda,\n  getMintInfo,\n} from \"./accounts\";\nimport {\n  CANDY_MACHINE_ID,\n  GUMDROP_DISTRIBUTOR_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n} from \"./ids\";\nimport {\n  MerkleTree,\n} from \"./merkleTree\";\n\nexport type ClaimantInfo = {\n  handle : string,\n  amount : number,\n  edition : number,\n\n  pin    : BN,\n  url    : string,\n\n  seed   : PublicKey,\n  secret : PublicKey,\n};\n\nconst csvStringToArray = (strData) => {\n  const objPattern = new RegExp((\"(\\\\,|\\\\r?\\\\n|\\\\r|^)(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|([^\\\\,\\\\r\\\\n]*))\"),\"gi\");\n  let arrMatches : RegExpExecArray | null = null;\n  let arrData : Array<Array<string>> = [[]];\n  while (!!(arrMatches = objPattern.exec(strData))) {\n    if (arrMatches[1].length && arrMatches[1] !== \",\")\n      arrData.push([]);\n    arrData[arrData.length - 1].push(\n      arrMatches[2]\n        ? arrMatches[2].replace(new RegExp( \"\\\"\\\"\", \"g\" ), \"\\\"\")\n        : arrMatches[3]);\n  }\n  return arrData;\n}\n\nexport type Claimants = Array<ClaimantInfo>;\nexport const parseClaimants = (\n  input : string,\n  filename : string,\n  method : string,\n) : Claimants => {\n  const extension = filename.match(/\\.[0-9a-z]+$/i);\n  if (extension === null) {\n    throw new Error(`Could not parse file extension from ${filename}`);\n  }\n  switch (extension[0]) {\n    case \".csv\": {\n      const arr = csvStringToArray(input);\n      // TODO: more robust\n      let search;\n      if (method === \"aws-sms\") {\n        search = \"phone number\";\n      } else if (method === \"aws-email\") {\n        search = \"email\";\n      } else {\n        throw new Error(`Cannot parse csv for ${search}`);\n      }\n      const foundIdx = arr[0].findIndex(s => s.includes(search));\n      if (foundIdx === -1)\n        throw new Error(`Could not find ${search} index`);\n\n      const numbers = new Set(\n        arr.slice(1)\n           .filter(arr => arr[foundIdx].length > 0)\n           .map(arr => arr[foundIdx])\n      );\n\n      return [...numbers].map((n, idx) => {\n        return {\n          handle : n,\n          amount : 1,\n          edition : idx,\n        } as any;\n      });\n    }\n    case \".json\": {\n      const json = JSON.parse(input);\n      return json.map(obj => {\n        return {\n          handle : obj.handle,\n          amount : obj.amount,\n          edition: obj.edition,\n          url    : obj.url,\n        };\n      });\n    }\n    default: {\n      throw new Error(`Cannot parse file format ${extension} from ${filename}`);\n    }\n  }\n};\n\nconst explorerUrlFor = (env : string, key : string) => {\n  return `https://explorer.solana.com/address/${key}?cluster=${env}`;\n}\n\nexport type ClaimInfo = { [key: string]: any };\n\nexport const dropInfoFor = (\n  env : string,\n  integration : string,\n  tokenMint : string,\n  candyConfig : string,\n  masterMint : string,\n) => {\n  switch (integration) {\n    case \"transfer\":\n      return { type: \"Token\", meta: explorerUrlFor(env, tokenMint) };\n    case \"candy\":\n      return { type: \"Candy\", meta: explorerUrlFor(env, candyConfig) };\n    case \"edition\":\n      return { type: \"Edition\", meta: explorerUrlFor(env, masterMint) };\n    default:\n      throw new Error(`Unknown claim integration method ${integration}`);\n  }\n}\n\nexport const validateTransferClaims = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  claimants : Claimants,\n  mintStr : string,\n) : Promise<ClaimInfo> => {\n  claimants.forEach((c, idx) => {\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\n    if (!c.amount) throw new Error(`Claimant ${idx} doesn't have amount`);\n    if (c.amount === 0) throw new Error(`Claimant ${idx} amount is 0`);\n  });\n\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\n  const mint = await getMintInfo(connection, mintStr);\n  const source = await getCreatorTokenAccount(\n    walletKey,\n    connection,\n    mint.key,\n    total\n  );\n\n  return {\n    total: total,\n    mint: mint,\n    source: source,\n  };\n}\n\nexport const validateCandyClaims = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  claimants : Claimants,\n  candyConfig : string,\n  candyUuid : string,\n) : Promise<ClaimInfo> => {\n  claimants.forEach((c, idx) => {\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\n    if (!c.amount) throw new Error(`Claimant ${idx} doesn't have amount`);\n    if (c.amount === 0) throw new Error(`Claimant ${idx} amount is 0`);\n  });\n\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\n  const configKey = await getCandyConfig(connection, candyConfig);\n  const [candyMachineKey, ] = await getCandyMachineAddress(configKey, candyUuid);\n\n  const candyMachine = await getCandyMachine(connection, candyMachineKey);\n\n  const remaining = candyMachine.data.itemsAvailable.toNumber() - candyMachine.itemsRedeemed.toNumber();\n  if (isNaN(remaining)) {\n    // TODO: should this have an override?\n    throw new Error(`Could not calculate how many candy machine items are remaining`);\n  }\n  if (remaining < total) {\n    throw new Error(`Distributor is allocated more mints (${total}) `\n                  + `than the candy machine has remaining (${remaining})`);\n  }\n  if (!candyMachine.authority.equals(walletKey)) {\n    throw new Error(`Candy machine authority does not match wallet public key`);\n  }\n\n  return {\n    total: total,\n    config: configKey,\n    uuid: candyUuid,\n    candyMachineKey: candyMachineKey,\n  };\n}\n\nconst getOffsetFromStart = (edition: BN) => {\n  return edition.mod(new BN(31 * 8));\n};\n\nconst getIndex = (offsetFromStart: BN) => {\n  return offsetFromStart.div(new BN(8));\n};\n\nconst getOffsetFromRight = (offsetFromStart: BN) => {\n  return new BN(7).sub(offsetFromStart.mod(new BN(8)));\n};\n\nconst getIndexAndMask = (edition: BN) => {\n  const offsetFromStart = getOffsetFromStart(edition);\n  return {\n    index: getIndex(offsetFromStart).toNumber(),\n    mask: new BN(1).shln(getOffsetFromRight(offsetFromStart).toNumber()).toNumber(),\n  };\n};\n\nconst editionTaken = (marker : Array<number>, edition : BN) : boolean => {\n  let m = getIndexAndMask(edition);\n  return (marker[m.index] & m.mask) !== 0;\n}\n\nconst setEditionTaken = (marker : Array<number>, edition : BN) => {\n  let m = getIndexAndMask(edition);\n  marker[m.index] = marker[m.index] | m.mask;\n}\n\nexport const validateEditionClaims = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  claimants : Claimants,\n  masterMintStr : string,\n) : Promise<ClaimInfo> => {\n  claimants.forEach((c, idx) => {\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\n    if (c.amount !== 1) {\n      throw new Error(`Claimant ${idx} has amount ${c.amount}. Expected 1 for edition gumdrop`);\n    }\n  });\n\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\n  const masterMint = await getMintInfo(connection, masterMintStr);\n  const masterTokenAccount = await getCreatorTokenAccount(\n    walletKey,\n    connection,\n    masterMint.key,\n    1 // just check that the creator has the master mint\n  );\n\n  const masterEditionKey = await getEdition(masterMint.key);\n  const masterEdition = await connection.getAccountInfo(masterEditionKey);\n  if (masterEdition === null) {\n    throw new Error(`Could not fetch master edition`);\n  }\n  console.log(\"Master edition\", masterEdition);\n\n  // maxSupply is an option, 9 bytes, first is 0 means is none\n  const currentSupply = new BN(masterEdition.data.slice(1, 1+8), 8, \"le\").toNumber();\n  let maxSupply;\n  if (masterEdition.data[9] === 0) {\n      maxSupply = null;\n  } else {\n      maxSupply = new BN(masterEdition.data.slice(10, 10+8), 8, \"le\").toNumber();\n  }\n  console.log(\"Max supply\", maxSupply);\n  console.log(\"Current supply\", currentSupply);\n\n  if (maxSupply !== null && maxSupply < total) {\n    throw new Error(`Distributor is allocated more editions (${total}) `\n                  + `than the master has total (${maxSupply})`);\n  }\n\n  // Whether an edition has been claimed is a single bit in a paginated account\n  // (pda off of master mint). The following code does some sanity checks\n  // around max supply and internally whether the distribution list has\n  // duplicate editions, and also checks if the editions were already taken on\n  // chain.\n  //\n  // There is a race condition since the authority to mint is still currently\n  // the wallet but it seems like a user error to have other editions being\n  // minted while a gumdrop is being created\n  const editions : { [key: number]: number } = {};\n  const editionMarkers : Array<[PublicKey, Array<number>]> = [];\n  for (let idx = 0; idx < claimants.length; ++idx ) {\n    const c = claimants[idx];\n    if (c.edition === undefined) throw new Error(`Claimant ${idx} doesn't have edition`);\n    if (c.edition <= 0) {\n      throw new Error(`Claimant ${idx} assigned invalid edition ${c.edition}`);\n    }\n    if (c.edition > maxSupply) {\n      throw new Error(`Claimant ${idx} assigned edition ${c.edition} which is beyond the max supply`);\n    }\n    if (c.edition in editions) {\n      throw new Error(`Claimant ${idx} and ${editions[c.edition]} are both assigned to edition ${c.edition}`);\n    }\n    const edition = new BN(c.edition);\n    const markerKey = await getEditionMarkerPda(masterMint.key, edition);\n    let markerData = editionMarkers.find(pm => pm[0].equals(markerKey));\n    if (markerData === undefined) {\n      const markerAcc = await connection.getAccountInfo(markerKey);\n      if (markerAcc === null) {\n        editionMarkers.push([markerKey, Array<number>(31)]);\n      } else {\n        editionMarkers.push([markerKey, [...markerAcc.data.slice(1, 32)]]);\n      }\n      markerData = editionMarkers[editionMarkers.length - 1];\n    }\n\n    if (markerData === undefined) {\n      throw new Error(`Internal Error: Edition marker info still undefined ${c.edition}`);\n    }\n\n    if (editionTaken(markerData[1], edition)) {\n      throw new Error(`Claimant ${idx} is assigned to edition ${c.edition} which is already taken`);\n    }\n\n    setEditionTaken(markerData[1], edition);\n\n    editions[c.edition] = idx;\n  }\n\n  return {\n    total: total,\n    masterMint: masterMint,\n    masterTokenAccount: masterTokenAccount,\n  };\n}\n\nexport const chunk = (\n  arr : Buffer,\n  len : number,\n) : Array<Buffer> => {\n  let chunks : Array<Buffer> = [],\n      i = 0,\n      n = arr.length;\n\n  while (i < n) {\n    chunks.push(arr.slice(i, i += len));\n  }\n\n  return chunks;\n}\n\nexport const buildGumdrop = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  needsPin : boolean,\n  claimIntegration : string,\n  host : string,\n  baseKey : PublicKey,\n  temporalSigner : PublicKey,\n  claimants : Claimants,\n  claimInfo  : ClaimInfo,\n  extraParams : Array<string> = [],\n) : Promise<Array<TransactionInstruction>> => {\n\n  const leafs : Array<Buffer> = [];\n  for (let idx = 0; idx < claimants.length; ++idx ) {\n    const claimant = claimants[idx];\n    if (!needsPin) {\n      try {\n        claimant.secret = new PublicKey(claimant.handle);\n      } catch (err) {\n        throw new Error(`Invalid claimant wallet handle ${err}`);\n      }\n    } else {\n      const seeds = [\n        claimant.seed.toBuffer(),\n        ...chunk(Buffer.from(claimant.handle), 32),\n        Buffer.from(claimant.pin.toArray(\"le\", 4)),\n      ];\n      const [claimantPda, ] = await PublicKey.findProgramAddress(\n          seeds.map(s => s.slice(0, 32)), GUMDROP_DISTRIBUTOR_ID);\n      claimant.secret = claimantPda;\n    }\n    // TODO: get this clarified with jordan... we can either just assign some\n    // range of editions to a user or give them an amount and just keep a\n    // counter on the distributor... the latter is much less work but we lose\n    // the ability to use gumdrop for auction house winnings and such?\n    const extra = claimIntegration === \"edition\"\n      ? [...new BN(claimant.edition).toArray(\"le\", 8)]\n      : []\n    leafs.push(Buffer.from(\n      [...new BN(idx).toArray(\"le\", 8),\n       ...claimant.secret.toBuffer(),\n       ...claimant.seed.toBuffer(),\n       ...new BN(claimant.amount).toArray(\"le\", 8),\n       ...extra\n      ]\n    ));\n  }\n\n  const tree = new MerkleTree(leafs);\n  const root = tree.getRoot();\n\n  const [distributor, dbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"MerkleDistributor\"),\n      baseKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID);\n\n  for (let idx = 0; idx < claimants.length; ++idx) {\n    const proof = tree.getProof(idx);\n    const verified = tree.verifyProof(idx, proof, root);\n\n    if (!verified) {\n      throw new Error(\"Gumdrop merkle tree verification failed\");\n    }\n\n    const claimant = claimants[idx];\n    const params = [\n      `distributor=${distributor}`,\n      `handle=${encodeURIComponent(claimant.handle)}`,\n      `amount=${claimant.amount}`,\n      `index=${idx}`,\n      `proof=${proof.map(b => bs58.encode(b))}`,\n      ...extraParams,\n    ];\n    if (needsPin) {\n      params.push(`pin=${claimant.pin.toNumber()}`);\n    } else {\n      params.push(`pin=NA`);\n    }\n    if (claimIntegration === \"transfer\") {\n      params.push(`tokenAcc=${claimInfo.source}`);\n    } else if (claimIntegration === \"candy\") {\n      params.push(`config=${claimInfo.config}`);\n      params.push(`uuid=${claimInfo.uuid}`);\n    } else {\n      params.push(`master=${claimInfo.masterMint.key}`);\n      params.push(`edition=${claimant.edition}`);\n    }\n    const query = params.join(\"&\");\n\n    claimant.url = `${host}/claim?${query}`;\n  }\n\n  // initial merkle-distributor state\n  const instructions = Array<TransactionInstruction>();\n  instructions.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: baseKey                 , isSigner: true  , isWritable: false } ,\n          { pubkey: distributor             , isSigner: false , isWritable: true  } ,\n          { pubkey: walletKey               , isSigner: true  , isWritable: false } ,\n          { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:new_distributor\")).slice(0, 8),\n        ...new BN(dbump).toArray(\"le\", 1),\n        ...root,\n        ...temporalSigner.toBuffer(),\n      ])\n  }));\n\n  if (claimIntegration === \"transfer\") {\n    instructions.push(Token.createApproveInstruction(\n      TOKEN_PROGRAM_ID,\n      claimInfo.source,\n      distributor,\n      walletKey,\n      [],\n      claimInfo.total\n    ));\n  } else if (claimIntegration === \"candy\") {\n    const [distributorWalletKey, ] = await PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"Wallet\"),\n        distributor.toBuffer(),\n      ],\n      GUMDROP_DISTRIBUTOR_ID\n    );\n\n    instructions.push(new TransactionInstruction({\n        programId: CANDY_MACHINE_ID,\n        keys: [\n            { pubkey: claimInfo.candyMachineKey,isSigner: false , isWritable: true  } ,\n            { pubkey: walletKey               , isSigner: true  , isWritable: false } ,\n        ],\n        data: Buffer.from([\n          ...Buffer.from(sha256.digest(\"global:update_authority\")).slice(0, 8),\n          ...new BN(1).toArray(\"le\", 1),  // optional exists...\n          ...distributorWalletKey.toBuffer(),\n        ])\n    }));\n  } else if (claimIntegration === \"edition\") {\n    // transfer master edition to distributor\n    const [distributorTokenKey, ] = await PublicKey.findProgramAddress(\n      [\n        distributor.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        claimInfo.masterMint.key.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    );\n\n    instructions.push(Token.createAssociatedTokenAccountInstruction(\n        SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n        TOKEN_PROGRAM_ID,\n        claimInfo.masterMint.key,\n        distributorTokenKey,\n        distributor,\n        walletKey,\n      ));\n\n    instructions.push(Token.createTransferInstruction(\n        TOKEN_PROGRAM_ID,\n        claimInfo.masterTokenAccount,\n        distributorTokenKey,\n        walletKey,\n        [],\n        1\n      ));\n  }\n\n  return instructions;\n}\n\nexport const closeGumdrop = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  base : Keypair,\n  claimMethod : string,\n  candyConfig : string,\n  candyUuid : string,\n  masterMint : string,\n) : Promise<Array<TransactionInstruction>> => {\n  const [distributorKey, dbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"MerkleDistributor\"),\n      base.publicKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID);\n\n  const [distributorWalletKey, wbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"Wallet\"),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  let extraKeys;\n  if (claimMethod === \"candy\") {\n    const configKey = await getCandyConfig(connection, candyConfig);\n    const [candyMachineKey, ] = await getCandyMachineAddress(\n      configKey, candyUuid);\n\n   extraKeys = [\n          { pubkey: candyMachineKey         , isSigner: false , isWritable: true  } ,\n          { pubkey: CANDY_MACHINE_ID        , isSigner: false , isWritable: false } ,\n    ];\n  } else {\n    extraKeys = [];\n  }\n\n  const instructions = Array<TransactionInstruction>();\n  if (claimMethod === \"edition\") {\n    let masterMintKey: PublicKey;\n    try {\n      masterMintKey = new PublicKey(masterMint);\n    } catch (err) {\n      throw new Error(`Invalid mint key ${err}`);\n    }\n    const [distributorTokenKey, ] = await PublicKey.findProgramAddress(\n      [\n        distributorKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        masterMintKey.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    );\n\n    const [walletTokenKey, ] = await PublicKey.findProgramAddress(\n      [\n        walletKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        masterMintKey.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    );\n\n    instructions.push(new TransactionInstruction({\n        programId: GUMDROP_DISTRIBUTOR_ID,\n        keys: [\n            { pubkey: base.publicKey          , isSigner: true  , isWritable: false } ,\n            { pubkey: distributorKey          , isSigner: false , isWritable: false } ,\n            { pubkey: distributorTokenKey     , isSigner: false , isWritable: true  } ,\n            { pubkey: walletTokenKey          , isSigner: false , isWritable: true  } ,\n            { pubkey: walletKey               , isSigner: false , isWritable: true  } ,\n            { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\n            { pubkey: TOKEN_PROGRAM_ID        , isSigner: false , isWritable: false } ,\n        ],\n        data: Buffer.from([\n          ...Buffer.from(sha256.digest(\"global:close_distributor_token_account\")).slice(0, 8),\n          ...new BN(dbump).toArray(\"le\", 1),\n        ])\n    }));\n  }\n\n  instructions.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: base.publicKey          , isSigner: true  , isWritable: false } ,\n          { pubkey: distributorKey          , isSigner: false , isWritable: true  } ,\n          { pubkey: distributorWalletKey    , isSigner: false , isWritable: true  } ,\n          { pubkey: walletKey               , isSigner: true  , isWritable: true  } ,\n          { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_PROGRAM_ID        , isSigner: false , isWritable: false } ,\n          ...extraKeys,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:close_distributor\")).slice(0, 8),\n        ...new BN(dbump).toArray(\"le\", 1),\n        ...new BN(wbump).toArray(\"le\", 1),\n      ])\n  }));\n\n  return instructions;\n}\n","import {\n  Blockhash,\n  Commitment,\n  Connection,\n  FeeCalculator,\n  Keypair,\n  RpcResponseAndContext,\n  SignatureStatus,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n} from '@solana/web3.js';\nimport { sleep } from \"../utils/utils\";\nimport log from 'loglevel';\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport const DEFAULT_TIMEOUT = 15000;\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nexport const envFor = (\n  connection: Connection\n) : string => {\n  const endpoint = (connection as any)._rpcEndpoint;\n  const regex = /https:\\/\\/api.([^.]*).solana.com/;\n  const match = endpoint.match(regex);\n  if (match[1]) {\n    return match[1];\n  }\n  return \"mainnet-beta\";\n}\n\nexport const explorerLinkFor = (\n  txid: TransactionSignature,\n  connection: Connection\n) : string => {\n  return `https://explorer.solana.com/tx/${txid}?cluster=${envFor(connection)}`;\n}\n\nexport const sendTransactionWithRetryWithKeypair = async (\n  connection: Connection,\n  wallet: Keypair,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void,\n) => {\n  const transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.sign(...[wallet, ...signers]);\n  } else {\n    transaction.sign(wallet);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const { txid, slot } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction,\n  });\n\n  return { txid, slot };\n};\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    },\n  );\n\n  log.debug('Started awaiting confirmation for', txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      'confirmed',\n      true,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      log.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err) {\n    log.error('Timeout Error caught', err);\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, 'single')\n      ).value;\n    } catch (e) {\n      log.error('Simulate Transaction error', e);\n    }\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith('Program log: ')) {\n            throw new Error(\n              'Transaction failed: ' + line.slice('Program log: '.length),\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  log.debug('Latency (ms)', txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment,\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching,\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config: any = { encoding: 'base64', commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest('simulateTransaction', args);\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n  return res.result;\n}\n\nexport async function awaitTransactionSignatureConfirmation(\n  txid: TransactionSignature,\n  timeout: number,\n  connection: Connection,\n  commitment: Commitment = 'recent',\n  queryStatus = false,\n): Promise<SignatureStatus | null | void> {\n  let done = false;\n  let status: SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  // eslint-disable-next-line no-async-promise-executor\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      log.warn('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            log.warn('Rejected via websocket', result.err);\n            reject(status);\n          } else {\n            log.debug('Resolved via websocket', result);\n            resolve(status);\n          }\n        },\n        commitment,\n      );\n    } catch (e) {\n      done = true;\n      log.error('WS error in setup', txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          console.log(explorerLinkFor(txid, connection));\n          if (!done) {\n            if (!status) {\n              log.debug('REST null result for', txid, status);\n            } else if (status.err) {\n              log.error('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              log.error('REST no confirmations for', txid, status);\n            } else {\n              log.debug('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            log.error('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  log.debug('Returning status', status);\n  return status;\n}\n","import { useLocalStorageState } from \"../utils/utils\";\nimport {\n  Keypair,\n  Commitment,\n  Connection,\n  Transaction,\n  TransactionInstruction,\n  Blockhash,\n  FeeCalculator,\n} from \"@solana/web3.js\";\nimport React, { useContext, useEffect, useMemo, useState } from \"react\";\nimport {\n  sendSignedTransaction,\n} from \"../utils/transactions\";\nimport {\n  TokenInfo,\n  TokenListProvider,\n  ENV as ChainId,\n} from \"@solana/spl-token-registry\";\nimport { WalletSigner } from \"./WalletContext/WalletContext\";\nimport { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport type ENV = \"mainnet-beta\" | \"testnet\" | \"devnet\" | \"localnet\";\n\nexport const ENDPOINTS = [\n  {\n    name: \"mainnet-beta\" as ENV,\n    endpoint: \"https://api.mainnet-beta.solana.com\",\n    ChainId: ChainId.MainnetBeta,\n  },\n  {\n    name: \"devnet\" as ENV,\n    endpoint: \"https://api.devnet.solana.com\",\n    ChainId: ChainId.Devnet,\n  },\n];\n\nconst DEFAULT = ENDPOINTS[0].endpoint;\n\ninterface ConnectionConfig {\n  connection: Connection;\n  endpoint: string;\n  env: ENV;\n  setEndpoint: (val: string) => void;\n  tokens: TokenInfo[];\n  tokenMap: Map<string, TokenInfo>;\n}\n\nconst ConnectionContext = React.createContext<ConnectionConfig>({\n  endpoint: DEFAULT,\n  setEndpoint: () => {},\n  connection: new Connection(DEFAULT, \"recent\"),\n  env: ENDPOINTS[0].name,\n  tokens: [],\n  tokenMap: new Map<string, TokenInfo>(),\n});\n\nexport function ConnectionProvider({ children = undefined as any }) {\n  const [endpoint, setEndpoint] = useLocalStorageState(\n    \"connectionEndpoint\",\n    ENDPOINTS[0].endpoint\n  );\n\n  const connection = useMemo(\n    () => new Connection(endpoint, \"recent\"),\n    [endpoint]\n  );\n\n  const env =\n    ENDPOINTS.find((end) => end.endpoint === endpoint)?.name ||\n    ENDPOINTS[0].name;\n\n  const [tokens, setTokens] = useState<TokenInfo[]>([]);\n  const [tokenMap, setTokenMap] = useState<Map<string, TokenInfo>>(new Map());\n  useEffect(() => {\n    // fetch token files\n    new TokenListProvider().resolve().then((container) => {\n      const list = container\n        .excludeByTag(\"nft\")\n        .filterByChainId(\n          ENDPOINTS.find((end) => end.endpoint === endpoint)?.ChainId ||\n            ChainId.MainnetBeta\n        )\n        .getList();\n\n      const knownMints = [...list].reduce((map, item) => {\n        map.set(item.address, item);\n        return map;\n      }, new Map<string, TokenInfo>());\n\n      setTokenMap(knownMints);\n      setTokens(list);\n    });\n  }, [env, endpoint]);\n\n  // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n  // This is a hack to prevent the list from every getting empty\n  useEffect(() => {\n    const id = connection.onAccountChange(\n      Keypair.generate().publicKey,\n      () => {}\n    );\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    const id = connection.onSlotChange(() => null);\n    return () => {\n      connection.removeSlotChangeListener(id);\n    };\n  }, [connection]);\n\n  return (\n    <ConnectionContext.Provider\n      value={{\n        endpoint,\n        setEndpoint,\n        connection,\n        tokens,\n        tokenMap,\n        env,\n      }}\n    >\n      {children}\n    </ConnectionContext.Provider>\n  );\n}\n\nexport function useConnection() {\n  return useContext(ConnectionContext).connection as Connection;\n}\n\nexport function useConnectionConfig() {\n  const context = useContext(ConnectionContext);\n  return {\n    endpoint: context.endpoint,\n    setEndpoint: context.setEndpoint,\n    env: context.env,\n    tokens: context.tokens,\n    tokenMap: context.tokenMap,\n  };\n}\n\nexport const getErrorForTransaction = async (\n  connection: Connection,\n  txid: string\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, \"max\");\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach((log) => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport enum SequenceType {\n  Sequential,\n  Parallel,\n  StopOnFailure,\n}\n\nexport const sendTransactionWithRetry = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = \"singleGossip\",\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void\n) : Promise<string| { txid: string; slot: number }> => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach((instruction) => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map((s) => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    try {\n      transaction = await wallet.signTransaction(transaction);\n    } catch {\n      return \"Failed to sign transaction\";\n    }\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n  console.log(\"About to send\");\n  try {\n    const { txid, slot } = await sendSignedTransaction({\n      connection,\n      signedTransaction: transaction,\n    });\n\n    return { txid, slot };\n  } catch (error) {\n    console.error(error);\n    return \"See console logs\";\n  }\n};\n\n","import { keccak_256 } from \"js-sha3\";\n\nexport class MerkleTree {\n  leafs: Array<Buffer>;\n  layers: Array<Array<Buffer>>;\n\n  constructor(leafs : Array<Buffer>) {\n    this.leafs = leafs.slice();\n    this.layers = [];\n\n    let hashes = this.leafs.map(MerkleTree.nodeHash);\n    while (hashes.length > 0) {\n      console.log(\"Hashes\", this.layers.length, hashes);\n      this.layers.push(hashes.slice());\n      if (hashes.length === 1) break;\n      hashes = hashes.reduce((acc, cur, idx, arr) => {\n        if (idx % 2 === 0) {\n          const nxt = arr[idx + 1];\n          acc.push(MerkleTree.internalHash(cur, nxt));\n        }\n        return acc;\n      }, Array<Buffer>());\n    }\n  }\n\n  static nodeHash(\n    data : Buffer,\n  ) : Buffer {\n    return Buffer.from(keccak_256.digest([0x00, ...data]));\n  }\n\n\n  static internalHash(\n    first : Buffer,\n    second : Buffer | undefined,\n  ) : Buffer {\n    if (!second) return first;\n    const [fst, snd] = [first, second].sort(Buffer.compare)\n    return Buffer.from(\n      keccak_256.digest([0x01, ...fst, ...snd])\n    );\n  }\n\n  getRoot() : Buffer {\n    return this.layers[this.layers.length - 1][0];\n  }\n\n  getProof(idx : number) : Buffer[] {\n    return this.layers.reduce((proof, layer) => {\n      const sibling = idx ^ 1;\n      if (sibling < layer.length) {\n        proof.push(layer[sibling]);\n      }\n\n      idx = Math.floor(idx / 2);\n\n      return proof;\n    }, []);\n  }\n\n  getHexRoot(): string {\n    return this.getRoot().toString(\"hex\");\n  }\n\n  getHexProof(idx : number) : string[] {\n    return this.getProof(idx).map((el) => el.toString(\"hex\"));\n  }\n\n  verifyProof(\n    idx : number,\n    proof : Buffer[],\n    root : Buffer\n  ): boolean {\n    let pair = MerkleTree.nodeHash(this.leafs[idx]);\n    for (const item of proof) {\n      pair = MerkleTree.internalHash(pair, item);\n    }\n\n    return pair.equals(root);\n  }\n\n  static verifyClaim(\n    leaf : Buffer,\n    proof : Buffer[],\n    root : Buffer\n  ): boolean {\n    let pair = MerkleTree.nodeHash(leaf);\n    for (const item of proof) {\n      pair = MerkleTree.internalHash(pair, item);\n    }\n\n    return pair.equals(root);\n  }\n\n}\n","import {\n  TOKEN_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  BPF_UPGRADE_LOADER_ID,\n  SYSTEM,\n  MEMO_ID,\n} from './ids';\n\nexport const setProgramIds = async () => {};\n\nexport const programIds = () => {\n  return {\n    token: TOKEN_PROGRAM_ID,\n    associatedToken: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    bpf_upgrade_loader: BPF_UPGRADE_LOADER_ID,\n    system: SYSTEM,\n    memo: MEMO_ID,\n    // store: STORE,\n  };\n};\n","import React from \"react\";\nimport { Modal } from \"antd\";\n\nimport \"./index.css\";\n\nexport const DefaultModal = (props: any) => {\n  const { children, closeIcon, bodyStyle, width, style, ...rest } = props;\n\n  return (\n    <Modal\n      style={{ background: \"transparent\", borderRadius: 16 }}\n      bodyStyle={{\n        background: \"#333333\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        ...bodyStyle,\n      }}\n      footer={null}\n      width={\n        width || 400\n      }\n      {...rest}\n    >\n      {children}\n    </Modal>\n  );\n};\n","import React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useState,\n} from 'react';\nimport { useConnection } from './ConnectionContext';\nimport { useWallet } from '@solana/wallet-adapter-react';\nimport { AccountInfo, Connection, PublicKey } from '@solana/web3.js';\nimport { AccountLayout, MintInfo, MintLayout, u64 } from '@solana/spl-token';\nimport { TokenAccount } from '../models';\nimport { chunks } from '../utils/utils';\nimport { EventEmitter } from '../utils/eventEmitter';\nimport { StringPublicKey, WRAPPED_SOL_MINT } from '../utils/ids';\nimport { programIds } from '../utils/programIds';\n\nconst AccountsContext = React.createContext<any>(null);\n\nconst pendingCalls = new Map<string, Promise<ParsedAccountBase>>();\nconst genericCache = new Map<string, ParsedAccountBase>();\nconst pendingMintCalls = new Map<string, Promise<MintInfo>>();\nconst mintCache = new Map<string, MintInfo>();\n\nexport interface ParsedAccountBase {\n  pubkey: StringPublicKey;\n  account: AccountInfo<Buffer>;\n  info: any; // TODO: change to unknown\n}\n\nexport type AccountParser = (\n  pubkey: StringPublicKey,\n  data: AccountInfo<Buffer>,\n) => ParsedAccountBase | undefined;\n\nexport interface ParsedAccount<T> extends ParsedAccountBase {\n  info: T;\n}\n\nconst getMintInfo = async (connection: Connection, pubKey: PublicKey) => {\n  const info = await connection.getAccountInfo(pubKey);\n  if (info === null) {\n    throw new Error('Failed to find mint account');\n  }\n\n  const data = Buffer.from(info.data);\n\n  return deserializeMint(data);\n};\n\nexport const MintParser = (pubKey: string, info: AccountInfo<Buffer>) => {\n  const buffer = Buffer.from(info.data);\n\n  const data = deserializeMint(buffer);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: data,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const TokenAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  // Sometimes a wrapped sol account gets closed, goes to 0 length,\n  // triggers an update over wss which triggers this guy to get called\n  // since your UI already logged that pubkey as a token account. Check for length.\n  if (info.data.length > 0) {\n    const buffer = Buffer.from(info.data);\n    const data = deserializeAccount(buffer);\n\n    const details = {\n      pubkey: pubKey,\n      account: {\n        ...info,\n      },\n      info: data,\n    } as TokenAccount;\n\n    return details;\n  }\n};\n\nexport const GenericAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  const buffer = Buffer.from(info.data);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: buffer,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const keyToAccountParser = new Map<string, AccountParser>();\n\nexport const cache = {\n  emitter: new EventEmitter(),\n  query: async (\n    connection: Connection,\n    pubKey: string | PublicKey,\n    parser?: AccountParser,\n  ) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n\n    let account = genericCache.get(address);\n    if (account) {\n      return account;\n    }\n\n    let query = pendingCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    // TODO: refactor to use multiple accounts query with flush like behavior\n    query = connection.getAccountInfo(id).then(data => {\n      if (!data) {\n        throw new Error('Account not found');\n      }\n\n      return cache.add(id, data, parser);\n    }) as Promise<TokenAccount>;\n    pendingCalls.set(address, query as any);\n\n    return query;\n  },\n  add: (\n    id: PublicKey | string,\n    obj: AccountInfo<Buffer>,\n    parser?: AccountParser,\n    isActive?: boolean | undefined | ((parsed: any) => boolean),\n  ) => {\n    const address = typeof id === 'string' ? id : id?.toBase58();\n    const deserialize = parser ? parser : keyToAccountParser.get(address);\n    if (!deserialize) {\n      throw new Error(\n        'Deserializer needs to be registered or passed as a parameter',\n      );\n    }\n\n    cache.registerParser(id, deserialize);\n    pendingCalls.delete(address);\n    const account = deserialize(address, obj);\n    if (!account) {\n      return;\n    }\n\n    if (isActive === undefined) isActive = true;\n    else if (isActive instanceof Function) isActive = isActive(account);\n\n    const isNew = !genericCache.has(address);\n\n    genericCache.set(address, account);\n    cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);\n    return account;\n  },\n  get: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return genericCache.get(key);\n  },\n  delete: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    if (genericCache.get(key)) {\n      genericCache.delete(key);\n      cache.emitter.raiseCacheDeleted(key);\n      return true;\n    }\n    return false;\n  },\n\n  byParser: (parser: AccountParser) => {\n    const result: string[] = [];\n    for (const id of keyToAccountParser.keys()) {\n      if (keyToAccountParser.get(id) === parser) {\n        result.push(id);\n      }\n    }\n\n    return result;\n  },\n  registerParser: (pubkey: PublicKey | string, parser: AccountParser) => {\n    if (pubkey) {\n      const address = typeof pubkey === 'string' ? pubkey : pubkey?.toBase58();\n      keyToAccountParser.set(address, parser);\n    }\n\n    return pubkey;\n  },\n  queryMint: async (connection: Connection, pubKey: string | PublicKey) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    let mint = mintCache.get(address);\n    if (mint) {\n      return mint;\n    }\n\n    let query = pendingMintCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    query = getMintInfo(connection, id).then(data => {\n      pendingMintCalls.delete(address);\n\n      mintCache.set(address, data);\n      return data;\n    }) as Promise<MintInfo>;\n    pendingMintCalls.set(address, query as any);\n\n    return query;\n  },\n  getMint: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return mintCache.get(key);\n  },\n  addMint: (pubKey: PublicKey, obj: AccountInfo<Buffer>) => {\n    const mint = deserializeMint(obj.data);\n    const id = pubKey.toBase58();\n    mintCache.set(id, mint);\n    return mint;\n  },\n};\n\nexport const useAccountsContext = () => {\n  const context = useContext(AccountsContext);\n\n  return context;\n};\n\nfunction wrapNativeAccount(\n  pubkey: string,\n  account?: AccountInfo<Buffer>,\n): TokenAccount | undefined {\n  if (!account) {\n    return undefined;\n  }\n\n  const key = new PublicKey(pubkey);\n\n  return {\n    pubkey: pubkey,\n    account,\n    info: {\n      address: key,\n      mint: WRAPPED_SOL_MINT,\n      owner: key,\n      amount: new u64(account.lamports),\n      delegate: null,\n      delegatedAmount: new u64(0),\n      isInitialized: true,\n      isFrozen: false,\n      isNative: true,\n      rentExemptReserve: null,\n      closeAuthority: null,\n    },\n  };\n}\n\nexport const getCachedAccount = (\n  predicate: (account: TokenAccount) => boolean,\n) => {\n  for (const account of genericCache.values()) {\n    if (predicate(account)) {\n      return account as TokenAccount;\n    }\n  }\n};\n\nconst UseNativeAccount = () => {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n\n  const [nativeAccount, setNativeAccount] = useState<AccountInfo<Buffer>>();\n\n  const updateCache = useCallback(\n    account => {\n      if (publicKey) {\n        const wrapped = wrapNativeAccount(publicKey.toBase58(), account);\n        if (wrapped !== undefined) {\n          const id = publicKey.toBase58();\n          cache.registerParser(id, TokenAccountParser);\n          genericCache.set(id, wrapped as TokenAccount);\n          cache.emitter.raiseCacheUpdated(id, false, TokenAccountParser, true);\n        }\n      }\n    },\n    [publicKey],\n  );\n\n  useEffect(() => {\n    let subId = 0;\n    const updateAccount = (account: AccountInfo<Buffer> | null) => {\n      if (account) {\n        updateCache(account);\n        setNativeAccount(account);\n      }\n    };\n\n    (async () => {\n      if (!connection || !publicKey) {\n        return;\n      }\n\n      try {\n        const account = await connection.getAccountInfo(publicKey);\n        updateAccount(account);\n      } catch {\n        return;\n      }\n\n      subId = connection.onAccountChange(publicKey, updateAccount);\n    })();\n\n    return () => {\n      if (subId) {\n        connection.removeAccountChangeListener(subId);\n      }\n    };\n  }, [setNativeAccount, publicKey, connection, updateCache]);\n\n  return { nativeAccount };\n};\n\nconst PRECACHED_OWNERS = new Set<string>();\nconst precacheUserTokenAccounts = async (\n  connection: Connection,\n  owner?: PublicKey,\n) => {\n  if (!owner) {\n    return;\n  }\n\n  // used for filtering account updates over websocket\n  PRECACHED_OWNERS.add(owner.toBase58());\n\n  // user accounts are updated via ws subscription\n  const accounts = await connection.getTokenAccountsByOwner(owner, {\n    programId: programIds().token,\n  });\n\n  accounts.value.forEach(info => {\n    cache.add(info.pubkey.toBase58(), info.account, TokenAccountParser);\n  });\n};\n\nexport function AccountsProvider({ children = null as any }) {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n  const [tokenAccounts, setTokenAccounts] = useState<TokenAccount[]>([]);\n  const [userAccounts, setUserAccounts] = useState<TokenAccount[]>([]);\n  const { nativeAccount } = UseNativeAccount();\n  const walletKey = publicKey?.toBase58();\n\n  const selectUserAccounts = useCallback(() => {\n    return cache\n      .byParser(TokenAccountParser)\n      .map(id => cache.get(id))\n      .filter(a => a && a.info.owner.toBase58() === walletKey)\n      .map(a => a as TokenAccount);\n  }, [walletKey]);\n\n  useEffect(() => {\n    const accounts = selectUserAccounts().filter(\n      a => a !== undefined,\n    ) as TokenAccount[];\n    setUserAccounts(accounts);\n  }, [nativeAccount, tokenAccounts, selectUserAccounts]);\n\n  useEffect(() => {\n    const subs: number[] = [];\n    cache.emitter.onCache(args => {\n      if (args.isNew && args.isActive) {\n        let id = args.id;\n        let deserialize = args.parser;\n        connection.onAccountChange(new PublicKey(id), info => {\n          cache.add(id, info, deserialize);\n        });\n      }\n    });\n\n    return () => {\n      subs.forEach(id => connection.removeAccountChangeListener(id));\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    if (!connection || !publicKey) {\n      setTokenAccounts([]);\n    } else {\n      precacheUserTokenAccounts(connection, publicKey).then(() => {\n        setTokenAccounts(selectUserAccounts());\n      });\n\n      // This can return different types of accounts: token-account, mint, multisig\n      // TODO: web3.js expose ability to filter.\n      // this should use only filter syntax to only get accounts that are owned by user\n      const tokenSubID = connection.onProgramAccountChange(\n        programIds().token,\n        info => {\n          // TODO: fix type in web3.js\n          const id = info.accountId as unknown as string;\n          // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\n          if (info.accountInfo.data.length === AccountLayout.span) {\n            const data = deserializeAccount(info.accountInfo.data);\n\n            if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\n              cache.add(id, info.accountInfo, TokenAccountParser);\n              setTokenAccounts(selectUserAccounts());\n            }\n          }\n        },\n        'singleGossip',\n      );\n\n      return () => {\n        connection.removeProgramAccountChangeListener(tokenSubID);\n      };\n    }\n  }, [connection, publicKey, selectUserAccounts]);\n\n  return (\n    <AccountsContext.Provider\n      value={{\n        userAccounts,\n        nativeAccount,\n      }}\n    >\n      {children}\n    </AccountsContext.Provider>\n  );\n}\n\nexport function useNativeAccount() {\n  const context = useContext(AccountsContext);\n  return {\n    account: context.nativeAccount as AccountInfo<Buffer>,\n  };\n}\n\nexport const getMultipleAccounts = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const result = await Promise.all(\n    chunks(keys, 99).map(chunk =>\n      getMultipleAccountsCore(connection, chunk, commitment),\n    ),\n  );\n\n  const array = result\n    .map(\n      a =>\n        a.array.map(acc => {\n          if (!acc) {\n            return undefined;\n          }\n\n          const { data, ...rest } = acc;\n          const obj = {\n            ...rest,\n            data: Buffer.from(data[0], 'base64'),\n          } as AccountInfo<Buffer>;\n          return obj;\n        }) as AccountInfo<Buffer>[],\n    )\n    .flat();\n  return { keys, array };\n};\n\nconst getMultipleAccountsCore = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const args = connection._buildArgs([keys], commitment, 'base64');\n\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\n  if (unsafeRes.error) {\n    throw new Error(\n      'failed to get info about account ' + unsafeRes.error.message,\n    );\n  }\n\n  if (unsafeRes.result.value) {\n    const array = unsafeRes.result.value as AccountInfo<string[]>[];\n    return { keys, array };\n  }\n\n  // TODO: fix\n  throw new Error();\n};\n\nexport function useMint(key?: string | PublicKey) {\n  const connection = useConnection();\n  const [mint, setMint] = useState<MintInfo>();\n\n  const id = typeof key === 'string' ? key : key?.toBase58();\n\n  useEffect(() => {\n    if (!id) {\n      return;\n    }\n\n    cache\n      .query(connection, id, MintParser)\n      .then(acc => setMint(acc.info as any))\n      .catch(err => console.log(err));\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === id) {\n        cache\n          .query(connection, id, MintParser)\n          .then(mint => setMint(mint.info as any));\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, id]);\n\n  return mint;\n}\n\nexport function useAccount(pubKey?: PublicKey) {\n  const connection = useConnection();\n  const [account, setAccount] = useState<TokenAccount>();\n\n  const key = pubKey?.toBase58();\n  useEffect(() => {\n    const query = async () => {\n      try {\n        if (!key) {\n          return;\n        }\n\n        const acc = await cache\n          .query(connection, key, TokenAccountParser)\n          .catch(err => console.log(err));\n        if (acc) {\n          setAccount(acc);\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    query();\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === key) {\n        query();\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, key]);\n\n  return account;\n}\n\n// TODO: expose in spl package\nexport const deserializeAccount = (data: Buffer) => {\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n};\n\n// TODO: expose in spl package\nexport const deserializeMint = (data: Buffer) => {\n  if (data.length !== MintLayout.span) {\n    throw new Error('Not a valid Mint');\n  }\n\n  const mintInfo = MintLayout.decode(data);\n\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n\n  return mintInfo as MintInfo;\n};\n","import { EventEmitter as Emitter } from 'eventemitter3';\n\nexport class CacheUpdateEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  parser: any;\n  isNew: boolean;\n  isActive: boolean;\n  constructor(id: string, isNew: boolean, parser: any, isActive: boolean) {\n    this.id = id;\n    this.parser = parser;\n    this.isNew = isNew;\n    this.isActive = isActive;\n  }\n}\n\nexport class CacheDeleteEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  constructor(id: string) {\n    this.id = id;\n  }\n}\n\nexport class MarketUpdateEvent {\n  static type = 'MarketUpdate';\n  ids: Set<string>;\n  constructor(ids: Set<string>) {\n    this.ids = ids;\n  }\n}\n\nexport class EventEmitter {\n  private emitter = new Emitter();\n\n  onMarket(callback: (args: MarketUpdateEvent) => void) {\n    this.emitter.on(MarketUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(MarketUpdateEvent.type, callback);\n  }\n\n  onCache(callback: (args: CacheUpdateEvent) => void) {\n    this.emitter.on(CacheUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(CacheUpdateEvent.type, callback);\n  }\n\n  raiseMarketUpdated(ids: Set<string>) {\n    this.emitter.emit(MarketUpdateEvent.type, new MarketUpdateEvent(ids));\n  }\n\n  raiseCacheUpdated(\n    id: string,\n    isNew: boolean,\n    parser: any,\n    isActive: boolean,\n  ) {\n    this.emitter.emit(\n      CacheUpdateEvent.type,\n      new CacheUpdateEvent(id, isNew, parser, isActive),\n    );\n  }\n\n  raiseCacheDeleted(id: string) {\n    this.emitter.emit(CacheDeleteEvent.type, new CacheDeleteEvent(id));\n  }\n}\n","import React from \"react\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { ENDPOINTS, useColorMode, useConnectionConfig } from \"../../contexts\";\nimport { notify, shortenAddress } from \"../../utils\";\nimport { CopyOutlined } from \"@ant-design/icons\";\nimport { ModalEnum, useModal, useWalletModal } from \"../../contexts\";\nimport {\n  Box,\n  Button,\n  Collapse,\n  Divider,\n  Drawer,\n  FormControl,\n  Link,\n  List,\n  ListItem,\n  ListItemText,\n  ListItemButton,\n  MenuItem,\n  Select,\n  Stack,\n} from \"@mui/material\";\nimport { useTheme } from \"@mui/material/styles\";\n\nimport AccountBalanceWalletIcon from '@mui/icons-material/AccountBalanceWallet';\nimport Brightness4Icon from \"@mui/icons-material/Brightness4\";\nimport Brightness7Icon from \"@mui/icons-material/Brightness7\";\nimport ExpandLess from '@mui/icons-material/ExpandLess';\nimport ExpandMore from '@mui/icons-material/ExpandMore';\n\nexport const Settings = ({ narrow }) => {\n  const { disconnect, publicKey } = useWallet();\n  const { setEndpoint, env, endpoint } = useConnectionConfig();\n  const { setVisible } = useWalletModal();\n  const open = React.useCallback(() => setVisible(true), [setVisible]);\n  const { setModal } = useModal();\n  const theme = useTheme();\n  const colorModeCtx = useColorMode();\n\n  const handleConnect = React.useCallback(() => {\n    setModal(ModalEnum.WALLET);\n    setVisible(true);\n  }, [setModal, setVisible]);\n\n  const connectedActions = [\n    {\n      click: async () => {\n        if (publicKey) {\n          await navigator.clipboard.writeText(publicKey.toBase58());\n          notify({\n            message: \"Wallet update\",\n            description: \"Address copied to clipboard\",\n          });\n        }\n      },\n      innerNarrow: () => (\n        `Copy Address (${publicKey && shortenAddress(publicKey.toBase58())})`\n      ),\n      inner: () => (\n        <React.Fragment>\n          <CopyOutlined />\n          {publicKey && shortenAddress(publicKey.toBase58())}\n        </React.Fragment>\n      ),\n    },\n    {\n      click: open,\n      inner: () => \"Change\\u00A0Wallet\",\n    },\n    {\n      click: () => disconnect().catch(),\n      inner: () => `Disconnect\\u00A0(${env})`,\n      expandedExtra: { // these are interepreted as props. TODO: specific types\n        color: \"error\" as any,\n        variant: \"contained\" as any,\n      }\n    },\n  ];\n\n  const [drawerOpen, setDrawerOpen] = React.useState(false);\n  const [envCollapseOpen, setEnvCollapseOpen] = React.useState(false);\n\n  const hackySkipSet = \"hackySkipSet\";\n  const toggleDrawer = (open) => (event) => {\n    if (event.type === 'keydown' && (event.key === 'Tab' || event.key === 'Shift')) {\n      return;\n    }\n\n    if (event.target.classList.contains(hackySkipSet)) {\n      return;\n    }\n\n    setDrawerOpen(open);\n  };\n\n  const drawerC = (inner) => {\n    return (\n      <React.Fragment>\n        <Button onClick={toggleDrawer(true)}>\n          <AccountBalanceWalletIcon />\n        </Button>\n        <Drawer\n          anchor=\"right\"\n          open={drawerOpen}\n          onClose={toggleDrawer(false)}\n        >\n          <Box\n            sx={{ width: 250 }}\n            role=\"presentation\"\n            onClick={toggleDrawer(false)}\n            onKeyDown={toggleDrawer(false)}\n          >\n            {inner}\n          </Box>\n        </Drawer>\n      </React.Fragment>\n    );\n  };\n\n  const themeSwitch = (\n    <Button\n      sx={{ ml: 1 }}\n      onClick={colorModeCtx.toggleColorMode}\n      color=\"inherit\"\n    >\n      {theme.palette.mode === \"dark\" ? (\n        <Brightness7Icon />\n      ) : (\n        <Brightness4Icon />\n      )}\n    </Button>\n  );\n\n  if (narrow) {\n    const listHead = (\n      <ListItem>\n        <ListItemText\n          primary=\"Wallet\"\n          primaryTypographyProps={{\n            fontSize: \"1.2rem\",\n            fontWeight: 'medium',\n            letterSpacing: 0,\n          }}\n        />\n      </ListItem>\n    );\n    return (\n      <React.Fragment>\n        {!publicKey && drawerC(\n          <List>\n            {listHead}\n            <Divider />\n            <ListItemButton\n              onClick={() => setEnvCollapseOpen(!envCollapseOpen)}\n              className={hackySkipSet}\n            >\n              Change Network\n              {envCollapseOpen ? <ExpandLess /> : <ExpandMore />}\n            </ListItemButton>\n            <Collapse in={envCollapseOpen} timeout=\"auto\" unmountOnExit>\n              <List component=\"div\" disablePadding>\n                {ENDPOINTS.map(p => (\n                  <ListItemButton\n                    selected={endpoint === p.endpoint}\n                    onClick={() => setEndpoint(p.endpoint)}\n                    key={p.name}\n                    sx={{ pl: 4 }}\n                    className={hackySkipSet}\n                  >\n                    {p.name}\n                  </ListItemButton>\n                ))}\n              </List>\n            </Collapse>\n            <ListItemButton onClick={handleConnect}>\n              Connect\n            </ListItemButton>\n          </List>\n        )}\n        {publicKey && drawerC(\n          <List>\n            {listHead}\n            <Divider />\n            {connectedActions.map((a, idx) => {\n              return (\n                <ListItemButton onClick={a.click} key={idx}>\n                  {(a.innerNarrow && a.innerNarrow()) || a.inner()}\n                </ListItemButton>\n              );\n            })}\n          </List>\n        )}\n        {themeSwitch}\n      </React.Fragment>\n    );\n  } else {\n    return (\n      <Stack\n        direction=\"row\"\n        spacing={2}\n        sx={{\n          display: \"flex\",\n          justifyContent: \"flex-end\",\n          alignItems: \"center\",\n          marginRight: \"36px\",\n        }}\n      >\n        {!publicKey && (\n          <React.Fragment>\n            <FormControl variant=\"standard\" style={{minWidth: \"10ch\"}}>\n              <Select\n                id=\"connected-env-select\"\n                onChange={(e) => { setEndpoint(e.target.value); }}\n                value={endpoint}\n              >\n                {ENDPOINTS.map(({ name, endpoint }) => (\n                  <MenuItem key={name} value={endpoint}>{name}</MenuItem>\n                ))}\n              </Select>\n            </FormControl>\n            <Link underline=\"none\">\n              <Button\n                variant=\"contained\"\n                onClick={handleConnect}\n              >\n                Connect\n              </Button>\n            </Link>\n          </React.Fragment>\n        )}\n        {publicKey && connectedActions.map((a, idx) => {\n            return (\n              <Button\n                key={idx}\n                variant=\"outlined\"\n                onClick={a.click}\n                {...a.expandedExtra}\n              >\n                {a.inner()}\n              </Button>\n            );\n          })\n        }\n        {themeSwitch}\n      </Stack>\n    );\n  }\n};\n","import { useTheme } from \"@mui/material\";\nimport React, { useContext } from \"react\";\n\nexport const ColorModeContext = React.createContext({});\n\nexport const ColorModeContextProvider = ({children=null as any }) => {\n  const [mode, setMode] = React.useState<'light' | 'dark'>('dark'); \n  const theme = useTheme();\n  const toggleColorMode = () => {\n    setMode((prevMode) => (prevMode === 'light' ? 'dark' : 'light'));\n  }\n  return (\n    <ColorModeContext.Provider\n      value={{\n        toggleColorMode,\n        mode,\n        theme,\n      }}\n    >\n      {children}\n    </ColorModeContext.Provider>\n  );\n};\n\nexport const useColorMode = (): any => {\n  const context = useContext(ColorModeContext);\n  return context;\n};\n","import React from 'react';\nimport { notification } from 'antd';\n// import Link from '../components/Link';\n\nexport function notify({\n  message = '',\n  description = undefined as any,\n  txid = '',\n  type = 'info',\n  placement = 'bottomLeft',\n}) {\n  if (txid) {\n    //   <Link\n    //     external\n    //     to={'https://explorer.solana.com/tx/' + txid}\n    //     style={{ color: '#0000ff' }}\n    //   >\n    //     View transaction {txid.slice(0, 8)}...{txid.slice(txid.length - 8)}\n    //   </Link>\n\n    description = <></>;\n  }\n  (notification as any)[type]({\n    message: <span style={{ color: 'black' }}>{message}</span>,\n    description: (\n      <span style={{ color: 'black', opacity: 0.5 }}>{description}</span>\n    ),\n    placement,\n    style: {\n      backgroundColor: 'white',\n    },\n  });\n}\n","import { PublicKey } from '@solana/web3.js';\nimport { BinaryReader, BinaryWriter } from 'borsh';\nimport base58 from 'bs58';\nimport { StringPublicKey } from './ids';\n\nexport const extendBorsh = () => {\n  (BinaryReader.prototype as any).readPubkey = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return new PublicKey(array);\n  };\n\n  (BinaryWriter.prototype as any).writePubkey = function (value: PublicKey) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(value.toBuffer());\n  };\n\n  (BinaryReader.prototype as any).readPubkeyAsString = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return base58.encode(array) as StringPublicKey;\n  };\n\n  (BinaryWriter.prototype as any).writePubkeyAsString = function (\n    value: StringPublicKey,\n  ) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(base58.decode(value));\n  };\n};\n\nextendBorsh();\n","import {\n  Coder,\n} from \"@project-serum/anchor\"\n\nconst idl = require(\"./merkle_distributor.json\");\nexport const coder = new Coder(idl);\n\n","import { PublicKey, AccountInfo } from '@solana/web3.js';\n\nexport type StringPublicKey = string;\n\nexport class LazyAccountInfoProxy<T> {\n  executable: boolean = false;\n  owner: StringPublicKey = '';\n  lamports: number = 0;\n\n  get data() {\n    //\n    return undefined as unknown as T;\n  }\n}\n\nexport interface LazyAccountInfo {\n  executable: boolean;\n  owner: StringPublicKey;\n  lamports: number;\n  data: [string, string];\n}\n\nconst PubKeysInternedMap = new Map<string, PublicKey>();\n\nexport const toPublicKey = (key: string | PublicKey) => {\n  if (typeof key !== 'string') {\n    return key;\n  }\n\n  let result = PubKeysInternedMap.get(key);\n  if (!result) {\n    result = new PublicKey(key);\n    PubKeysInternedMap.set(key, result);\n  }\n\n  return result;\n};\n\nexport interface PublicKeyStringAndAccount<T> {\n  pubkey: string;\n  account: AccountInfo<T>;\n}\n\nexport const WRAPPED_SOL_MINT = new PublicKey('So11111111111111111111111111111111111111112');\n\nexport const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n\nexport const BPF_UPGRADE_LOADER_ID = new PublicKey('BPFLoaderUpgradeab1e11111111111111111111111');\n\nexport const MEMO_ID = new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');\n\nexport const SYSTEM = new PublicKey('11111111111111111111111111111111');\n\nexport const TOKEN_METADATA_PROGRAM_ID = new PublicKey(\"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\");\n\nexport const CANDY_MACHINE_ID = new PublicKey('cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ');\n\nexport const GUMDROP_DISTRIBUTOR_ID = new PublicKey(\"gdrpGjVffourzkdDRrQmySw4aTHr8a3xmQzzxSwFD1a\");\n\nexport const GUMDROP_TEMPORAL_SIGNER = new PublicKey(\"MSv9H2sMceAzccBganUXwGq3GXgqYAstmZAbFDZYbAV\");\n\n","import React from \"react\";\nimport { RouteComponentProps, } from \"react-router-dom\";\nimport queryString from 'query-string';\n\nimport {\n  Box,\n  Button,\n  CircularProgress,\n  FormControl,\n  Link as HyperLink,\n  InputLabel,\n  MenuItem,\n  Select,\n  Stack,\n  Step,\n  StepLabel,\n  Stepper,\n  TextField,\n} from \"@mui/material\";\n\nimport {\n  useWallet,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  Connection as RPCConnection,\n  Keypair,\n  PublicKey,\n  SystemProgram,\n  SYSVAR_RENT_PUBKEY,\n  SYSVAR_CLOCK_PUBKEY,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport {\n  AccountLayout,\n  MintLayout,\n  Token,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport { sha256 } from \"js-sha256\";\nimport BN from 'bn.js';\nimport * as bs58 from \"bs58\";\n\nimport {\n  useConnection,\n} from \"../contexts\";\nimport {\n  CANDY_MACHINE_ID,\n  GUMDROP_DISTRIBUTOR_ID,\n  GUMDROP_TEMPORAL_SIGNER,\n  TOKEN_METADATA_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  getCandyMachine,\n  getCandyMachineAddress,\n  getEdition,\n  getEditionMarkerPda,\n  getMetadata,\n  notify,\n} from \"../utils\";\nimport { MerkleTree } from \"../utils/merkleTree\";\nimport {\n  explorerLinkFor,\n  sendSignedTransaction,\n} from \"../utils/transactions\";\nimport {\n  chunk,\n} from \"../utils/claimant\";\nimport { coder } from \"../utils/merkleDistributor\";\n\nconst walletKeyOrPda = async (\n  walletKey : PublicKey,\n  handle : string,\n  pin : BN | null,\n  seed : PublicKey,\n) : Promise<[PublicKey, Array<Buffer>]> => {\n  if (pin === null) {\n    try {\n      const key = new PublicKey(handle);\n      if (!key.equals(walletKey)) {\n        throw new Error(\"Claimant wallet handle does not match connected wallet\");\n      }\n      return [key, []];\n    } catch (err) {\n      throw new Error(`Invalid claimant wallet handle ${err}`);\n    }\n  } else {\n    const seeds = [\n      seed.toBuffer(),\n      Buffer.from(handle),\n      Buffer.from(pin.toArray(\"le\", 4)),\n    ];\n\n    const [claimantPda, ] = await PublicKey.findProgramAddress(\n      [\n        seeds[0],\n        ...chunk(seeds[1], 32),\n        seeds[2],\n      ],\n      GUMDROP_DISTRIBUTOR_ID\n    );\n    return [claimantPda, seeds];\n  }\n}\n\n\nconst buildMintClaim = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  distributorKey : PublicKey,\n  distributorInfo : any,\n  tokenAcc : string,\n  proof : Array<Buffer>,\n  handle : string,\n  amount : number,\n  index : number,\n  pin : BN | null,\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\n  let tokenAccKey: PublicKey;\n  try {\n    tokenAccKey = new PublicKey(tokenAcc);\n  } catch (err) {\n    throw new Error(`Invalid tokenAcc key ${err}`);\n  }\n  const distTokenAccount = await connection.getAccountInfo(tokenAccKey);\n  if (distTokenAccount === null) {\n    throw new Error(`Could not fetch distributor token account`);\n  }\n\n  const tokenAccountInfo = AccountLayout.decode(distTokenAccount.data);\n  const mint = new PublicKey(tokenAccountInfo.mint);\n\n  console.log(mint.toBase58());\n\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, mint);\n\n  // TODO: since it's in the PDA do we need it to be in the leaf?\n  const leaf = Buffer.from(\n    [...new BN(index).toArray(\"le\", 8),\n     ...secret.toBuffer(),\n     ...mint.toBuffer(),\n     ...new BN(amount).toArray(\"le\", 8),\n    ]\n  );\n\n  const matches = MerkleTree.verifyClaim(\n    leaf, proof, Buffer.from(distributorInfo.root)\n  );\n\n  if (!matches) {\n    throw new Error(\"Gumdrop merkle proof does not match\");\n  }\n\n  const [claimStatus, cbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"ClaimStatus\"),\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  const [walletTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      walletKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      mint.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n\n  const setup : Array<TransactionInstruction> = [];\n\n  if (await connection.getAccountInfo(walletTokenKey) === null) {\n    setup.push(Token.createAssociatedTokenAccountInstruction(\n        SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n        TOKEN_PROGRAM_ID,\n        mint,\n        walletTokenKey,\n        walletKey,\n        walletKey\n      ));\n  }\n\n  const temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\n      ? walletKey : distributorInfo.temporal;\n\n  const claimAirdrop = new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: distributorKey          , isSigner: false , isWritable: true  } ,\n          { pubkey: claimStatus             , isSigner: false , isWritable: true  } ,\n          { pubkey: tokenAccKey             , isSigner: false , isWritable: true  } ,\n          { pubkey: walletTokenKey          , isSigner: false , isWritable: true  } ,\n          { pubkey: temporalSigner          , isSigner: true  , isWritable: false } ,\n          { pubkey: walletKey               , isSigner: true  , isWritable: false } ,  // payer\n          { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_PROGRAM_ID        , isSigner: false , isWritable: false } ,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:claim\")).slice(0, 8),\n        ...new BN(cbump).toArray(\"le\", 1),\n        ...new BN(index).toArray(\"le\", 8),\n        ...new BN(amount).toArray(\"le\", 8),\n        ...secret.toBuffer(),\n        ...new BN(proof.length).toArray(\"le\", 4),\n        ...Buffer.concat(proof),\n      ])\n  })\n\n  return [[...setup, claimAirdrop], pdaSeeds, []];\n}\n\nconst buildCandyClaim = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  distributorKey : PublicKey,\n  distributorInfo : any,\n  candyConfig : string,\n  candyUUID : string,\n  proof : Array<Buffer>,\n  handle : string,\n  amount : number,\n  index : number,\n  pin : BN | null,\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\n\n  let configKey : PublicKey;\n  try {\n    configKey = new PublicKey(candyConfig);\n  } catch (err) {\n    throw new Error(`Invalid candy config key ${err}`);\n  }\n\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, configKey);\n\n  // TODO: since it's in the PDA do we need it to be in the leaf?\n  const leaf = Buffer.from(\n    [...new BN(index).toArray(\"le\", 8),\n     ...secret.toBuffer(),\n     ...configKey.toBuffer(),\n     ...new BN(amount).toArray(\"le\", 8),\n    ]\n  );\n\n  const matches = MerkleTree.verifyClaim(\n    leaf, proof, Buffer.from(distributorInfo.root)\n  );\n\n  if (!matches) {\n    throw new Error(\"Gumdrop merkle proof does not match\");\n  }\n\n  const [claimCount, cbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"ClaimCount\"),\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  const [distributorWalletKey, wbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"Wallet\"),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  // atm the contract has a special case for when the temporal key is defaulted\n  // (aka always passes temporal check)\n  // TODO: more flexible\n  let temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\n      ? walletKey : distributorInfo.temporal;\n\n  const setup : Array<TransactionInstruction> = [];\n\n  const claimCountAccount = await connection.getAccountInfo(claimCount);\n  let nftsAlreadyMinted = 0;\n  if (claimCountAccount === null) {\n  } else {\n    // TODO: subtract already minted?...\n    const claimAccountInfo = coder.accounts.decode(\n      \"ClaimCount\", claimCountAccount.data);\n    nftsAlreadyMinted = claimAccountInfo.count;\n    if (claimAccountInfo.claimant.equals(walletKey)) {\n      // we already proved this claim and verified the OTP once, contract knows\n      // that this wallet is OK\n      temporalSigner = walletKey;\n    } else {\n      // need to claim with the first wallet...\n      const claimantStr = claimAccountInfo.claimant.toBase58();\n      throw new Error(`This wallet does not match existing claimant ${claimantStr}`);\n    }\n  }\n\n  const nftsAvailable = amount;\n  if (nftsAlreadyMinted >= nftsAvailable) {\n    throw new Error(`Cannot mint another NFT. ${nftsAvailable} NFT(s) were originally allocated`\n      + (nftsAlreadyMinted > 0 ? ` and ${nftsAlreadyMinted} NFT(s) were already minted` : \"\"));\n  }\n\n\n  const [candyMachineKey, ] = await getCandyMachineAddress(configKey, candyUUID);\n  const candyMachine = await getCandyMachine(connection, candyMachineKey);\n  console.log(\"Candy Machine\", candyMachine);\n\n  const candyMachineMints : Array<Keypair> = [];\n\n  const [instrs, mint] = await buildSingleCandyMint(\n    connection,\n    walletKey,\n    distributorKey,\n    distributorWalletKey,\n    claimCount,\n    temporalSigner,\n    configKey,\n    candyMachineKey,\n    candyMachine.wallet,\n    Buffer.from([\n      ...new BN(wbump).toArray(\"le\", 1),\n      ...new BN(cbump).toArray(\"le\", 1),\n      ...new BN(index).toArray(\"le\", 8),\n      ...new BN(amount).toArray(\"le\", 8),\n      ...secret.toBuffer(),\n      ...new BN(proof.length).toArray(\"le\", 4),\n      ...Buffer.concat(proof),\n    ]),\n  );\n  candyMachineMints.push(mint);\n  setup.push(...instrs);\n\n  return [setup, pdaSeeds, candyMachineMints];\n}\n\nconst buildSingleCandyMint = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  distributorKey : PublicKey,\n  distributorWalletKey : PublicKey,\n  claimCount : PublicKey,\n  temporalSigner : PublicKey,\n  configKey : PublicKey,\n  candyMachineKey : PublicKey,\n  candyMachineWallet : PublicKey,\n  data : Buffer,\n) : Promise<[Array<TransactionInstruction>, Keypair]> => {\n  const candyMachineMint = Keypair.generate();\n  const candyMachineMetadata = await getMetadata(candyMachineMint.publicKey);\n  const candyMachineMaster = await getEdition(candyMachineMint.publicKey);\n\n  const setup : Array<TransactionInstruction> = [];\n  await createMintAndAccount(connection, walletKey, candyMachineMint.publicKey, setup);\n  setup.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: distributorKey            , isSigner: false , isWritable: true  } ,\n          { pubkey: distributorWalletKey      , isSigner: false , isWritable: true  } ,\n          { pubkey: claimCount                , isSigner: false , isWritable: true  } ,\n          { pubkey: temporalSigner            , isSigner: true  , isWritable: false } ,\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // payer\n\n          { pubkey: configKey                 , isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineKey           , isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineWallet        , isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineMint.publicKey, isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineMetadata      , isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineMaster        , isSigner: false , isWritable: true  } ,\n\n          { pubkey: SystemProgram.programId   , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_PROGRAM_ID          , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_METADATA_PROGRAM_ID , isSigner: false , isWritable: false } ,\n          { pubkey: CANDY_MACHINE_ID          , isSigner: false , isWritable: false } ,\n          { pubkey: SYSVAR_RENT_PUBKEY        , isSigner: false , isWritable: false } ,\n          { pubkey: SYSVAR_CLOCK_PUBKEY       , isSigner: false , isWritable: false } ,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:claim_candy\")).slice(0, 8),\n        ...data,\n      ])\n  }));\n\n  return [setup, candyMachineMint];\n}\n\nconst createMintAndAccount = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  mint : PublicKey,\n  setup : Array<TransactionInstruction>,\n) => {\n  const [walletTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      walletKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      mint.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n\n  setup.push(SystemProgram.createAccount({\n    fromPubkey: walletKey,\n    newAccountPubkey: mint,\n    space: MintLayout.span,\n    lamports:\n      await connection.getMinimumBalanceForRentExemption(\n        MintLayout.span,\n      ),\n    programId: TOKEN_PROGRAM_ID,\n  }));\n\n  setup.push(Token.createInitMintInstruction(\n    TOKEN_PROGRAM_ID,\n    mint,\n    0,\n    walletKey,\n    walletKey,\n  ));\n\n  setup.push(Token.createAssociatedTokenAccountInstruction(\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    mint,\n    walletTokenKey,\n    walletKey,\n    walletKey\n  ));\n\n  setup.push(Token.createMintToInstruction(\n    TOKEN_PROGRAM_ID,\n    mint,\n    walletTokenKey,\n    walletKey,\n    [],\n    1,\n  ));\n\n}\n\nconst buildEditionClaim = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  distributorKey : PublicKey,\n  distributorInfo : any,\n  masterMint : string,\n  edition : number,\n  proof : Array<Buffer>,\n  handle : string,\n  amount : number,\n  index : number,\n  pin : BN | null,\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\n\n  let masterMintKey : PublicKey;\n  try {\n    masterMintKey = new PublicKey(masterMint);\n  } catch (err) {\n    throw new Error(`Invalid master mint key ${err}`);\n  }\n\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, masterMintKey);\n\n  // should we assert that the amount is 1?\n  const leaf = Buffer.from(\n    [...new BN(index).toArray(\"le\", 8),\n     ...secret.toBuffer(),\n     ...masterMintKey.toBuffer(),\n     ...new BN(amount).toArray(\"le\", 8),\n     ...new BN(edition).toArray(\"le\", 8),\n    ]\n  );\n\n  const matches = MerkleTree.verifyClaim(\n    leaf, proof, Buffer.from(distributorInfo.root)\n  );\n\n  if (!matches) {\n    throw new Error(\"Gumdrop merkle proof does not match\");\n  }\n\n  const [claimCount, cbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"ClaimCount\"),\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  // atm the contract has a special case for when the temporal key is defaulted\n  // (aka always passes temporal check)\n  // TODO: more flexible\n  let temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\n      ? walletKey : distributorInfo.temporal;\n\n  const claimCountAccount = await connection.getAccountInfo(claimCount);\n  if (claimCountAccount !== null) {\n    throw new Error(`This edition was already claimed`);\n  }\n\n  const setup : Array<TransactionInstruction> = [];\n\n  const newMint = Keypair.generate();\n  const newMetadataKey = await getMetadata(newMint.publicKey);\n  const masterMetadataKey = await getMetadata(masterMintKey);\n  const newEdition = await getEdition(newMint.publicKey);\n  const masterEdition = await getEdition(masterMintKey);\n\n  await createMintAndAccount(connection, walletKey, newMint.publicKey, setup);\n\n  const [distributorTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      distributorKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      masterMintKey.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n\n  const editionMarkKey = await getEditionMarkerPda(masterMintKey, new BN(edition));\n\n  setup.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: distributorKey            , isSigner: false , isWritable: true  } ,\n          { pubkey: claimCount                , isSigner: false , isWritable: true  } ,\n          { pubkey: temporalSigner            , isSigner: true  , isWritable: false } ,\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // payer\n\n          { pubkey: newMetadataKey            , isSigner: false , isWritable: true  } ,\n          { pubkey: newEdition                , isSigner: false , isWritable: true  } ,\n          { pubkey: masterEdition             , isSigner: false , isWritable: true  } ,\n          { pubkey: newMint.publicKey         , isSigner: false , isWritable: true  } ,\n          { pubkey: editionMarkKey            , isSigner: false , isWritable: true  } ,\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // `newMint` auth\n          { pubkey: distributorTokenKey       , isSigner: false , isWritable: false } ,\n          { pubkey: walletKey                 , isSigner: false , isWritable: false } , // new update auth\n          { pubkey: masterMetadataKey         , isSigner: false , isWritable: false } ,\n          { pubkey: masterMintKey             , isSigner: false , isWritable: false } ,\n\n          { pubkey: SystemProgram.programId   , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_PROGRAM_ID          , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_METADATA_PROGRAM_ID , isSigner: false , isWritable: false } ,\n          { pubkey: SYSVAR_RENT_PUBKEY        , isSigner: false , isWritable: false } ,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:claim_edition\")).slice(0, 8),\n        ...new BN(cbump).toArray(\"le\", 1),\n        ...new BN(index).toArray(\"le\", 8),\n        ...new BN(amount).toArray(\"le\", 8),\n        ...new BN(edition).toArray(\"le\", 8),\n        ...secret.toBuffer(),\n        ...new BN(proof.length).toArray(\"le\", 4),\n        ...Buffer.concat(proof),\n      ])\n  }));\n\n  return [setup, pdaSeeds, [newMint]];\n}\n\nconst fetchDistributor = async (\n  connection : RPCConnection,\n  distributorStr : string,\n) => {\n  let key;\n  try {\n    key = new PublicKey(distributorStr);\n  } catch (err) {\n    throw new Error(`Invalid distributor key ${err}`);\n  }\n  const account = await connection.getAccountInfo(key);\n  if (account === null) {\n    throw new Error(`Could not fetch distributor ${distributorStr}`);\n  }\n  if (!account.owner.equals(GUMDROP_DISTRIBUTOR_ID)) {\n    const ownerStr = account.owner.toBase58();\n    throw new Error(`Invalid distributor owner ${ownerStr}`);\n  }\n  const info = coder.accounts.decode(\"MerkleDistributor\", account.data);\n  return [key, info];\n};\n\nconst fetchNeedsTemporalSigner = async (\n  connection : RPCConnection,\n  distributorStr : string,\n  indexStr : string,\n  claimMethod : string,\n) => {\n  const [key, info] = await fetchDistributor(connection, distributorStr);\n  if (!info.temporal.equals(GUMDROP_TEMPORAL_SIGNER)) {\n    // default pubkey or program itself (distribution through wallets)\n    return false;\n  } else if (claimMethod === \"candy\") {\n    const [claimCount, ] = await PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"ClaimCount\"),\n        Buffer.from(new BN(Number(indexStr)).toArray(\"le\", 8)),\n        key.toBuffer(),\n      ],\n      GUMDROP_DISTRIBUTOR_ID\n    );\n    // if someone (maybe us) has already claimed this, the contract will\n    // not check the existing temporal signer anymore since presumably\n    // they have already verified the OTP. So we need to fetch the temporal\n    // signer if it is null\n    const claimCountAccount = await connection.getAccountInfo(claimCount);\n    return claimCountAccount === null;\n  } else {\n    // default to need one\n    return true;\n  }\n};\n\nexport type ClaimProps = {};\n\nexport const Claim = (\n  props : RouteComponentProps<ClaimProps>,\n) => {\n  const connection = useConnection();\n  const wallet = useWallet();\n\n  let query = props.location.search;\n  if (query && query.length > 0) {\n    localStorage.setItem(\"claimQuery\", query);\n  } else {\n    const stored = localStorage.getItem(\"claimQuery\");\n    if (stored)\n      query = stored;\n  }\n\n  let params = queryString.parse(query);\n  const [distributor, setDistributor] = React.useState(params.distributor as string || \"\");\n  const [claimMethod, setClaimMethod] = React.useState(\n        params.tokenAcc ? \"transfer\"\n      : params.config   ? \"candy\"\n      : params.master   ? \"edition\"\n      :                   \"\");\n  const [tokenAcc, setTokenAcc] = React.useState(params.tokenAcc as string || \"\");\n  const [candyConfig, setCandyConfig] = React.useState(params.config as string || \"\");\n  const [candyUUID, setCandyUUID] = React.useState(params.uuid as string || \"\");\n  const [masterMint, setMasterMint] = React.useState(params.master as string || \"\");\n  const [editionStr, setEditionStr] = React.useState(params.edition as string || \"\");\n  const [handle, setHandle] = React.useState(params.handle as string || \"\");\n  const [amountStr, setAmount] = React.useState(params.amount as string || \"\");\n  const [indexStr, setIndex] = React.useState(params.index as string || \"\");\n  const [pinStr, setPin] = React.useState(params.pin as string || \"\");\n  const [proofStr, setProof] = React.useState(params.proof as string || \"\");\n\n  const discordGuild = params.guild;\n\n  const allFieldsPopulated =\n    distributor.length > 0\n    && ( claimMethod === \"transfer\" ? tokenAcc.length > 0\n       : claimMethod === \"candy\"    ? candyConfig.length > 0 && candyUUID.length > 0\n       : claimMethod === \"edition\"  ? masterMint.length > 0 && editionStr.length > 0\n       :                              false\n       )\n    && handle.length > 0\n    && amountStr.length > 0\n    && indexStr.length > 0;\n    // NB: pin can be empty if handle is a public-key and we are claiming through wallets\n    // NB: proof can be empty!\n\n  const [editable, setEditable] = React.useState(!allFieldsPopulated);\n\n  // temporal verification\n  const [transaction, setTransaction] = React.useState<Transaction | null>(null);\n  const [OTPStr, setOTPStr] = React.useState(\"\");\n\n  // async computed\n  const [asyncNeedsTemporalSigner, setNeedsTemporalSigner] = React.useState<boolean>(true);\n\n  React.useEffect(() => {\n    const wrap = async () => {\n      try {\n        setNeedsTemporalSigner(await fetchNeedsTemporalSigner(\n          connection, distributor, indexStr, claimMethod));\n      } catch {\n        // TODO: log?\n      }\n    };\n    wrap();\n  }, [connection, distributor, indexStr, claimMethod]);\n\n  const lambdaAPIEndpoint = \"https://n82bm4ts81.execute-api.us-east-2.amazonaws.com/send-OTP\";\n\n  const skipAWSWorkflow = false;\n\n  const sendOTP = async (e : React.SyntheticEvent) => {\n    e.preventDefault();\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const index = Number(indexStr);\n    const amount = Number(amountStr);\n    let pin : BN | null = null;\n\n    if (isNaN(amount)) {\n      throw new Error(`Could not parse amount ${amountStr}`);\n    }\n    if (isNaN(index)) {\n      throw new Error(`Could not parse index ${indexStr}`);\n    }\n    if (params.pin !== \"NA\") {\n      try {\n        pin = new BN(pinStr);\n      } catch (err) {\n        throw new Error(`Could not parse pin ${pinStr}: ${err}`);\n      }\n    }\n\n    // TODO: use cached?\n    const [distributorKey, distributorInfo] =\n        await fetchDistributor(connection, distributor);\n\n    console.log(\"Distributor\", distributorInfo);\n\n    const proof = proofStr === \"\" ? [] : proofStr.split(\",\").map(b => {\n      const ret = Buffer.from(bs58.decode(b))\n      if (ret.length !== 32)\n        throw new Error(`Invalid proof hash length`);\n      return ret;\n    });\n\n    let instructions, pdaSeeds, extraSigners;\n    if (claimMethod === \"candy\") {\n      console.log(\"Building candy claim\");\n      [instructions, pdaSeeds, extraSigners] = await buildCandyClaim(\n        connection, wallet.publicKey, distributorKey, distributorInfo,\n        candyConfig, candyUUID,\n        proof, handle, amount, index, pin\n      );\n    } else if (claimMethod === \"transfer\") {\n      [instructions, pdaSeeds, extraSigners] = await buildMintClaim(\n        connection, wallet.publicKey, distributorKey, distributorInfo,\n        tokenAcc,\n        proof, handle, amount, index, pin\n      );\n    } else if (claimMethod === \"edition\") {\n      const edition = Number(editionStr);\n      if (isNaN(edition)) {\n        throw new Error(`Could not parse edition ${editionStr}`);\n      }\n      [instructions, pdaSeeds, extraSigners] = await buildEditionClaim(\n        connection, wallet.publicKey, distributorKey, distributorInfo,\n        masterMint, edition,\n        proof, handle, amount, index, pin\n      );\n    } else {\n      throw new Error(`Unknown claim method ${claimMethod}`);\n    }\n\n    // NB: if we're claiming through wallets then pdaSeeds should be empty\n    // since the secret is the wallet key (which is also a signer)\n    if (pin === null && pdaSeeds.length > 0) {\n      throw new Error(`Internal error: PDA generated when distributing to wallet directly`);\n    }\n\n    let transaction = new Transaction({\n      feePayer: wallet.publicKey,\n      recentBlockhash: (await connection.getRecentBlockhash(\"singleGossip\")).blockhash,\n    });\n\n    const signers = new Set<PublicKey>();\n    for (const instr of instructions) {\n      transaction.add(instr);\n      for (const key of instr.keys)\n        if (key.isSigner)\n          signers.add(key.pubkey);\n    }\n    console.log(`Expecting the following signers: ${[...signers].map(s => s.toBase58())}`);\n    transaction.setSigners(...signers);\n\n    if (extraSigners.length > 0) {\n      transaction.partialSign(...extraSigners);\n    }\n\n    const txnNeedsTemporalSigner =\n        transaction.signatures.some(s => s.publicKey.equals(GUMDROP_TEMPORAL_SIGNER));\n    if (txnNeedsTemporalSigner && !skipAWSWorkflow) {\n      const otpQuery : { [key: string] : any } = {\n        method: \"send\",\n        transaction: bs58.encode(transaction.serializeMessage()),\n        seeds: pdaSeeds,\n      };\n      if (discordGuild) {\n        otpQuery.discordGuild = discordGuild;\n      }\n      const params = {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(otpQuery),\n      };\n\n      const response = await fetch(lambdaAPIEndpoint, params);\n      console.log(response);\n\n      if (response.status !== 200) {\n        throw new Error(`Failed to send AWS OTP`);\n      }\n\n      let data;\n      try {\n        data = await response.json();\n      } catch {\n        throw new Error(`Could not parse AWS OTP response`);\n      }\n\n      console.log(\"AWS OTP response data:\", data);\n\n      let succeeded, toCheck;\n      if (discordGuild) {\n        succeeded = !!data.id;\n        toCheck = \"discord\";\n      } else {\n        succeeded = !!data.MessageId;\n        toCheck = \"email\";\n      }\n\n      if (!succeeded) {\n        throw new Error(`Failed to send AWS OTP`);\n      }\n\n      notify({\n        message: \"OTP sent\",\n        description: `Please check your ${toCheck} (${handle}) for an OTP`,\n      });\n    }\n\n    return transaction;\n  };\n\n  const verifyOTP = async (\n    e : React.SyntheticEvent,\n    transaction : Transaction | null,\n  ) => {\n    e.preventDefault();\n\n    if (!transaction) {\n      throw new Error(`Transaction not available for OTP verification`);\n    }\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const txnNeedsTemporalSigner =\n        transaction.signatures.some(s => s.publicKey.equals(GUMDROP_TEMPORAL_SIGNER));\n    if (txnNeedsTemporalSigner && !skipAWSWorkflow) {\n      // TODO: distinguish between OTP failure and transaction-error. We can try\n      // again on the former but not the latter\n      const OTP = Number(OTPStr);\n      if (isNaN(OTP) || OTPStr.length === 0) {\n        throw new Error(`Could not parse OTP ${OTPStr}`);\n      }\n\n      const params = {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        FunctionName: \"send-OTP\",\n        body: JSON.stringify({\n          method: \"verify\",\n          otp: OTP,\n          handle: handle,  // TODO?\n        }),\n      };\n\n      const response = await fetch(lambdaAPIEndpoint, params);\n      console.log(response);\n\n      if (response.status !== 200) {\n        const blob = JSON.stringify(response);\n        throw new Error(`Failed to verify AWS OTP. ${blob}`);\n      }\n\n      let data;\n      try {\n        data = await response.json();\n      } catch {\n        throw new Error(`Could not parse AWS OTP verification response`);\n      }\n\n      console.log(\"AWS verify response data:\", data);\n\n      let sig;\n      try {\n        sig = bs58.decode(data);\n      } catch {\n        throw new Error(`Could not decode transaction signature ${data.body}`);\n      }\n\n      transaction.addSignature(GUMDROP_TEMPORAL_SIGNER, sig);\n    }\n\n    let fullySigned;\n    try {\n      fullySigned = await wallet.signTransaction(transaction);\n    } catch {\n      throw new Error(\"Failed to sign transaction\");\n    }\n\n    const claimResult = await sendSignedTransaction({\n      connection,\n      signedTransaction: fullySigned,\n    });\n\n    console.log(claimResult);\n    notify({\n      message: \"Claim succeeded\",\n      description: (\n        <HyperLink href={explorerLinkFor(claimResult.txid, connection)}>\n          View transaction on explorer\n        </HyperLink>\n      ),\n    });\n    setTransaction(null);\n    try {\n      setNeedsTemporalSigner(await fetchNeedsTemporalSigner(\n        connection, distributor, indexStr, claimMethod));\n    } catch {\n      // TODO: log?\n    }\n  };\n\n  const [loading, setLoading] = React.useState(false);\n  const loadingProgress = () => (\n    <CircularProgress\n      size={24}\n      sx={{\n        position: 'absolute',\n        top: '50%',\n        left: '50%',\n        marginTop: '-12px',\n        marginLeft: '-12px',\n      }}\n    />\n  );\n\n  const verifyOTPC = (onClick) => (\n    <React.Fragment>\n      <TextField\n        id=\"otp-text-field\"\n        label=\"OTP\"\n        value={OTPStr}\n        onChange={(e) => setOTPStr(e.target.value)}\n      />\n      <Box />\n\n      <Box sx={{ position: \"relative\" }}>\n      <Button\n        disabled={!wallet.connected || !OTPStr || loading}\n        variant=\"contained\"\n        color=\"success\"\n        style={{ width: \"100%\" }}\n        onClick={(e) => {\n          setLoading(true);\n          const wrap = async () => {\n            try {\n              await verifyOTP(e, transaction);\n              setLoading(false);\n              onClick();\n            } catch (err) {\n              notify({\n                message: \"Claim failed\",\n                description: `${err}`,\n              });\n              setLoading(false);\n            }\n          };\n          wrap();\n        }}\n      >\n        Claim Gumdrop\n      </Button>\n      {loading && loadingProgress()}\n      </Box>\n    </React.Fragment>\n  );\n\n  const claimData = (claimMethod) => {\n    if (claimMethod === \"candy\") {\n      return (\n        <React.Fragment>\n          <TextField\n            id=\"config-text-field\"\n            label=\"Candy Config\"\n            value={candyConfig}\n            onChange={e => setCandyConfig(e.target.value)}\n            disabled={!editable}\n          />\n          <TextField\n            id=\"config-uuid-text-field\"\n            label=\"Candy UUID\"\n            value={candyUUID}\n            onChange={e => setCandyUUID(e.target.value)}\n            disabled={!editable}\n          />\n        </React.Fragment>\n      );\n    } else if (claimMethod === \"transfer\") {\n      return (\n        <React.Fragment>\n          <TextField\n            id=\"token-acc-text-field\"\n            label=\"Source Token Account\"\n            value={tokenAcc}\n            onChange={(e) => setTokenAcc(e.target.value)}\n            disabled={!editable}\n          />\n        </React.Fragment>\n      );\n    } else if (claimMethod === \"edition\") {\n      return (\n        <React.Fragment>\n          <TextField\n            id=\"master-mint-text-field\"\n            label=\"Master Mint\"\n            value={masterMint}\n            onChange={(e) => setMasterMint(e.target.value)}\n            disabled={!editable}\n          />\n          <TextField\n            id=\"edition-text-field\"\n            label=\"Edition\"\n            value={editionStr}\n            onChange={(e) => setEditionStr(e.target.value)}\n            disabled={!editable}\n          />\n        </React.Fragment>\n      );\n    }\n  };\n\n  const populateClaimC = (onClick) => (\n    <React.Fragment>\n      <TextField\n        id=\"distributor-text-field\"\n        label=\"Distributor\"\n        value={distributor}\n        onChange={(e) => setDistributor(e.target.value)}\n        disabled={!editable}\n      />\n      <FormControl fullWidth>\n        <InputLabel\n          id=\"claim-method-label\"\n          disabled={!editable}\n        >\n          Claim Method\n        </InputLabel>\n        <Select\n          labelId=\"claim-method-label\"\n          id=\"claim-method-select\"\n          value={claimMethod}\n          label=\"Claim Method\"\n          onChange={(e) => { setClaimMethod(e.target.value); }}\n          style={{textAlign: \"left\"}}\n          disabled={!editable}\n        >\n          <MenuItem value={\"transfer\"}>Token Transfer</MenuItem>\n          <MenuItem value={\"candy\"}>Candy Machine</MenuItem>\n          <MenuItem value={\"edition\"}>Limited Edition</MenuItem>\n        </Select>\n      </FormControl>\n      {claimMethod !== \"\" && claimData(claimMethod)}\n      {claimMethod !== \"edition\" && <TextField\n        id=\"amount-text-field\"\n        label=\"Amount\"\n        value={amountStr}\n        onChange={(e) => setAmount(e.target.value)}\n        disabled={!editable}\n      />}\n      <TextField\n        id=\"handle-text-field\"\n        label=\"Handle\"\n        value={handle}\n        onChange={(e) => setHandle(e.target.value)}\n        disabled={!editable}\n      />\n      <TextField\n        id=\"index-text-field\"\n        label=\"Index\"\n        value={indexStr}\n        onChange={(e) => setIndex(e.target.value)}\n        disabled={!editable}\n      />\n      {params.pin !== \"NA\" && <TextField\n        id=\"pin-text-field\"\n        label=\"Pin\"\n        value={pinStr}\n        onChange={(e) => setPin(e.target.value)}\n        disabled={!editable}\n      />}\n      <TextField\n        id=\"proof-text-field\"\n        label=\"Proof\"\n        multiline\n        value={proofStr}\n        onChange={(e) => setProof(e.target.value)}\n        disabled={!editable}\n      />\n      <Button\n        color=\"info\"\n        onClick={(e) => setEditable(!editable)}\n      >\n        {!editable ? \"Edit Claim\" : \"Stop Editing\"}\n      </Button>\n      <Box />\n\n      <Box sx={{ position: \"relative\" }}>\n      <Button\n        disabled={!wallet.connected || !allFieldsPopulated || loading}\n        variant=\"contained\"\n        style={{ width: \"100%\" }}\n        color={asyncNeedsTemporalSigner ? \"primary\" : \"success\"}\n        onClick={(e) => {\n          setLoading(true);\n          const wrap = async () => {\n            try {\n              const needsTemporalSigner = await fetchNeedsTemporalSigner(\n                  connection, distributor, indexStr, claimMethod);\n              const transaction = await sendOTP(e);\n              if (!needsTemporalSigner) {\n                await verifyOTP(e, transaction);\n              } else {\n                setTransaction(transaction);\n              }\n              setLoading(false);\n              onClick();\n            } catch (err) {\n              notify({\n                message: \"Claim failed\",\n                description: `${err}`,\n              });\n              setLoading(false);\n            }\n          };\n          wrap();\n        }}\n      >\n        {asyncNeedsTemporalSigner ? \"Next\" : \"Claim Gumdrop\"}\n      </Button>\n      {loading && loadingProgress()}\n      </Box>\n    </React.Fragment>\n  );\n\n  const steps = [\n    { name: \"Populate Claim\", inner: populateClaimC },\n  ];\n  if (asyncNeedsTemporalSigner) {\n    steps.push(\n    { name: \"Verify OTP\"    , inner: verifyOTPC     }\n    );\n  }\n\n  // TODO: better interaction between setting `asyncNeedsTemporalSigner` and\n  // the stepper... this is pretty jank\n  const [activeStep, setActiveStep] = React.useState(0);\n  const stepToUse = Math.min(activeStep, steps.length - 1);\n\n  const handleNext = () => {\n    // return to start if going past the end (claim succeeded)\n    setActiveStep(prev => {\n      if (prev === steps.length - 1) {\n        return 0;\n      } else {\n        return prev + 1;\n      }\n    });\n  };\n  const handleBack = () => {\n    setActiveStep(prev => prev - 1);\n  };\n\n  const stepper = (\n    <React.Fragment>\n      <Stepper activeStep={stepToUse}>\n        {steps.map((s, index) => {\n          return (\n            <Step key={s.name}>\n              <StepLabel>{s.name}</StepLabel>\n            </Step>\n          );\n        })}\n      </Stepper>\n      <Box />\n    </React.Fragment>\n  );\n\n  return (\n    <Stack spacing={2}>\n      {asyncNeedsTemporalSigner && stepper}\n      {steps[stepToUse].inner(handleNext)}\n      {stepToUse > 0 && (\n        <Button\n          color=\"info\"\n          onClick={handleBack}\n        >\n          Back\n        </Button>\n      )}\n    </Stack>\n  );\n};\n\n","import { WalletAdapter, WalletError } from \"@solana/wallet-adapter-base\";\nimport {\n  useWallet,\n  WalletProvider as BaseWalletProvider,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  getLedgerWallet,\n  getMathWallet,\n  getPhantomWallet,\n  getSolflareWallet,\n  getSolletWallet,\n  getSolongWallet,\n  getTorusWallet,\n} from \"@solana/wallet-adapter-wallets\";\nimport { Button } from \"antd\";\nimport React, {\n  createContext,\n  FC,\n  ReactNode,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\nimport { notify } from \"../../utils\";\nimport { DefaultModal } from \"../../components\";\n\nimport \"./wallet.less\";\n\nexport interface WalletModalContextState {\n  visible: boolean;\n  setVisible: (open: boolean) => void;\n}\n\nexport const WalletModalContext = createContext<WalletModalContextState>(\n  {} as WalletModalContextState\n);\n\nexport function useWalletModal(): WalletModalContextState {\n  return useContext(WalletModalContext);\n}\n\nexport const WalletModal: FC = () => {\n  const { wallets, wallet: selected, select } = useWallet();\n  const { visible, setVisible } = useWalletModal();\n  const [ , setShowWallets] = useState(false);\n  const close = useCallback(() => {\n    setVisible(false);\n    setShowWallets(false);\n  }, [setVisible, setShowWallets]);\n\n  return (\n    <DefaultModal visible={visible} onCancel={close}>\n      <div\n        style={{\n          background:\n            \"linear-gradient(180deg, #D329FC 0%, #8F6DDE 49.48%, #19E6AD 100%)\",\n          borderRadius: 36,\n          width: 50,\n          height: 50,\n          textAlign: \"center\",\n          verticalAlign: \"middle\",\n          fontWeight: 700,\n          fontSize: \"1.3rem\",\n          lineHeight: 2.4,\n          marginBottom: 10,\n        }}\n      ></div>\n      <h2\n        style={{\n          color: \"white\",\n          fontWeight: \"bold\",\n          fontSize: \"1.2rem\",\n        }}\n      >\n        {selected ? \"Change provider\" : \"\"}\n      </h2>\n      <p style={{ color: \"white\", fontSize: \"1rem\"}}>\n        {selected\n          ? \"Choose from the following options:\"\n          : \"Please sign into your wallet\"}\n      </p>\n\n      <br />\n      {wallets.map((wallet) => {\n        return (\n          <Button\n            key={wallet.name}\n            size=\"large\"\n            type={wallet === selected ? \"primary\" : \"ghost\"}\n            onClick={() => {\n              select(wallet.name);\n              close();\n            }}\n            icon={\n              <img\n                alt={`${wallet.name}`}\n                width={20}\n                height={20}\n                src={wallet.icon}\n                style={{ marginRight: 30, float: \"left\" }}\n              />\n            }\n            style={{\n              display: \"block\",\n              width: \"100%\",\n              textAlign: \"left\",\n              marginBottom: 8,\n              color: \"white\",\n            }}\n          >\n            {wallet.name}\n          </Button>\n        );\n      })}\n    </DefaultModal>\n  );\n};\n\nexport const WalletModalProvider: FC<{ children: ReactNode }> = ({\n  children,\n}) => {\n  const { publicKey } = useWallet();\n  const [connected, setConnected] = useState(!!publicKey);\n  const [visible, setVisible] = useState(false);\n\n  useEffect(() => {\n    if (publicKey) {\n      const base58 = publicKey.toBase58();\n      const keyToDisplay =\n        base58.length > 20\n          ? `${base58.substring(0, 7)}.....${base58.substring(\n              base58.length - 7,\n              base58.length\n            )}`\n          : base58;\n\n      notify({\n        message: \"Wallet update\",\n        description: \"Connected to wallet \" + keyToDisplay,\n      });\n    }\n  }, [publicKey]);\n\n  useEffect(() => {\n    if (!publicKey && connected) {\n      notify({\n        message: \"Wallet update\",\n        description: \"Disconnected from wallet\",\n      });\n    }\n    setConnected(!!publicKey);\n  }, [publicKey, connected, setConnected]);\n\n  return (\n    <WalletModalContext.Provider\n      value={{\n        visible,\n        setVisible,\n      }}\n    >\n      {children}\n      <WalletModal />\n    </WalletModalContext.Provider>\n  );\n};\n\nexport const WalletProvider: FC<{ children: ReactNode }> = ({ children }) => {\n  const wallets = useMemo(\n    () => [\n      getPhantomWallet(),\n      getSolflareWallet(),\n      getTorusWallet({\n        options: {\n          clientId:\n            \"BEB_D44HovHuXH0Ace97QVqSu1ahCKndjpGhzhVcMy_9XmDTbHyqTbzQTufcyaN0kFwtlVbfPzJwpJXg94gWJqE\",\n          uxMode: \"redirect\",\n        },\n      }),\n      getLedgerWallet(),\n      getSolongWallet(),\n      getMathWallet(),\n      getSolletWallet(),\n    ],\n    []\n  );\n\n  const onError = useCallback((error: WalletError) => {\n    console.error(error);\n    notify({\n      message: \"Wallet error\",\n      description: error.message,\n    });\n  }, []);\n\n  return (\n    <BaseWalletProvider wallets={wallets} onError={onError} autoConnect>\n      <WalletModalProvider>{children}</WalletModalProvider>\n    </BaseWalletProvider>\n  );\n};\n\nexport type WalletSigner = Pick<\n  WalletAdapter,\n  \"publicKey\" | \"signTransaction\" | \"signAllTransactions\"\n>;\n","export default __webpack_public_path__ + \"static/media/wallet.c746d144.less\";","import React, { useState, useContext, useCallback } from 'react';\n\nimport { WalletModal } from './WalletContext/WalletContext';\n\nexport enum ModalEnum {\n  WALLET = 'wallet',\n}\n\ntype ModalContextProps = {\n  setModal: (modal: ModalEnum | undefined) => void;\n  removeModal: () => void;\n};\n\nexport const ModalContext = React.createContext<ModalContextProps>({\n  setModal: () => null,\n  removeModal: () => null,\n});\n\nexport const ModalProvider: React.FC = ({ children }) => {\n  const [modal, setModal] = useState<ModalEnum | undefined>(undefined);\n\n  const removeModal = useCallback(() => {\n    setModal(undefined);\n  }, [setModal]);\n\n  return (\n    <ModalContext.Provider\n      value={{\n        setModal,\n        removeModal,\n      }}\n    >\n      {children}\n      {modal === ModalEnum.WALLET && <WalletModal />}\n    </ModalContext.Provider>\n  );\n};\n\nexport const useModal = (): ModalContextProps => {\n  const context = useContext(ModalContext);\n  if (context === undefined) {\n    throw new Error('useModal must be used within a ModalProvider');\n  }\n  return context;\n};\n","import React from \"react\";\nimport {\n  Link,\n} from \"react-router-dom\";\nimport {\n  Box,\n  Button,\n  Divider,\n  Drawer,\n  List,\n  ListItem,\n  ListItemButton,\n  ListItemText,\n  Stack,\n} from \"@mui/material\";\nimport HomeIcon from '@mui/icons-material/Home';\nimport MenuIcon from '@mui/icons-material/Menu';\n\nimport { Settings } from \"../Settings\";\n\nexport const Header = ({ narrow }) => {\n  const navs = [\n    {\n      href: `/gumdrop/`,\n      innerNarrow: \"About\",\n      inner: <HomeIcon />,\n    },\n    {\n      href: `/gumdrop/create`,\n      inner: \"Create\",\n    },\n    {\n      href: `/gumdrop/claim`,\n      inner: \"Claim\",\n    },\n    {\n      href: `/gumdrop/close`,\n      inner: \"Close\",\n    },\n  ];\n\n  const [drawerOpen, setDrawerOpen] = React.useState(false);\n\n  const toggleDrawer = (open) => (event) => {\n    if (event.type === 'keydown' && (event.key === 'Tab' || event.key === 'Shift')) {\n      return;\n    }\n\n    setDrawerOpen(open);\n  };\n\n  return (\n    <Box\n      sx={{\n        height: \"52px\",\n        display: \"flex\",\n        bgcolor: \"action.disabledBackground\",\n        overflow: \"auto\",\n      }}\n    >\n      {narrow\n        ? (\n          <React.Fragment>\n            <Button onClick={toggleDrawer(true)}>\n              <MenuIcon />\n            </Button>\n            <Drawer\n              open={drawerOpen}\n              onClose={toggleDrawer(false)}\n            >\n              <Box\n                sx={{ width: 250 }}\n                role=\"presentation\"\n                onClick={toggleDrawer(false)}\n                onKeyDown={toggleDrawer(false)}\n              >\n                <List>\n                  <ListItem>\n                    <ListItemText\n                      primary=\"Gumdrop\"\n                      primaryTypographyProps={{\n                        fontSize: \"1.2rem\",\n                        fontWeight: 'medium',\n                        letterSpacing: 0,\n                      }}\n                    />\n                  </ListItem>\n                  <Divider />\n                  {navs.map((nav, idx) => {\n                    return (\n                      <Link to={nav.href} key={idx} style={{color: \"inherit\"}}>\n                        <ListItemButton>\n                          {nav.innerNarrow || nav.inner}\n                        </ListItemButton>\n                      </Link>\n                    );\n                  })}\n                </List>\n              </Box>\n            </Drawer>\n          </React.Fragment>\n        )\n        : (\n          <Stack\n            direction=\"row\"\n            spacing={2}\n            sx={{\n              display: \"flex\",\n              justifyContent: \"flex-start\",\n              alignItems: \"center\",\n              marginLeft: \"36px\",\n            }}\n          >\n            {navs.map((nav, idx) => {\n              return (\n                <Link to={nav.href} key={idx}>\n                  <Button variant=\"outlined\" style={{minWidth:0}}>\n                    {nav.inner}\n                  </Button>\n                </Link>\n              );\n            })}\n          </Stack>\n        )\n      }\n      <Box sx={{flexGrow: 1, minWidth: \"36px\"}}></Box>\n      <Settings narrow={narrow}/>\n    </Box>\n  );\n};\n","import React from \"react\";\n\nimport {\n  Box,\n  Button,\n  CircularProgress,\n  FormControl,\n  InputLabel,\n  Link as HyperLink,\n  MenuItem,\n  Stack,\n  Select,\n  TextField,\n} from \"@mui/material\";\n\nimport {\n  useWallet,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  Keypair,\n} from \"@solana/web3.js\";\n\nimport {\n  useConnection,\n  Connection,\n} from \"../contexts\";\nimport {\n  notify,\n} from \"../utils\";\nimport {\n  closeGumdrop,\n} from \"../utils/claimant\";\nimport {\n  explorerLinkFor,\n} from \"../utils/transactions\";\n\nexport const Close = () => {\n  const connection = useConnection();\n  const wallet = useWallet();\n\n  const [baseKey, setBaseKey] = React.useState(\"\");\n  const [claimMethod, setClaimMethod] = React.useState(localStorage.getItem(\"claimMethod\") || \"transfer\");\n  const [candyConfig, setCandyConfig] = React.useState(localStorage.getItem(\"candyConfig\") || \"\");\n  const [candyUUID, setCandyUUID] = React.useState(localStorage.getItem(\"candyUUID\") || \"\");\n  const [masterMint, setMasterMint] = React.useState(localStorage.getItem(\"masterMint\") || \"\");\n\n  const submit = async (e : React.SyntheticEvent) => {\n    e.preventDefault();\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const base = Keypair.fromSecretKey(\n      new Uint8Array(JSON.parse(baseKey)));\n\n    const instructions = await closeGumdrop(\n      connection,\n      wallet.publicKey,\n      base,\n      claimMethod,\n      candyConfig,\n      candyUUID,\n      masterMint,\n    );\n\n    const closeResult = await Connection.sendTransactionWithRetry(\n      connection,\n      wallet,\n      instructions,\n      [base]\n    );\n\n    console.log(closeResult);\n    if (typeof closeResult === \"string\") {\n      notify({\n        message: \"Close failed\",\n        description: closeResult,\n      });\n    } else {\n      notify({\n        message: \"Close succeeded\",\n        description: (\n          <HyperLink href={explorerLinkFor(closeResult.txid, connection)}>\n            View transaction on explorer\n          </HyperLink>\n        ),\n      });\n    }\n  };\n\n  const claimData = (claimMethod) => {\n    if (claimMethod === \"candy\") {\n      return (\n        <React.Fragment>\n          <TextField\n            id=\"config-text-field\"\n            label=\"Candy Config\"\n            value={candyConfig}\n            onChange={e => setCandyConfig(e.target.value)}\n          />\n          <TextField\n            id=\"config-uuid-text-field\"\n            label=\"Candy UUID\"\n            value={candyUUID}\n            onChange={e => setCandyUUID(e.target.value)}\n          />\n        </React.Fragment>\n      );\n    } else if (claimMethod === \"transfer\") {\n      return null;\n    } else if (claimMethod === \"edition\") {\n      return (\n        <React.Fragment>\n          <TextField\n            id=\"master-mint-text-field\"\n            label=\"Master Mint\"\n            value={masterMint}\n            onChange={(e) => setMasterMint(e.target.value)}\n          />\n        </React.Fragment>\n      );\n    }\n  };\n\n  const [loading, setLoading] = React.useState(false);\n  const loadingProgress = () => (\n    <CircularProgress\n      size={24}\n      sx={{\n        position: 'absolute',\n        top: '50%',\n        left: '50%',\n        marginTop: '-12px',\n        marginLeft: '-12px',\n      }}\n    />\n  );\n  return (\n    <Stack spacing={2}>\n      <TextField\n        id=\"base-text-field\"\n        label=\"Base Private Key\"\n        value={baseKey}\n        onChange={(e) => setBaseKey(e.target.value)}\n      />\n      <FormControl fullWidth>\n        <InputLabel id=\"claim-method-label\">Claim Method</InputLabel>\n        <Select\n          labelId=\"claim-method-label\"\n          id=\"claim-method-select\"\n          value={claimMethod}\n          label=\"Claim Method\"\n          onChange={(e) => {\n            localStorage.setItem(\"claimMethod\", e.target.value);\n            setClaimMethod(e.target.value);\n          }}\n          style={{textAlign: \"left\"}}\n        >\n          <MenuItem value={\"transfer\"}>Token Transfer</MenuItem>\n          <MenuItem value={\"candy\"}>Candy Machine</MenuItem>\n          <MenuItem value={\"edition\"}>Limited Edition</MenuItem>\n        </Select>\n      </FormControl>\n      {claimMethod !== \"\" && claimData(claimMethod)}\n      <Box sx={{ position: \"relative\" }}>\n      <Button\n        disabled={!wallet.connected || !baseKey || loading}\n        variant=\"contained\"\n        style={{ width: \"100%\" }}\n        onClick={(e) => {\n          setLoading(true);\n          const wrap = async () => {\n            try {\n              await submit(e);\n              setLoading(false);\n            } catch (err) {\n              notify({\n                message: \"Close failed\",\n                description: `${err}`,\n              });\n              setLoading(false);\n            }\n          };\n          wrap();\n        }}\n      >\n        Close Gumdrop\n      </Button>\n      {loading && loadingProgress()}\n      </Box>\n    </Stack>\n  );\n};\n","import log from 'loglevel';\nimport { SESv2Client, SendEmailCommand } from \"@aws-sdk/client-sesv2\"\nimport { SNSClient, PublishCommand } from \"@aws-sdk/client-sns\";\n\nimport {\n  ClaimantInfo,\n  Claimants,\n} from \"./claimant\"\n\nexport type AuthKeys = { [key: string] : string }\nexport type Response = { [key: string] : any }\n\nexport type DropInfo = {\n  type : string,\n  meta : string,\n};\n\nexport const formatDropMessage = (\n  info : ClaimantInfo,\n  drop : DropInfo,\n  html : boolean,\n) => {\n  const wrap = (url, text) => {\n    if (html) {\n      return `<a href=\"${url}\">${text}</a>`;\n    } else {\n      return `${text} ${url}`;\n    }\n  }\n  if (drop.type === \"Token\") {\n    return {\n      subject: \"Gumdrop Token Drop\",\n      message: `You received ${info.amount} token(s) `\n             + `(click ${wrap(drop.meta, \"here\")} to view more information about the token mint). `\n             +  wrap(info.url, \"Click here to claim them!\"),\n    };\n  } else if (drop.type === \"Candy\") {\n    return {\n      subject: \"Gumdrop NFT Drop\",\n      message: `You received ${info.amount} Candy Machine pre-sale mint(s) `\n             + `(click ${wrap(drop.meta, \"here\")} to view the candy machine configuration on explorer). `\n             +  wrap(info.url, \"Click here to claim them!\"),\n    };\n  } else if (drop.type === \"Edition\") {\n    return {\n      subject: \"Gumdrop NFT Drop\",\n      message: `You received ${info.amount} limited-edition print(s) `\n             + `(click ${wrap(drop.meta, \"here\")} to view the master edition mint on explorer). `\n             +  wrap(info.url, \"Click here to claim them!\"),\n    };\n  } else {\n    throw new Error(`Internal Error: Unknown drop type ${drop.type}`);\n  }\n};\n\nexport const distributeAwsSns = async (\n  auth : AuthKeys,\n  source : string,\n  claimants : Claimants,\n  drop : DropInfo,\n) => {\n  if (!auth.accessKeyId || !auth.secretAccessKey) {\n    throw new Error(\"AWS SES auth keys not supplied\");\n  }\n  if (claimants.length === 0) return [];\n\n  log.debug(\"SES auth\", auth);\n  const client = new SNSClient({\n    region: \"us-east-2\",\n    credentials: {\n      accessKeyId: auth.accessKeyId,\n      secretAccessKey: auth.secretAccessKey,\n    },\n  });\n\n  const single = async (\n    info : ClaimantInfo,\n    drop : DropInfo,\n  ) => {\n    const formatted = formatDropMessage(info, drop, true);\n    const message = {\n      Message: formatted.message,\n      PhoneNumber: info.handle,\n    };\n\n    try {\n      const response = await client.send(new PublishCommand(message));\n      return {\n        status: \"success\",\n        handle: info.handle,\n        messageId: response.MessageId,\n      };\n    } catch (err) {\n      return {\n        status: \"error\",\n        handle: info.handle,\n        error: err,\n      };\n    }\n  };\n\n  const responses = Array<Response>();\n  for (const c of claimants) {\n    responses.push(await single(c, drop));\n  }\n  return responses;\n}\n\nexport const distributeAwsSes = async (\n  auth : AuthKeys,\n  source : string,\n  claimants : Claimants,\n  drop : DropInfo,\n) => {\n  if (!auth.accessKeyId || !auth.secretAccessKey) {\n    throw new Error(\"AWS SES auth keys not supplied\");\n  }\n  if (claimants.length === 0) return [];\n\n  log.debug(\"SES auth\", auth);\n  const client = new SESv2Client({\n    region: \"us-east-2\",\n    credentials: {\n      accessKeyId: auth.accessKeyId,\n      secretAccessKey: auth.secretAccessKey,\n    },\n  });\n\n  // TODO: move to template + bulk message?\n  const single = async (\n    info : ClaimantInfo,\n    drop : DropInfo,\n  ) => {\n    const formatted = formatDropMessage(info, drop, true);\n    const message = {\n      Destination: {\n        ToAddresses: [\n          info.handle,\n        ]\n      },\n      Content: {\n        Simple: {\n          Subject: {\n            Data: formatted.subject,\n            Charset: \"utf-8\",\n          },\n          Body: {\n            Html: {\n              Data: formatted.message\n                + \"<br><br>\"\n                + \"<div>\"\n                +   \"If you would like to unsubscribe from new Gumdrops, \"\n                +   \"change your subscription preferences here: \"\n                +   \"<a href='{{amazonSESUnsubscribeUrl}}'>AWS subscription preferences</a>\"\n                + \"</div>\",\n              Charset: \"utf-8\",\n            },\n          },\n        },\n      },\n      FromEmailAddress: source,\n      ListManagementOptions: {\n        ContactListName: \"Gumdrop\",\n        TopicName: drop.type,\n      },\n    };\n\n    try {\n      const response = await client.send(new SendEmailCommand(message));\n      return {\n        status: \"success\",\n        handle: info.handle,\n        messageId: response.MessageId,\n      };\n    } catch (err) {\n      return {\n        status: \"error\",\n        handle: info.handle,\n        error: err,\n      };\n    }\n  };\n\n  const responses = Array<Response>();\n  for (const c of claimants) {\n    responses.push(await single(c, drop));\n  }\n  return responses;\n}\n\nexport const distributeManual = async (\n  auth : AuthKeys,\n  source : string,\n  claimants : Claimants,\n  drop : DropInfo,\n) => {\n  return Array<Response>();\n}\n\nexport const distributeWallet = async (\n  auth : AuthKeys,\n  source : string,\n  claimants : Claimants,\n  drop : DropInfo,\n) => {\n  return Array<Response>();\n}\n\nexport const urlAndHandleFor = (claimants : Array<ClaimantInfo>) => {\n  return claimants.map(info => {\n    return {\n      handle: info.handle,\n      amount: info.amount,\n      url: info.url,\n    };\n  });\n}\n","import React from \"react\"\nimport {\n  useColorMode,\n} from \"../contexts/ColorModeContext\";\n\nexport const DragAndDrop = (props) => {\n  const dropRef = React.useRef<HTMLDivElement>(null);\n  const [dragCounter, setDragCounter] = React.useState(0);\n  const [dragging, setDragging] = React.useState(false);\n\n  const handleDrag = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n  };\n\n  const handleDragIn = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    setDragCounter(dragCounter + 1);\n    if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {\n      setDragging(true);\n    }\n  };\n\n  const handleDragOut = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    const remainingDrags = dragCounter - 1;\n    setDragCounter(remainingDrags);\n    if (remainingDrags === 0) {\n      setDragging(false);\n    }\n  };\n\n  const handleDrop = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    setDragging(false);\n    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\n      props.handleDrop(e.dataTransfer.files);\n      e.dataTransfer.clearData();\n      setDragCounter(0);\n    }\n  };\n\n  React.useEffect(() => {\n    const node = dropRef.current;\n    if (node === null) return;\n    node.addEventListener(\"dragenter\" , handleDragIn);\n    node.addEventListener(\"dragleave\" , handleDragOut);\n    node.addEventListener(\"dragover\"  , handleDrag);\n    node.addEventListener(\"drop\"      , handleDrop);\n\n    return () => {\n      node.removeEventListener(\"dragenter\" , handleDragIn);\n      node.removeEventListener(\"dragleave\" , handleDragOut);\n      node.removeEventListener(\"dragover\"  , handleDrag);\n      node.removeEventListener(\"drop\"      , handleDrop);\n    };\n  });\n\n  const colorModeCtx = useColorMode();\n  const shade = colorModeCtx.mode === 'dark' ? \"rgba(255,255,255,.1)\" : \"rgba(0, 0, 0,.1)\";\n\n  return (\n    <div\n      ref={dropRef}\n      style={dragging ? { backgroundColor: shade} : {}}\n    >\n      {props.children}\n    </div>\n  );\n};\n\n\nexport default DragAndDrop;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport {\n  Box,\n  Button,\n  CircularProgress,\n  FormControl,\n  Link as HyperLink,\n  InputLabel,\n  MenuItem,\n  Stack,\n  Select,\n  Table,\n  TableBody,\n  TableCell,\n  TableContainer,\n  TableHead,\n  TableRow,\n  TextField,\n} from \"@mui/material\";\nimport FilePresentIcon from '@mui/icons-material/FilePresent';\n\nimport {\n  useWallet,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  Keypair,\n  PublicKey,\n} from \"@solana/web3.js\";\nimport {\n  MintInfo,\n} from \"@solana/spl-token\";\nimport BN from 'bn.js';\n\nimport {\n  useConnection,\n  Connection,\n} from \"../contexts\";\nimport {\n  GUMDROP_DISTRIBUTOR_ID,\n  GUMDROP_TEMPORAL_SIGNER,\n  notify,\n  shortenAddress,\n} from \"../utils\";\nimport {\n  ClaimantInfo,\n  Claimants,\n  buildGumdrop,\n  dropInfoFor,\n  parseClaimants,\n  validateTransferClaims,\n  validateCandyClaims,\n  validateEditionClaims,\n} from \"../utils/claimant\";\nimport {\n  AuthKeys,\n  DropInfo,\n  Response as DResponse,\n  distributeAwsSes,\n  distributeManual,\n  distributeWallet,\n  urlAndHandleFor,\n} from \"../utils/communication\";\nimport {\n  envFor,\n  explorerLinkFor,\n} from \"../utils/transactions\";\nimport { DragAndDrop } from \"./DragAndDrop\";\nimport { DefaultModal } from \"./DefaultModal\";\n\n// NB: assumes no overflow\nconst randomBytes = () : Uint8Array => {\n  // TODO: some predictable seed? sha256?\n  const buf = new Uint8Array(4);\n  window.crypto.getRandomValues(buf);\n  return buf;\n}\n\nconst WHITESPACE = \"\\u00A0\";\n\nconst distribute = (\n  method : string,\n  auth : AuthKeys,\n  source : string,\n  claimants : Claimants,\n  drop : DropInfo,\n) => {\n  if (method === \"AWS SES\") {\n    return distributeAwsSes(auth, source, claimants, drop);\n  } else if (method === \"Manual\") {\n    return distributeManual(auth, source, claimants, drop);\n  } else if (method === \"Wallets\") {\n    return distributeWallet(auth, source, claimants, drop);\n  } else {\n    throw new Error(`Unrecognized claim distribution method ${method}`);\n  }\n}\n\nconst reactModal = (renderModal) => {\n  const container = document.createElement('div');\n  document.body.appendChild(container);\n\n  const displayModal = ({ onSubmit, onDismiss }) => {\n    ReactDOM.render(renderModal({ onSubmit, onDismiss, show: true }), container);\n  };\n\n  const hideModal = ({ onSubmit, onDismiss }, callback) => {\n    ReactDOM.render(renderModal({ onSubmit, onDismiss, show: false }), container, callback);\n  };\n\n  const destroyModal = () => {\n    ReactDOM.unmountComponentAtNode(container);\n    document.body.removeChild(container);\n  };\n\n  const confirmation = new Promise((resolve) => {\n    const onSubmit = (value) => resolve(value);\n    const onDismiss = () => resolve(undefined);\n    displayModal({ onSubmit, onDismiss });\n  });\n\n  return confirmation.finally(() => {\n    const onSubmit = () => {};\n    const onDismiss = () => {};\n    hideModal({ onSubmit, onDismiss }, destroyModal);\n  });\n};\n\nconst resendOnlyRender = ({ show, onSubmit, onDismiss }) => {\n  const options = [\n    { click: () => onSubmit(\"create\"), name: \"Create and Send\" },\n    { click: () => onSubmit(\"send\")  , name: \"Send only\"       },\n  ];\n  return (\n    <DefaultModal visible={show} onCancel={onDismiss} width=\"70ch\">\n      <p style={{\n        color: \"white\",\n        fontSize: \"0.9rem\",\n        marginTop: 8,\n        width: \"90%\",\n      }}>\n        Uploaded distribution list has URLs for all claimants.\n        Skip creation of airdrop and only re-send links?\n      </p>\n      <br />\n      <Stack direction=\"row\" spacing={2} style={{width: \"100%\"}}>\n      {options.map((opt) => {\n        return (\n          <Button\n            key={opt.name}\n            style={{\n              width: \"100%\",\n              color: \"white\",\n              marginBottom: 8,\n            }}\n            variant=\"outlined\"\n            onClick={opt.click}\n          >\n            {opt.name}\n          </Button>\n        );\n      })}\n      </Stack>\n    </DefaultModal>\n  );\n};\n\nconst displayMintTokens = (amount : number, mintInfo : MintInfo) : string => {\n  // TODO: better decimal rounding\n  return String(amount / Math.pow(10, mintInfo.decimals));\n};\n\nconst hyperLinkData = (data) => {\n  const encoded = encodeURIComponent(JSON.stringify(data));\n  return `data:text/plain;charset=utf-8,${encoded}`;\n};\n\nconst shouldSendRender = (claimants, needsPin, claimMethod, claimInfo, baseKey) => {\n  const limit = 1000;\n  return ({ show, onSubmit, onDismiss }) => {\n    return (\n      <DefaultModal visible={show} onCancel={onDismiss} width=\"70ch\">\n        <h2\n          style={{\n            color: \"white\",\n            fontWeight: \"bold\",\n            fontSize: \"1.2rem\",\n          }}\n        >\n          Claim Distribution Preview{claimants.length > limit ? ` (First ${limit})` : \"\"}\n        </h2>\n        <p style={{ color: \"white\", fontSize: \"1rem\", textAlign: \"center\" }}>\n          Approving will save the keypair authority generated for gumdrop\n          state. This keypair is necessary to close the gumdrop later!\n        </p>\n        <TableContainer\n          sx={{\n            \"td, th\": { color: \"white\" },\n            backgroundColor: \"#444444\",\n            borderRadius: \"5px\",\n            maxHeight: \"30ch\",\n          }}\n        >\n          <Table size=\"small\">\n            <TableHead>\n              <TableRow>\n                <TableCell>Handle</TableCell>\n                <TableCell>\n                  {claimMethod === \"edition\"\n                    ? \"Edition\"\n                    : \"Tokens\"\n                  }\n                </TableCell>\n                {needsPin && <TableCell>Pin</TableCell>}\n              </TableRow>\n            </TableHead>\n            <TableBody>\n              {claimants.slice(0, limit).map((c, idx) => (\n                <TableRow\n                  key={idx}\n                  sx={{ 'td, th': { border: 0 } }}\n                >\n                  <TableCell component=\"th\" scope=\"row\">{c.handle} </TableCell>\n                  <TableCell>\n                    { claimMethod === \"transfer\" ? displayMintTokens(c.amount, claimInfo.mint.info)\n                    : claimMethod === \"candy\"    ? c.amount\n                    : /* === \"edition\" */          c.edition\n                    }\n                  </TableCell>\n                  {needsPin && <TableCell>{c.pin.toNumber()}</TableCell>}\n                </TableRow>\n              ))}\n            </TableBody>\n          </Table>\n        </TableContainer>\n        <Box style={{ height: \"3ch\" }} />\n        <Stack direction=\"row\" spacing={2} style={{width: \"100%\"}}>\n          <Button\n            style={{\n              width: \"100%\",\n              color: \"white\",\n              marginBottom: 8,\n            }}\n            variant=\"outlined\"\n            onClick={() => onSubmit(false)}\n          >\n            Cancel\n          </Button>\n          <HyperLink\n            href={hyperLinkData(Array.from(baseKey.secretKey))}\n            download={`${baseKey.publicKey.toBase58()}.json`}\n            underline=\"none\"\n            style={{width: \"100%\"}}\n          >\n            <Button\n              style={{\n                width: \"100%\",\n                color: \"white\",\n                marginBottom: 8,\n              }}\n              variant=\"outlined\"\n              onClick={() => onSubmit(true)}\n            >\n              Approve\n            </Button>\n          </HyperLink>\n        </Stack>\n      </DefaultModal>\n    );\n  }\n};\n\nexport type CreateProps = {};\n\nexport const Create = (\n  props : CreateProps,\n) => {\n  const connection = useConnection();\n  const wallet = useWallet();\n\n  // claim state\n  const [claimMethod, setClaimMethod] = React.useState(localStorage.getItem(\"claimMethod\") || \"\");\n  const [candyConfig, setCandyConfig] = React.useState(localStorage.getItem(\"candyConfig\") || \"\");\n  const [candyUUID, setCandyUUID] = React.useState(localStorage.getItem(\"candyUUID\") || \"\");\n  const [mint, setMint] = React.useState(localStorage.getItem(\"mint\") || \"\");\n  const [masterMint, setMasterMint] = React.useState(localStorage.getItem(\"masterMint\") || \"\");\n  const [filename, setFilename] = React.useState(\"\");\n  const [text, setText] = React.useState(\"\");\n\n  // response state\n  const [claimURLs, setClaimURLs] = React.useState<Array<{ [key: string]: any }>>([]);\n  const [responses, setResponses] = React.useState<Array<DResponse>>([]);\n\n  // auth state\n  const [otpAuth, setOtpAuth] = React.useState(localStorage.getItem(\"otpAuth\") || \"default\");\n  const [commMethod, setCommMethod] = React.useState(localStorage.getItem(\"commMethod\") || \"\");\n  const [commAuth, setCommAuth] = React.useState<AuthKeys>({});\n  const [commSource, setCommSource] = React.useState(localStorage.getItem(\"commSource\") || \"\");\n  const [awsAccessKeyId, setAwsAccessKeyId] = React.useState(\"\");\n  const [awsSecretKey, setAwsSecretKey] = React.useState(\"\");\n\n  const explorerUrlFor = (key : PublicKey) => {\n    return `https://explorer.solana.com/address/${key.toBase58()}?cluster=${envFor(connection)}`;\n  }\n\n  const distributeClaims = async (claimants, drop) => {\n    const responses = await distribute(\n      commMethod, commAuth, commSource, claimants, drop);\n\n    console.log(\"Responses\", responses);\n    setResponses(responses);\n\n    // notify if the above routine is actually supposed to do anything\n    // (manual and wallet do nothing atm)\n    if (commMethod === \"AWS SES\") {\n      notify({\n        message: \"Gumdrop email distribution completed\",\n      });\n    }\n  }\n\n  const submit = async (e : React.SyntheticEvent) => {\n    e.preventDefault();\n\n    setClaimURLs([]);\n    setResponses([]);\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const claimants = parseClaimants(text, filename, commMethod);\n    if (claimants.length === 0) {\n      throw new Error(`No claimants provided`);\n    }\n\n    const dropInfo = dropInfoFor(envFor(connection), claimMethod, mint, candyConfig, masterMint);\n    // check that auth is correct...\n    await distribute(\n      commMethod, commAuth, commSource, [], dropInfo);\n\n    const mightHaveExisting = (info : ClaimantInfo) => {\n      return info.url !== undefined && info.url !== null;\n    };\n    if (claimants.reduce((acc, c) => acc && mightHaveExisting(c), true)) {\n      const resendOnly = await reactModal(resendOnlyRender);\n      console.log(\"Resend only\", resendOnly);\n      if (resendOnly === \"send\") {\n        setClaimURLs(urlAndHandleFor(claimants));\n        await distributeClaims(claimants, dropInfo);\n        return;\n      } else if (resendOnly === \"create\") {\n        // fallthrough to full create\n      } else {\n        // dismissed. don't use exceptions for control flow?\n        throw new Error(\"Dismissed\");\n      }\n    }\n\n\n    let claimInfo;\n    switch (claimMethod) {\n      case \"transfer\": {\n        claimInfo = await validateTransferClaims(\n          connection,\n          wallet.publicKey,\n          claimants,\n          mint,\n        );\n        break;\n      }\n      case \"candy\": {\n        claimInfo = await validateCandyClaims(\n          connection,\n          wallet.publicKey,\n          claimants,\n          candyConfig,\n          candyUUID,\n        );\n        break;\n      }\n      case \"edition\": {\n        claimInfo = await validateEditionClaims(\n          connection,\n          wallet.publicKey,\n          claimants,\n          masterMint,\n        );\n        break;\n      }\n      default:\n        throw new Error(`Unknown claim method ${claimMethod}`);\n    }\n    console.log(\"Claims info\", claimInfo);\n\n    claimants.forEach(c => {\n      c.pin = new BN(randomBytes());\n      c.seed = claimMethod === \"transfer\" ? claimInfo.mint.key\n             : claimMethod === \"candy\"    ? claimInfo.config\n             : /* === edition */            claimInfo.masterMint.key;\n    });\n\n    // temporal auth is the AWS signer by 'default' and a no-op key otherwise\n    let temporalSigner;\n    if (commMethod === \"Wallets\") {\n      // TODO: this is a bit jank. There should be no form option to set the\n      // OTP auth if we are using a wallet but there's still a defaulted value\n      // atm...\n      // NB: We also need this to not be 'none' since there is a special check\n      // for claimant_secret==accounts.temporal\n      temporalSigner = GUMDROP_DISTRIBUTOR_ID;\n    } else if (otpAuth === \"default\") {\n      temporalSigner = GUMDROP_TEMPORAL_SIGNER;\n    } else if (otpAuth === \"none\") {\n      temporalSigner = PublicKey.default;\n    } else {\n      throw new Error(`Unknown OTP authorization type ${otpAuth}`);\n    }\n\n    console.log(`Temporal signer: ${temporalSigner.toBase58()}`);\n\n    const base = Keypair.generate();\n    console.log(`Base ${base.publicKey.toBase58()}`);\n\n    const needsPin = commMethod !== \"Wallets\";\n    const instructions = await buildGumdrop(\n      connection,\n      wallet.publicKey,\n      needsPin,\n      claimMethod,\n      `${window.location.origin}/gumdrop`,\n      base.publicKey,\n      temporalSigner,\n      claimants,\n      claimInfo\n    );\n\n    const shouldSend = await reactModal(\n      shouldSendRender(claimants, needsPin, claimMethod, claimInfo, base)\n    ) as boolean | undefined;\n    if (shouldSend === true) {\n    } else {\n      // dismissed. don't use exceptions for control flow?\n      throw new Error(\"Claim distribution preview not approved\");\n    }\n\n\n    setClaimURLs(urlAndHandleFor(claimants));\n\n    const createResult = await Connection.sendTransactionWithRetry(\n      connection,\n      wallet,\n      instructions,\n      [base]\n    );\n\n    console.log(createResult);\n    if (typeof createResult === \"string\") {\n      throw new Error(createResult);\n    } else {\n      notify({\n        message: \"Gumdrop creation succeeded\",\n        description: (\n          <HyperLink href={explorerLinkFor(createResult.txid, connection)}>\n            View transaction on explorer\n          </HyperLink>\n        ),\n      });\n    }\n\n    console.log(\"Distributing claim URLs\");\n    await distributeClaims(claimants, dropInfo);\n  };\n\n  const handleFiles = (files) => {\n    if (files.length !== 1) {\n      notify({\n        message: \"File upload failed\",\n        description: `Received ${files.length} files`,\n      });\n      return;\n    }\n\n    const file = files[0];\n    const reader = new FileReader();\n    reader.onload = (e) => {\n      if (e !== null && e.target !== null) {\n        if (typeof e.target.result === \"string\") {\n          try {\n            parseClaimants(e.target.result, file.name, commMethod);\n          } catch {\n            notify({\n              message: `File upload failed for: ${file.name}`,\n              description: (\n                <span>\n                  Could not parse uploaded file.{WHITESPACE}\n                  <HyperLink href=\"#/\">\n                    Does it follow the JSON scheme?\n                  </HyperLink>\n                </span>\n              ),\n            });\n            setFilename(\"\");\n            setText(\"\");\n            return;\n          }\n          setFilename(file.name);\n          setText(e.target.result);\n        } else {\n          notify({\n            message: `File upload failed for: ${file.name}`,\n            description: \"Could not read uploaded file\",\n          });\n        }\n      }\n    };\n    reader.readAsText(file);\n  };\n\n  const claimData = (claimMethod) => {\n    if (claimMethod === \"candy\") {\n      return (\n        <React.Fragment>\n          <TextField\n            id=\"config-text-field\"\n            label=\"Candy Config\"\n            value={candyConfig}\n            onChange={e => {\n              setCandyConfig(e.target.value);\n              localStorage.setItem(\"candyConfig\", e.target.value);\n            }}\n          />\n          <TextField\n            id=\"config-uuid-text-field\"\n            label=\"Candy UUID\"\n            value={candyUUID}\n            onChange={e => {\n              setCandyUUID(e.target.value);\n              localStorage.setItem(\"candyUUID\", e.target.value);\n            }}\n          />\n        </React.Fragment>\n      );\n    } else if (claimMethod === \"transfer\") {\n      return (\n        <TextField\n          id=\"mint-text-field\"\n          label=\"Mint\"\n          value={mint}\n          onChange={(e) => {\n            localStorage.setItem(\"mint\", e.target.value);\n            setMint(e.target.value);\n          }}\n        />\n      );\n    } else if (claimMethod === \"edition\") {\n      // transfers master mint token from this account to the distributor\n      // wallet ATA\n      return (\n        <TextField\n          id=\"master-mint-text-field\"\n          label=\"Master Mint\"\n          value={masterMint}\n          onChange={(e) => {\n            localStorage.setItem(\"masterMint\", e.target.value);\n            setMasterMint(e.target.value);\n          }}\n        />\n      );\n    }\n  };\n\n  const commAuthorization = (commMethod) => {\n    if (commMethod === \"AWS SES\") {\n      return (\n        <React.Fragment>\n          <TextField\n            id=\"comm-access-key-id-field\"\n            label={`${commMethod} Access Key Id`}\n            value={awsAccessKeyId}\n            onChange={(e) => {\n              setCommAuth(prev => ({...prev, accessKeyId: e.target.value}));\n              setAwsAccessKeyId(e.target.value)\n            }}\n          />\n          <TextField\n            id=\"comm-secret-access-key-field\"\n            label={`${commMethod} Secret Access Key`}\n            value={awsSecretKey}\n            onChange={(e) => {\n              setCommAuth(prev => ({...prev, secretAccessKey: e.target.value}));\n              setAwsSecretKey(e.target.value)\n            }}\n          />\n          <TextField\n            id=\"comm-source-field\"\n            label={`${commMethod} Source`}\n            value={commSource}\n            onChange={(e) => {\n              localStorage.setItem(\"commSource\", e.target.value);\n              setCommSource(e.target.value)\n            }}\n          />\n        </React.Fragment>\n      );\n    }\n\n    // commMethod === \"Manual\" || commMethod === \"Wallets\"\n    return null;\n  };\n\n  const fileUpload = (\n    <React.Fragment>\n      <DragAndDrop handleDrop={handleFiles} >\n        <Stack\n          direction=\"row\"\n          style={{\n            height: \"15ch\",\n          }}\n          sx={{\n            border: '1px dashed grey',\n            justifyContent: \"center\",\n            alignContent: \"center\",\n          }}\n        >\n          <Button\n            variant=\"text\"\n            component=\"label\"\n            style={{\n              padding: 0,\n              // don't make the button click field too large...\n              marginTop: \"5ch\",\n              marginBottom: \"5ch\",\n            }}\n          >\n            Upload a {filename === \"\" ? \"distribution\" : \"different\"} list\n            <input\n              type=\"file\"\n              onChange={(e) => {\n                handleFiles(e.target.files);\n                // re-parse every time...\n                e.target.value = '';\n              }}\n              hidden\n            />\n          </Button>\n          {WHITESPACE}\n          {/*For display alignment...*/}\n          <Button\n            variant=\"text\"\n            component=\"label\"\n            disabled={true}\n            style={{\n              padding: 0,\n              color: \"#eee\",\n            }}\n          >\n            or drag it here\n          </Button>\n        </Stack>\n      </DragAndDrop>\n      {filename !== \"\"\n      ? (<Button\n            variant=\"text\"\n            component=\"label\"\n            disabled={true}\n            style={{\n              padding: 0,\n              color: \"#eee\",\n            }}\n          >\n            <FilePresentIcon />\n            <span>{WHITESPACE} Uploaded {filename}</span>\n          </Button>\n        )\n      : (<Box/>)}\n    </React.Fragment>\n  );\n\n  const [loading, setLoading] = React.useState(false);\n  const loadingProgress = () => (\n    <CircularProgress\n      size={24}\n      sx={{\n        position: 'absolute',\n        top: '50%',\n        left: '50%',\n        marginTop: '-12px',\n        marginLeft: '-12px',\n      }}\n    />\n  );\n  const createAirdrop = (\n    <Box sx={{ position: \"relative\" }}>\n    <Button\n      disabled={!wallet.connected || !commMethod || !filename || loading}\n      variant=\"contained\"\n      style={{ width: \"100%\" }}\n      onClick={(e) => {\n        setLoading(true);\n        const wrap = async () => {\n          try {\n            await submit(e);\n            setLoading(false);\n          } catch (err) {\n            notify({\n              message: \"Create failed\",\n              description: `${err}`,\n            });\n            setLoading(false);\n          }\n        };\n        wrap();\n      }}\n    >\n      Create{claimURLs.length > 0 ? \" Another \" : \" \"}Gumdrop\n    </Button>\n    {loading && loadingProgress()}\n    </Box>\n  );\n\n  const otpAuthC = (\n    <React.Fragment>\n      <FormControl fullWidth>\n        <InputLabel id=\"otp-auth-label\">OTP Authorization</InputLabel>\n        <Select\n          labelId=\"otp-auth-label\"\n          id=\"otp-auth-select\"\n          value={otpAuth}\n          label=\"OTP Authorization\"\n          onChange={(e) => {\n            localStorage.setItem(\"otpAuth\", e.target.value);\n            setOtpAuth(e.target.value);\n          }}\n          style={{textAlign: \"left\"}}\n        >\n          <MenuItem value={\"default\"}>\n            Default{WHITESPACE}\n            <HyperLink\n              href={explorerUrlFor(GUMDROP_TEMPORAL_SIGNER)}\n              underline=\"none\"\n              target=\"_blank\" rel=\"noopener noreferrer\"\n            >\n              ({shortenAddress(GUMDROP_TEMPORAL_SIGNER.toBase58())})\n            </HyperLink>\n          </MenuItem>\n          <MenuItem value={\"none\"}>None</MenuItem>\n        </Select>\n      </FormControl>\n    </React.Fragment>\n  );\n\n  return (\n    <Stack spacing={2}>\n      <FormControl fullWidth>\n        <InputLabel id=\"claim-method-label\">Claim Method</InputLabel>\n        <Select\n          labelId=\"claim-method-label\"\n          id=\"claim-method-select\"\n          value={claimMethod}\n          label=\"Claim Method\"\n          onChange={(e) => {\n            localStorage.setItem(\"claimMethod\", e.target.value);\n            setClaimMethod(e.target.value);\n          }}\n          style={{textAlign: \"left\"}}\n        >\n          <MenuItem value={\"transfer\"}>Token Transfer</MenuItem>\n          <MenuItem value={\"candy\"}>Candy Machine</MenuItem>\n          <MenuItem value={\"edition\"}>Limited Edition</MenuItem>\n        </Select>\n      </FormControl>\n      {claimMethod !== \"\" && claimData(claimMethod)}\n      <FormControl fullWidth>\n        <InputLabel id=\"comm-method-label\">Distribution Method</InputLabel>\n        <Select\n          labelId=\"comm-method-label\"\n          id=\"comm-method-select\"\n          value={commMethod}\n          label=\"Distribution Method\"\n          onChange={(e) => {\n            if (e.target.value === \"Discord\") {\n              notify({\n                message: \"Discord distribution unavailable\",\n                description: \"Please use the CLI for this. Discord does not support browser-connection requests\",\n              });\n              return;\n            }\n            localStorage.setItem(\"commMethod\", e.target.value);\n            setCommMethod(e.target.value);\n          }}\n          style={{textAlign: \"left\"}}\n        >\n          <MenuItem value={\"AWS SES\"}>AWS SES</MenuItem>\n          <MenuItem value={\"Discord\"}>Discord</MenuItem>\n          <MenuItem value={\"Wallets\"}>Wallets</MenuItem>\n          <MenuItem value={\"Manual\"}>Manual</MenuItem>\n        </Select>\n      </FormControl>\n      {commMethod !== \"\" && commAuthorization(commMethod)}\n      {commMethod !== \"\" && commMethod !== \"Wallets\" && otpAuthC}\n      {commMethod !== \"\" && fileUpload}\n      {createAirdrop}\n      {claimURLs.length > 0 && (\n        <HyperLink\n          href={hyperLinkData(claimURLs)}\n          download=\"claimURLs.json\"\n          underline=\"none\"\n          style={{width: \"100%\"}}\n        >\n          <Button\n            variant=\"contained\"\n            style={{width: \"100%\"}}\n          >\n            Download claim URLs\n          </Button>\n        </HyperLink>\n      )}\n      {responses.length > 0 && (\n        <HyperLink\n          href={hyperLinkData(responses)}\n          download=\"responses.json\"\n          underline=\"none\"\n          style={{width: \"100%\"}}\n        >\n          <Button\n            variant=\"contained\"\n            style={{width: \"100%\"}}\n          >\n            Download distribution responses\n          </Button>\n        </HyperLink>\n      )}\n    </Stack>\n  );\n};\n","import React from \"react\";\nimport {\n  BrowserRouter,\n  Link,\n  Route,\n  Switch,\n} from \"react-router-dom\";\n\nimport { createTheme, ThemeProvider } from \"@mui/material/styles\";\nimport CssBaseline from \"@mui/material/CssBaseline\";\nimport {\n  Box,\n  Link as HyperLink,\n  Stack,\n} from \"@mui/material\";\n\nimport \"./App.css\";\nimport {\n  useColorMode,\n} from \"./contexts\";\nimport { Header } from \"./components/Header/Header\";\nimport { Claim } from \"./components/Claim\";\nimport { Close } from \"./components/Close\";\nimport { Create } from \"./components/Create\";\n\nconst WHITESPACE = \"\\u00A0\";\n\ntype AboutProps = {};\n\nconst About = (\n  props : AboutProps,\n) => {\n  const summary = (\n    <Stack spacing={1}>\n      <div>\n      The Gumdrop program leverages the Solana blockchain and merkle trees to\n      facilitate airdrops to a large number of whitelisted users at a low cost\n      to creators.\n      </div>\n\n      <div>\n      In the Solana ecosystem, the cost of token airdrops is currently largely\n      due to rent costs being{WHITESPACE}\n      <HyperLink\n        href=\"https://docs.solana.com/implemented-proposals/rent\"\n        underline=\"none\"\n      >\n        \"fixed at the genesis\"\n      </HyperLink>\n      . With the large increase in SOLUSD since genesis, rent costs when\n      creating accounts for thousands of users have duly skyrocketed.\n      </div>\n\n      <div>\n      Simultaneously, NFT projects often have a presale to early project\n      followers and contributors. However, the candy-machine doesn't have the\n      ability to grant early minting to a whitelisted subset of wallets while\n      also using the same asset configuration for open launch.\n      </div>\n\n      <div>\n      Gumdrop (originally pioneered for token airdrops by{\" \"}\n      <HyperLink\n        href=\"https://github.com/Uniswap/merkle-distributor\"\n        underline=\"none\"\n      >\n        Uniswap\n      </HyperLink>\n      {\" \"}and ported to Solana by{WHITESPACE}\n      <HyperLink\n        href=\"https://github.com/saber-hq/merkle-distributor\"\n        underline=\"none\"\n      >\n        Saber\n      </HyperLink>) solves both these issues by building a space-efficient hash\n      structure (the merkle tree) such that an on-chain program can validate\n      whether the user is part of a whitelist. Moreover, Gumdrop\n      allows creators to directly send whitelisted users an airdrop reclamation\n      link by building the tree with off-chain handles (e.g email, discord,\n      etc) and allowing the user to redeem into any wallet.\n      </div>\n    </Stack>\n  );\n\n  const create= (\n    <Stack spacing={1}>\n      <Link to={`/gumdrop/create`}>\n        CREATION\n      </Link>\n\n      <div>\n      Creation builds a whitelist of users that can claim either existing\n      fungible tokens or directly mint from a pre-sale candy-machine.\n      </div>\n\n      <div>\n      Creators must choose a mint or a candy-machine config and UUID, an\n      off-chain notification method (based on the handles supplied below, e.g\n      email, discord, etc), and supply a list of recipients and balances with\n      the following JSON schema{WHITESPACE}\n      <HyperLink\n        href={`data:text/plain;charset=utf-8,${JSON.stringify(require(\"./example.json\"))}`}\n        download=\"example.json\"\n        underline=\"none\"\n      >\n      (Click here for an example)\n      </HyperLink>\n      </div>\n\n      <pre style={{ fontSize: 14 }}>{`\n[\n  {\n    \"handle\": \"<DISTRIBUTION-SPECIFIC-HANDLE>\"\n    \"amount\": <#-TOKENS-OR-CANDY-MINTS>\n  },\n  ...\n]`}</pre>\n\n      <div>\n      NB: When a candy-machine is supplied, update authority for the\n      candy-machine will be transferred to the Gumdrop state. This can\n      be reclaimed by closing the Gumdrop.\n      </div>\n    </Stack>\n  );\n\n  const claim = (\n    <Stack spacing={1}>\n      <Link to={`/gumdrop/claim`}>\n        CLAIMS\n      </Link>\n\n      <div>\n      Claims are redeemed through a URL with query parameters holding\n      claim-specific keys. Claimants will need to verify ownership of the\n      specified handle by answering a OTP challenge and pay the rent and\n      minting fees if applicable.\n      </div>\n    </Stack>\n  );\n\n  const close = (\n    <Stack spacing={1}>\n      <Link to={`/gumdrop/close`}>\n        CLOSING\n      </Link>\n\n      <div>\n      Closing the Gumdrop cleans up the on-chain state and allows\n      creators to recycle any lamports held for rent-exemption after the\n      airdrop is complete.\n      </div>\n\n      <div>\n      When closing a candy-machine-integrated distributor, update authority\n      will be transferred back to the wallet owner.\n      </div>\n    </Stack>\n  );\n\n  const steps = [\n    { name: \"summary\" , inner: summary } ,\n    { name: \"create\"  , inner: create  } ,\n    { name: \"claim\"   , inner: claim   } ,\n    { name: \"close\"   , inner: close   } ,\n  ];\n  return (\n    <Stack\n      alignContent=\"left\"\n      textAlign=\"left\"\n      spacing={2}\n    >\n      {steps.map((s, idx) => <div key={idx}>{s.inner}</div>)}\n    </Stack>\n  );\n};\n\nconst getWindowDimensions = () => {\n  const { innerWidth: width, innerHeight: height } = window;\n  return {\n    width,\n    height,\n  };\n};\n\n// eslint-disable-next-line\nconst useWindowDimensions = () => {\n  const [windowDimensions, setWindowDimensions] = React.useState(\n    getWindowDimensions()\n  );\n\n  React.useEffect(() => {\n    const handleResize = () => {\n      setWindowDimensions(getWindowDimensions());\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []);\n\n  return windowDimensions;\n};\n\nfunction App() {\n  const colorModeCtx = useColorMode();\n\n  React.useEffect(() => {}, [colorModeCtx.mode]);\n\n  const theme = React.useMemo(\n    () => {\n      let mode;\n      if (colorModeCtx.mode === \"dark\" || !colorModeCtx.mode) {\n        mode = \"dark\";\n      } else {\n        mode = \"light\";\n      }\n\n      return createTheme({\n        palette: {\n          mode,\n        },\n      })\n    },\n    [colorModeCtx.mode]\n  );\n\n  const { width } = useWindowDimensions();\n\n  return (\n    <div className=\"App\" style={{ backgroundColor: \"transparent\" }}>\n      <ThemeProvider theme={theme}>\n        <BrowserRouter>\n          <CssBaseline />\n          <Header narrow={width < 670}/>\n          <Box\n            maxWidth=\"60ch\"\n            width=\"calc(100% - 60px)\"\n            style={{\n              marginLeft: \"auto\",\n              marginRight: \"auto\",\n            }}\n          >\n            <Box height=\"40px\" />\n            <Switch>\n              <Route path=\"/gumdrop/create\" component={Create} />\n              <Route path=\"/gumdrop/claim\" component={Claim} />\n              <Route path=\"/gumdrop/close\" component={Close} />\n              <Route path=\"/gumdrop/\" component={About} />\n            </Switch>\n            <Box height=\"80px\" />\n          </Box>\n        </BrowserRouter>\n      </ThemeProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport {\n  AccountsProvider,\n  WalletProvider,\n  ConnectionProvider,\n  ColorModeContextProvider,\n} from \"./contexts\";\n\nimport \"antd/dist/antd.css\";\nimport \"@fontsource/open-sans\";\nimport \"@fontsource/roboto\";\nimport \"@fontsource/sora\";\n\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <ConnectionProvider>\n      <WalletProvider>\n        <AccountsProvider>\n          <ColorModeContextProvider>\n            <App />\n          </ColorModeContextProvider>\n        </AccountsProvider>\n      </WalletProvider>\n    </ConnectionProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\nreportWebVitals();\n","import * as anchor from '@project-serum/anchor';\nimport { Connection, PublicKey } from '@solana/web3.js';\nimport {\n  AccountLayout,\n  MintInfo,\n  MintLayout,\n} from \"@solana/spl-token\";\nimport BN from 'bn.js';\n\nimport {\n  CANDY_MACHINE_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  TOKEN_METADATA_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n} from \"./ids\";\n\nexport const getMintInfo = async (\n  connection : Connection,\n  mint : string\n) : Promise<{ key: PublicKey, info: MintInfo }> => {\n  let mintKey : PublicKey;\n  try {\n    mintKey = new PublicKey(mint);\n  } catch (err) {\n    throw new Error(`Invalid mint key ${err}`);\n  }\n  const mintAccount = await connection.getAccountInfo(mintKey);\n  if (mintAccount === null) {\n    throw new Error(`Could not fetch mint`);\n  }\n  if (!mintAccount.owner.equals(TOKEN_PROGRAM_ID)) {\n    const mintOwner = mintAccount.owner.toBase58();\n    throw new Error(`Invalid mint owner ${mintOwner}`);\n  }\n  if (mintAccount.data.length !== MintLayout.span) {\n    throw new Error(`Invalid mint size ${mintAccount.data.length}`);\n  }\n  const mintInfo = MintLayout.decode(Buffer.from(mintAccount.data));\n  return {\n    key: mintKey,\n    info: mintInfo,\n  };\n};\n\nexport const getCreatorTokenAccount = async (\n  walletKey : PublicKey,\n  connection : Connection,\n  mintKey : PublicKey,\n  totalClaim : number,\n) => {\n  const [creatorTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      walletKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      mintKey.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n  const creatorTokenAccount = await connection.getAccountInfo(creatorTokenKey);\n  if (creatorTokenAccount === null) {\n    throw new Error(`Could not fetch creator token account`);\n  }\n  if (creatorTokenAccount.data.length !== AccountLayout.span) {\n    throw new Error(`Invalid token account size ${creatorTokenAccount.data.length}`);\n  }\n  const creatorTokenInfo = AccountLayout.decode(Buffer.from(creatorTokenAccount.data));\n  if (new BN(creatorTokenInfo.amount, 8, \"le\").toNumber() < totalClaim) {\n    throw new Error(`Creator token account does not have enough tokens`);\n  }\n  return creatorTokenKey;\n};\n\nexport const fetchCoder = async (\n  address : anchor.Address,\n  connection : Connection,\n) : Promise<anchor.Coder | null> => {\n  return new anchor.Coder(await anchor.Program.fetchIdl(\n      address, { connection: connection } as anchor.Provider));\n}\n\nexport const getCandyConfig = async (\n  connection : Connection,\n  config : string\n) : Promise<PublicKey> => {\n  let configKey : PublicKey;\n  try {\n    configKey = new PublicKey(config);\n  } catch (err) {\n    throw new Error(`Invalid config key ${err}`);\n  }\n  const configAccount = await connection.getAccountInfo(configKey);\n  if (configAccount === null) {\n    throw new Error(`Could not fetch config`);\n  }\n  if (!configAccount.owner.equals(CANDY_MACHINE_ID)) {\n    throw new Error(`Invalid config owner ${configAccount.owner.toBase58()}`);\n  }\n  return configKey;\n};\n\nexport const getCandyMachineAddress = async (\n  config: PublicKey,\n  uuid: string,\n) => {\n  return await PublicKey.findProgramAddress(\n    [Buffer.from(\"candy_machine\"), config.toBuffer(), Buffer.from(uuid)],\n    CANDY_MACHINE_ID,\n  );\n};\n\nexport const getCandyMachine = async (\n  connection : Connection,\n  candyMachineKey : PublicKey,\n) => {\n  const candyMachineCoder = await fetchCoder(CANDY_MACHINE_ID, connection);\n  if (candyMachineCoder === null) {\n    throw new Error(`Could not fetch candy machine IDL`);\n  }\n  const candyMachineAccount = await connection.getAccountInfo(candyMachineKey);\n  if (candyMachineAccount === null) {\n    throw new Error(`Could not fetch candy machine`);\n  }\n  return candyMachineCoder.accounts.decode(\n      \"CandyMachine\", candyMachineAccount.data);\n}\n\nexport const getMetadata = async (\n  mint: PublicKey,\n): Promise<PublicKey> => {\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const getEdition = async (\n  mint: PublicKey,\n): Promise<PublicKey> => {\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('edition'),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const getEditionMarkerPda = async (\n  mint: PublicKey,\n  edition: BN,\n) : Promise<PublicKey> => {\n  // editions are divided into pages of 31-bytes (248-bits) for more efficient\n  // packing to check if an edition is occupied. The offset is determined from\n  // the edition passed in through data\n  const editionPageNumber = edition.div(new BN(248)).toNumber();\n\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('edition'),\n        Buffer.from(String(editionPageNumber)),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n}\n","import BN from 'bn.js';\n\nexport const TEN = new BN(10);\nexport const HALF_WAD = TEN.pow(new BN(18));\nexport const WAD = TEN.pow(new BN(18));\nexport const RAY = TEN.pow(new BN(27));\nexport const ZERO = new BN(0);\n","import { useCallback, useState } from 'react';\nimport { MintInfo } from '@solana/spl-token';\n\nimport { TokenAccount } from './../models';\nimport { PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport { WAD, ZERO } from '../constants';\nimport { TokenInfo } from '@solana/spl-token-registry';\n\nexport type KnownTokenMap = Map<string, TokenInfo>;\n\nexport const formatPriceNumber = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 8,\n});\n\nexport function useLocalStorageState(key: string, defaultState?: string) {\n  const [state, setState] = useState(() => {\n    // NOTE: Not sure if this is ok\n    const storedState = localStorage.getItem(key);\n    if (storedState) {\n      return JSON.parse(storedState);\n    }\n    return defaultState;\n  });\n\n  const setLocalStorageState = useCallback(\n    newState => {\n      const changed = state !== newState;\n      if (!changed) {\n        return;\n      }\n      setState(newState);\n      if (newState === null) {\n        localStorage.removeItem(key);\n      } else {\n        try {\n          localStorage.setItem(key, JSON.stringify(newState));\n        } catch {\n          // ignore\n        }\n      }\n    },\n    [state, key],\n  );\n\n  return [state, setLocalStorageState];\n}\n\nexport const findProgramAddress = async (\n  seeds: (Buffer | Uint8Array)[],\n  programId: PublicKey,\n) => {\n  const key =\n    'pda-' +\n    seeds.reduce((agg, item) => agg + item.toString('hex'), '') +\n    programId.toString();\n  let cached = localStorage.getItem(key);\n  if (cached) {\n    const value = JSON.parse(cached);\n\n    return [value.key, parseInt(value.nonce)] as [string, number];\n  }\n\n  const result = await PublicKey.findProgramAddress(seeds, programId);\n\n  try {\n    localStorage.setItem(\n      key,\n      JSON.stringify({\n        key: result[0].toBase58(),\n        nonce: result[1],\n      }),\n    );\n  } catch {\n    // ignore\n  }\n\n  return [result[0].toBase58(), result[1]] as [string, number];\n};\n\n// shorten the checksummed version of the input address to have 4 characters at start and end\nexport function shortenAddress(address: string, chars = 4): string {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n}\n\nexport function getTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownSymbol = map.get(mintAddress)?.symbol;\n  if (knownSymbol) {\n    return knownSymbol;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\nexport function getVerboseTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownName = map.get(mintAddress)?.name;\n  if (knownName) {\n    return knownName;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\n\nexport function getTokenByName(tokenMap: KnownTokenMap, name: string) {\n  let token: TokenInfo | null = null;\n  for (const val of tokenMap.values()) {\n    if (val.symbol === name) {\n      token = val;\n      break;\n    }\n  }\n  return token;\n}\n\nexport function getTokenIcon(\n  map: KnownTokenMap,\n  mintAddress?: string | PublicKey,\n): string | undefined {\n  const address =\n    typeof mintAddress === 'string' ? mintAddress : mintAddress?.toBase58();\n  if (!address) {\n    return;\n  }\n\n  return map.get(address)?.logoURI;\n}\n\nexport function isKnownMint(map: KnownTokenMap, mintAddress: string) {\n  return !!map.get(mintAddress);\n}\n\nexport const STABLE_COINS = new Set(['USDC', 'wUSDC', 'USDT']);\n\nexport function chunks<T>(array: T[], size: number): T[][] {\n  return Array.apply<number, T[], T[][]>(\n    0,\n    new Array(Math.ceil(array.length / size)),\n  ).map((_, index) => array.slice(index * size, (index + 1) * size));\n}\n\nexport function toLamports(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  return Math.floor(amount * precision);\n}\n\nexport function wadToLamports(amount?: BN): BN {\n  return amount?.div(WAD) || ZERO;\n}\n\nexport function fromLamports(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount = Math.floor(\n    typeof account === 'number'\n      ? account\n      : BN.isBN(account)\n      ? account.toNumber()\n      : account.info.amount.toNumber(),\n  );\n\n  const precision = Math.pow(10, mint?.decimals || 9);\n  return (amount / precision) * rate;\n}\n\nexport const tryParseKey = (key: string): PublicKey | null => {\n  try {\n    return new PublicKey(key);\n  } catch (error) {\n    return null;\n  }\n};\n\nvar SI_SYMBOL = ['', 'k', 'M', 'G', 'T', 'P', 'E'];\n\nconst abbreviateNumber = (number: number, precision: number) => {\n  let tier = (Math.log10(number) / 3) | 0;\n  let scaled = number;\n  let suffix = SI_SYMBOL[tier];\n  if (tier !== 0) {\n    let scale = Math.pow(10, tier * 3);\n    scaled = number / scale;\n  }\n\n  return scaled.toFixed(precision) + suffix;\n};\n\nexport const formatAmount = (\n  val: number,\n  precision: number = 2,\n  abbr: boolean = true,\n) => (abbr ? abbreviateNumber(val, precision) : val.toFixed(precision));\n\nexport function formatTokenAmount(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n  prefix = '',\n  suffix = '',\n  precision = 2,\n  abbr = false,\n): string {\n  if (!account) {\n    return '';\n  }\n\n  return `${[prefix]}${formatAmount(\n    fromLamports(account, mint, rate),\n    precision,\n    abbr,\n  )}${suffix}`;\n}\n\nexport const formatUSD = new Intl.NumberFormat('en-US', {\n  style: 'currency',\n  currency: 'USD',\n});\n\nconst numberFormater = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport const formatNumber = {\n  format: (val?: number) => {\n    if (!val) {\n      return '--';\n    }\n\n    return numberFormater.format(val);\n  },\n};\n\nexport const formatPct = new Intl.NumberFormat('en-US', {\n  style: 'percent',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport function convert(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  let result = (amount / precision) * rate;\n\n  return result;\n}\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n"],"sourceRoot":""}