{"version":3,"sources":["utils/claimant.ts","utils/transactions.ts","contexts/ConnectionContext.tsx","utils/merkleTree.ts","utils/programIds.ts","components/DefaultModal/index.tsx","contexts/AccountContext.tsx","utils/eventEmitter.ts","components/Settings/index.tsx","contexts/ColorModeContext.tsx","utils/merkleDistributor.ts","utils/notifications.tsx","utils/borsh.ts","utils/ids.ts","components/Claim.tsx","contexts/WalletContext/WalletContext.tsx","contexts/WalletContext/wallet.less","contexts/ModalContext.tsx","components/Header/Header.tsx","components/Close.tsx","utils/communication.ts","components/DragAndDrop.tsx","components/Create.tsx","App.tsx","reportWebVitals.ts","index.tsx","utils/accounts.ts","constants/math.ts","utils/utils.ts"],"names":["parseClaimants","input","filename","method","extension","match","Error","search","arr","strData","objPattern","RegExp","arrMatches","arrData","exec","length","push","replace","csvStringToArray","foundIdx","findIndex","s","includes","numbers","Set","slice","filter","map","n","idx","handle","amount","edition","JSON","parse","obj","url","explorerUrlFor","env","key","dropInfoFor","integration","tokenMint","candyConfig","masterMint","type","meta","validateTransferClaims","connection","walletKey","claimants","mintStr","a","forEach","c","total","reduce","acc","getMintInfo","mint","getCreatorTokenAccount","source","validateCandyClaims","candyUuid","getCandyConfig","configKey","getCandyMachineAddress","candyMachineKey","getCandyMachine","candyMachine","remaining","data","itemsAvailable","toNumber","itemsRedeemed","isNaN","authority","equals","config","uuid","getIndex","offsetFromStart","div","BN","getOffsetFromRight","sub","mod","getIndexAndMask","getOffsetFromStart","index","mask","shln","editionTaken","marker","m","setEditionTaken","validateEditionClaims","masterMintStr","masterTokenAccount","getEdition","masterEditionKey","getAccountInfo","masterEdition","console","log","currentSupply","maxSupply","editions","editionMarkers","undefined","getEditionMarkerPda","markerKey","markerData","find","pm","markerAcc","Array","chunk","len","chunks","i","buildGumdrop","needsPin","claimIntegration","host","baseKey","temporalSigner","claimInfo","leafs","claimant","secret","PublicKey","seeds","seed","toBuffer","Buffer","from","pin","toArray","findProgramAddress","GUMDROP_DISTRIBUTOR_ID","claimantPda","extra","tree","MerkleTree","root","getRoot","distributor","dbump","proof","getProof","verifyProof","params","encodeURIComponent","b","bs58","query","join","instructions","TransactionInstruction","programId","keys","pubkey","isSigner","isWritable","SystemProgram","sha256","digest","Token","createApproveInstruction","TOKEN_PROGRAM_ID","distributorWalletKey","CANDY_MACHINE_ID","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","distributorTokenKey","createAssociatedTokenAccountInstruction","createTransferInstruction","closeGumdrop","base","claimMethod","publicKey","distributorKey","wbump","extraKeys","masterMintKey","walletTokenKey","getUnixTs","Date","getTime","envFor","_rpcEndpoint","explorerLinkFor","txid","sendSignedTransaction","signedTransaction","timeout","rawTransaction","serialize","startTime","slot","sendRawTransaction","skipPreflight","debug","done","sleep","awaitTransactionSignatureConfirmation","confirmation","err","error","simulateResult","simulateTransaction","value","logs","line","startsWith","stringify","transaction","commitment","_recentBlockhash","_disableBlockhashCaching","recentBlockhash","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","args","encoding","_rpcRequest","res","message","result","queryStatus","status","confirmations","subId","Promise","resolve","reject","setTimeout","warn","onSignature","context","e","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener","ENDPOINTS","name","endpoint","ChainId","MainnetBeta","Devnet","DEFAULT","ConnectionContext","React","createContext","setEndpoint","Connection","tokens","tokenMap","Map","ConnectionProvider","children","useLocalStorageState","useMemo","end","useState","setTokens","setTokenMap","useEffect","TokenListProvider","then","container","list","excludeByTag","filterByChainId","getList","knownMints","item","set","address","id","onAccountChange","Keypair","generate","removeAccountChangeListener","onSlotChange","removeSlotChangeListener","Provider","useConnection","useContext","useConnectionConfig","SequenceType","getErrorForTransaction","confirmTransaction","getParsedConfirmedTransaction","tx","errors","logMessages","regex","lastIndex","sendTransactionWithRetry","wallet","signers","includesFeePayer","block","beforeSend","WalletNotConnectedError","Transaction","instruction","add","getRecentBlockhash","blockhash","setSigners","partialSign","signTransaction","layers","this","hashes","nodeHash","cur","nxt","internalHash","layer","sibling","Math","floor","el","pair","keccak_256","first","second","sort","compare","fst","snd","leaf","programIds","token","associatedToken","bpf_upgrade_loader","BPF_UPGRADE_LOADER_ID","system","SYSTEM","memo","MEMO_ID","DefaultModal","props","bodyStyle","closeIcon","width","rest","style","background","borderRadius","display","flexDirection","alignItems","footer","AccountsContext","pendingCalls","genericCache","pendingMintCalls","mintCache","pubKey","info","deserializeMint","TokenAccountParser","buffer","deserializeAccount","account","keyToAccountParser","cache","emitter","EventEmitter","parser","toBase58","get","isActive","deserialize","registerParser","delete","Function","isNew","has","raiseCacheUpdated","raiseCacheDeleted","byParser","queryMint","getMint","addMint","UseNativeAccount","useWallet","nativeAccount","setNativeAccount","updateCache","useCallback","wrapped","WRAPPED_SOL_MINT","owner","u64","lamports","delegate","delegatedAmount","isInitialized","isFrozen","isNative","rentExemptReserve","closeAuthority","wrapNativeAccount","updateAccount","PRECACHED_OWNERS","precacheUserTokenAccounts","getTokenAccountsByOwner","AccountsProvider","tokenAccounts","setTokenAccounts","userAccounts","setUserAccounts","selectUserAccounts","accounts","subs","onCache","tokenSubID","onProgramAccountChange","accountId","accountInfo","AccountLayout","span","removeProgramAccountChangeListener","decode","fromBuffer","delegateOption","state","isNativeOption","closeAuthorityOption","MintLayout","mintInfo","mintAuthorityOption","mintAuthority","supply","freezeAuthorityOption","freezeAuthority","CacheUpdateEvent","CacheDeleteEvent","MarketUpdateEvent","ids","Emitter","callback","on","removeListener","emit","Settings","narrow","disconnect","setVisible","useWalletModal","open","setModal","useModal","theme","useTheme","colorModeCtx","useColorMode","handleConnect","ModalEnum","WALLET","connectedActions","click","navigator","clipboard","writeText","notify","description","innerNarrow","inner","Fragment","shortenAddress","catch","expandedExtra","color","variant","drawerOpen","setDrawerOpen","envCollapseOpen","setEnvCollapseOpen","hackySkipSet","toggleDrawer","event","target","classList","contains","drawerC","onClick","anchor","onClose","sx","role","onKeyDown","themeSwitch","ml","toggleColorMode","palette","mode","listHead","primary","primaryTypographyProps","fontSize","fontWeight","letterSpacing","className","in","unmountOnExit","component","disablePadding","p","selected","pl","direction","spacing","justifyContent","marginRight","minWidth","onChange","underline","ColorModeContext","ColorModeContextProvider","setMode","prevMode","idl","require","coder","Coder","placement","notification","opacity","backgroundColor","BinaryReader","prototype","readPubkey","array","readFixedArray","BinaryWriter","writePubkey","writeFixedArray","readPubkeyAsString","base58","encode","writePubkeyAsString","TOKEN_METADATA_PROGRAM_ID","GUMDROP_TEMPORAL_SIGNER","walletKeyOrPda","buildMintClaim","distributorInfo","tokenAcc","tokenAccKey","distTokenAccount","tokenAccountInfo","pdaSeeds","verifyClaim","claimStatus","cbump","setup","temporal","default","claimAirdrop","concat","buildCandyClaim","candyUUID","claimCount","claimCountAccount","nftsAlreadyMinted","claimAccountInfo","count","claimantStr","nftsAvailable","candyMachineMints","buildSingleCandyMint","instrs","candyMachineWallet","candyMachineMint","getMetadata","candyMachineMetadata","candyMachineMaster","createMintAndAccount","SYSVAR_RENT_PUBKEY","SYSVAR_CLOCK_PUBKEY","getMinimumBalanceForRentExemption","fromPubkey","newAccountPubkey","space","createAccount","createInitMintInstruction","createMintToInstruction","buildEditionClaim","newMint","newMetadataKey","masterMetadataKey","newEdition","editionMarkKey","fetchDistributor","distributorStr","ownerStr","fetchNeedsTemporalSigner","indexStr","Number","Claim","queryString","location","setDistributor","master","setClaimMethod","setTokenAcc","setCandyConfig","setCandyUUID","setMasterMint","editionStr","setEditionStr","setHandle","amountStr","setAmount","setIndex","pinStr","setPin","proofStr","setProof","allFieldsPopulated","editable","setEditable","setTransaction","OTPStr","setOTPStr","asyncNeedsTemporalSigner","setNeedsTemporalSigner","wrap","lambdaAPIEndpoint","sendOTP","preventDefault","connected","split","ret","extraSigners","feePayer","instr","signatures","some","headers","body","fetch","response","json","MessageId","verifyOTP","OTP","FunctionName","otp","blob","sig","addSignature","fullySigned","claimResult","href","loading","setLoading","loadingProgress","size","position","top","left","marginTop","marginLeft","claimData","label","disabled","steps","fullWidth","labelId","textAlign","multiline","needsTemporalSigner","activeStep","setActiveStep","stepToUse","min","stepper","prev","WalletModalContext","WalletModal","wallets","select","visible","setShowWallets","close","onCancel","height","verticalAlign","lineHeight","marginBottom","icon","alt","src","float","WalletModalProvider","setConnected","keyToDisplay","substring","WalletProvider","getPhantomWallet","getSolflareWallet","getTorusWallet","options","clientId","uxMode","getLedgerWallet","getSolongWallet","getMathWallet","getSolletWallet","onError","Object","getOwnPropertyNames","autoConnect","ModalContext","removeModal","Header","navs","window","pathname","Box","bgcolor","overflow","Button","Drawer","List","ListItem","ListItemText","Divider","nav","to","Stack","flexGrow","Close","setBaseKey","localStorage","getItem","submit","fromSecretKey","Uint8Array","closeResult","TextField","FormControl","InputLabel","Select","setItem","MenuItem","formatDropMessage","drop","html","text","subject","distributeAwsSes","auth","accessKeyId","secretAccessKey","client","SESv2Client","region","credentials","single","formatted","Destination","ToAddresses","Content","Simple","Subject","Data","Charset","Body","Html","FromEmailAddress","ListManagementOptions","ContactListName","TopicName","send","SendEmailCommand","messageId","responses","distributeManual","distributeWallet","urlAndHandleFor","DragAndDrop","dropRef","useRef","dragCounter","setDragCounter","dragging","setDragging","handleDrag","stopPropagation","handleDragIn","dataTransfer","items","handleDragOut","remainingDrags","handleDrop","files","clearData","node","current","addEventListener","removeEventListener","shade","ref","randomBytes","buf","crypto","getRandomValues","WHITESPACE","distribute","reactModal","renderModal","document","createElement","appendChild","destroyModal","ReactDOM","unmountComponentAtNode","removeChild","onSubmit","onDismiss","render","show","displayModal","finally","hideModal","resendOnlyRender","opt","hyperLinkData","encoded","shouldSendRender","limit","TableContainer","maxHeight","Table","TableHead","TableRow","TableCell","TableBody","border","scope","String","pow","decimals","secretKey","download","Create","setMint","setFilename","setText","claimURLs","setClaimURLs","setResponses","otpAuth","setOtpAuth","commMethod","setCommMethod","commAuth","setCommAuth","commSource","setCommSource","awsAccessKeyId","setAwsAccessKeyId","awsSecretKey","setAwsSecretKey","distributeClaims","dropInfo","mightHaveExisting","resendOnly","origin","createResult","handleFiles","file","reader","FileReader","onload","readAsText","fileUpload","alignContent","padding","hidden","createAirdrop","CircularProgress","otpAuthC","rel","commAuthorization","About","getWindowDimensions","innerWidth","innerHeight","App","createTheme","windowDimensions","setWindowDimensions","handleResize","useWindowDimensions","ThemeProvider","CssBaseline","maxWidth","path","reportWebVitals","onPerfEntry","getCLS","getFID","getFCP","getLCP","getTTFB","StrictMode","getElementById","mintKey","mintAccount","mintOwner","totalClaim","creatorTokenKey","creatorTokenAccount","creatorTokenInfo","fetchCoder","fetchIdl","configAccount","candyMachineCoder","candyMachineAccount","editionPageNumber","TEN","Intl","NumberFormat","minimumFractionDigits","maximumFractionDigits","defaultState","storedState","setState","setLocalStorageState","newState","removeItem","chars","apply","ceil","_","currency","ms"],"mappings":"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","file":"static/js/main.6ab14e45.chunk.js","sourcesContent":["import {\n  Connection as RPCConnection,\n  Keypair,\n  PublicKey,\n  SystemProgram,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport {\n  Token,\n} from \"@solana/spl-token\";\nimport { sha256 } from \"js-sha256\";\nimport BN from 'bn.js';\nimport * as bs58 from \"bs58\";\n\nimport {\n  getCandyConfig,\n  getCandyMachineAddress,\n  getCandyMachine,\n  getCreatorTokenAccount,\n  getEdition,\n  getEditionMarkerPda,\n  getMintInfo,\n} from \"./accounts\";\nimport {\n  CANDY_MACHINE_ID,\n  GUMDROP_DISTRIBUTOR_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n} from \"./ids\";\nimport {\n  MerkleTree,\n} from \"./merkleTree\";\n\nexport type ClaimantInfo = {\n  handle : string,\n  amount : number,\n  edition : number,\n\n  pin    : BN,\n  url    : string,\n\n  seed   : PublicKey,\n  secret : PublicKey,\n};\n\nconst csvStringToArray = (strData) => {\n  const objPattern = new RegExp((\"(\\\\,|\\\\r?\\\\n|\\\\r|^)(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|([^\\\\,\\\\r\\\\n]*))\"),\"gi\");\n  let arrMatches : RegExpExecArray | null = null;\n  let arrData : Array<Array<string>> = [[]];\n  while (!!(arrMatches = objPattern.exec(strData))) {\n    if (arrMatches[1].length && arrMatches[1] !== \",\")\n      arrData.push([]);\n    arrData[arrData.length - 1].push(\n      arrMatches[2]\n        ? arrMatches[2].replace(new RegExp( \"\\\"\\\"\", \"g\" ), \"\\\"\")\n        : arrMatches[3]);\n  }\n  return arrData;\n}\n\nexport type Claimants = Array<ClaimantInfo>;\nexport const parseClaimants = (\n  input : string,\n  filename : string,\n  method : string,\n) : Claimants => {\n  const extension = filename.match(/\\.[0-9a-z]+$/i);\n  if (extension === null) {\n    throw new Error(`Could not parse file extension from ${filename}`);\n  }\n  switch (extension[0]) {\n    case \".csv\": {\n      const arr = csvStringToArray(input);\n      // TODO: more robust\n      let search;\n      if (method === \"aws-sms\") {\n        search = \"phone number\";\n      } else if (method === \"aws-email\") {\n        search = \"email\";\n      } else {\n        throw new Error(`Cannot parse csv for ${search}`);\n      }\n      const foundIdx = arr[0].findIndex(s => s.includes(search));\n      if (foundIdx === -1)\n        throw new Error(`Could not find ${search} index`);\n\n      const numbers = new Set(\n        arr.slice(1)\n           .filter(arr => arr[foundIdx].length > 0)\n           .map(arr => arr[foundIdx])\n      );\n\n      return [...numbers].map((n, idx) => {\n        return {\n          handle : n,\n          amount : 1,\n          edition : idx,\n        } as any;\n      });\n    }\n    case \".json\": {\n      const json = JSON.parse(input);\n      return json.map(obj => {\n        return {\n          handle : obj.handle,\n          amount : obj.amount,\n          edition: obj.edition,\n          url    : obj.url,\n        };\n      });\n    }\n    default: {\n      throw new Error(`Cannot parse file format ${extension} from ${filename}`);\n    }\n  }\n};\n\nconst explorerUrlFor = (env : string, key : string) => {\n  return `https://explorer.solana.com/address/${key}?cluster=${env}`;\n}\n\nexport type ClaimInfo = { [key: string]: any };\n\nexport const dropInfoFor = (\n  env : string,\n  integration : string,\n  tokenMint : string,\n  candyConfig : string,\n  masterMint : string,\n) => {\n  switch (integration) {\n    case \"transfer\":\n      return { type: \"Token\", meta: explorerUrlFor(env, tokenMint) };\n    case \"candy\":\n      return { type: \"Candy\", meta: explorerUrlFor(env, candyConfig) };\n    case \"edition\":\n      return { type: \"Edition\", meta: explorerUrlFor(env, masterMint) };\n    default:\n      throw new Error(`Unknown claim integration method ${integration}`);\n  }\n}\n\nexport const validateTransferClaims = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  claimants : Claimants,\n  mintStr : string,\n) : Promise<ClaimInfo> => {\n  claimants.forEach((c, idx) => {\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\n    if (!c.amount) throw new Error(`Claimant ${idx} doesn't have amount`);\n    if (c.amount === 0) throw new Error(`Claimant ${idx} amount is 0`);\n  });\n\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\n  const mint = await getMintInfo(connection, mintStr);\n  const source = await getCreatorTokenAccount(\n    walletKey,\n    connection,\n    mint.key,\n    total\n  );\n\n  return {\n    total: total,\n    mint: mint,\n    source: source,\n  };\n}\n\nexport const validateCandyClaims = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  claimants : Claimants,\n  candyConfig : string,\n  candyUuid : string,\n) : Promise<ClaimInfo> => {\n  claimants.forEach((c, idx) => {\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\n    if (!c.amount) throw new Error(`Claimant ${idx} doesn't have amount`);\n    if (c.amount === 0) throw new Error(`Claimant ${idx} amount is 0`);\n  });\n\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\n  const configKey = await getCandyConfig(connection, candyConfig);\n  const [candyMachineKey, ] = await getCandyMachineAddress(configKey, candyUuid);\n\n  const candyMachine = await getCandyMachine(connection, candyMachineKey);\n\n  const remaining = candyMachine.data.itemsAvailable.toNumber() - candyMachine.itemsRedeemed.toNumber();\n  if (isNaN(remaining)) {\n    // TODO: should this have an override?\n    throw new Error(`Could not calculate how many candy machine items are remaining`);\n  }\n  if (remaining < total) {\n    throw new Error(`Distributor is allocated more mints (${total}) `\n                  + `than the candy machine has remaining (${remaining})`);\n  }\n  if (!candyMachine.authority.equals(walletKey)) {\n    throw new Error(`Candy machine authority does not match wallet public key`);\n  }\n\n  return {\n    total: total,\n    config: configKey,\n    uuid: candyUuid,\n    candyMachineKey: candyMachineKey,\n  };\n}\n\nconst getOffsetFromStart = (edition: BN) => {\n  return edition.mod(new BN(31 * 8));\n};\n\nconst getIndex = (offsetFromStart: BN) => {\n  return offsetFromStart.div(new BN(8));\n};\n\nconst getOffsetFromRight = (offsetFromStart: BN) => {\n  return new BN(7).sub(offsetFromStart.mod(new BN(8)));\n};\n\nconst getIndexAndMask = (edition: BN) => {\n  const offsetFromStart = getOffsetFromStart(edition);\n  return {\n    index: getIndex(offsetFromStart).toNumber(),\n    mask: new BN(1).shln(getOffsetFromRight(offsetFromStart).toNumber()).toNumber(),\n  };\n};\n\nconst editionTaken = (marker : Array<number>, edition : BN) : boolean => {\n  let m = getIndexAndMask(edition);\n  return (marker[m.index] & m.mask) !== 0;\n}\n\nconst setEditionTaken = (marker : Array<number>, edition : BN) => {\n  let m = getIndexAndMask(edition);\n  marker[m.index] = marker[m.index] | m.mask;\n}\n\nexport const validateEditionClaims = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  claimants : Claimants,\n  masterMintStr : string,\n) : Promise<ClaimInfo> => {\n  claimants.forEach((c, idx) => {\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\n    if (c.amount !== 1) {\n      throw new Error(`Claimant ${idx} has amount ${c.amount}. Expected 1 for edition gumdrop`);\n    }\n  });\n\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\n  const masterMint = await getMintInfo(connection, masterMintStr);\n  const masterTokenAccount = await getCreatorTokenAccount(\n    walletKey,\n    connection,\n    masterMint.key,\n    1 // just check that the creator has the master mint\n  );\n\n  const masterEditionKey = await getEdition(masterMint.key);\n  const masterEdition = await connection.getAccountInfo(masterEditionKey);\n  if (masterEdition === null) {\n    throw new Error(`Could not fetch master edition`);\n  }\n  console.log(\"Master edition\", masterEdition);\n\n  // maxSupply is an option, 9 bytes, first is 0 means is none\n  const currentSupply = new BN(masterEdition.data.slice(1, 1+8), 8, \"le\").toNumber();\n  let maxSupply;\n  if (masterEdition.data[9] === 0) {\n      maxSupply = null;\n  } else {\n      maxSupply = new BN(masterEdition.data.slice(10, 10+8), 8, \"le\").toNumber();\n  }\n  console.log(\"Max supply\", maxSupply);\n  console.log(\"Current supply\", currentSupply);\n\n  if (maxSupply !== null && maxSupply < total) {\n    throw new Error(`Distributor is allocated more editions (${total}) `\n                  + `than the master has total (${maxSupply})`);\n  }\n\n  // Whether an edition has been claimed is a single bit in a paginated account\n  // (pda off of master mint). The following code does some sanity checks\n  // around max supply and internally whether the distribution list has\n  // duplicate editions, and also checks if the editions were already taken on\n  // chain.\n  //\n  // There is a race condition since the authority to mint is still currently\n  // the wallet but it seems like a user error to have other editions being\n  // minted while a gumdrop is being created\n  const editions : { [key: number]: number } = {};\n  const editionMarkers : Array<[PublicKey, Array<number>]> = [];\n  for (let idx = 0; idx < claimants.length; ++idx ) {\n    const c = claimants[idx];\n    if (c.edition === undefined) throw new Error(`Claimant ${idx} doesn't have edition`);\n    if (c.edition <= 0) {\n      throw new Error(`Claimant ${idx} assigned invalid edition ${c.edition}`);\n    }\n    if (c.edition > maxSupply) {\n      throw new Error(`Claimant ${idx} assigned edition ${c.edition} which is beyond the max supply`);\n    }\n    if (c.edition in editions) {\n      throw new Error(`Claimant ${idx} and ${editions[c.edition]} are both assigned to edition ${c.edition}`);\n    }\n    const edition = new BN(c.edition);\n    const markerKey = await getEditionMarkerPda(masterMint.key, edition);\n    let markerData = editionMarkers.find(pm => pm[0].equals(markerKey));\n    if (markerData === undefined) {\n      const markerAcc = await connection.getAccountInfo(markerKey);\n      if (markerAcc === null) {\n        editionMarkers.push([markerKey, Array<number>(31)]);\n      } else {\n        editionMarkers.push([markerKey, [...markerAcc.data.slice(1, 32)]]);\n      }\n      markerData = editionMarkers[editionMarkers.length - 1];\n    }\n\n    if (markerData === undefined) {\n      throw new Error(`Internal Error: Edition marker info still undefined ${c.edition}`);\n    }\n\n    if (editionTaken(markerData[1], edition)) {\n      throw new Error(`Claimant ${idx} is assigned to edition ${c.edition} which is already taken`);\n    }\n\n    setEditionTaken(markerData[1], edition);\n\n    editions[c.edition] = idx;\n  }\n\n  return {\n    total: total,\n    masterMint: masterMint,\n    masterTokenAccount: masterTokenAccount,\n  };\n}\n\nexport const chunk = (\n  arr : Buffer,\n  len : number,\n) : Array<Buffer> => {\n  let chunks : Array<Buffer> = [],\n      i = 0,\n      n = arr.length;\n\n  while (i < n) {\n    chunks.push(arr.slice(i, i += len));\n  }\n\n  return chunks;\n}\n\nexport const buildGumdrop = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  needsPin : boolean,\n  claimIntegration : string,\n  host : string,\n  baseKey : PublicKey,\n  temporalSigner : PublicKey,\n  claimants : Claimants,\n  claimInfo  : ClaimInfo,\n) : Promise<Array<TransactionInstruction>> => {\n\n  const leafs : Array<Buffer> = [];\n  for (let idx = 0; idx < claimants.length; ++idx ) {\n    const claimant = claimants[idx];\n    if (!needsPin) {\n      try {\n        claimant.secret = new PublicKey(claimant.handle);\n      } catch (err) {\n        throw new Error(`Invalid claimant wallet handle ${err}`);\n      }\n    } else {\n      const seeds = [\n        claimant.seed.toBuffer(),\n        ...chunk(Buffer.from(claimant.handle), 32),\n        Buffer.from(claimant.pin.toArray(\"le\", 4)),\n      ];\n      const [claimantPda, ] = await PublicKey.findProgramAddress(\n          seeds.map(s => s.slice(0, 32)), GUMDROP_DISTRIBUTOR_ID);\n      claimant.secret = claimantPda;\n    }\n    // TODO: get this clarified with jordan... we can either just assign some\n    // range of editions to a user or give them an amount and just keep a\n    // counter on the distributor... the latter is much less work but we lose\n    // the ability to use gumdrop for auction house winnings and such?\n    const extra = claimIntegration === \"edition\"\n      ? [...new BN(claimant.edition).toArray(\"le\", 8)]\n      : []\n    leafs.push(Buffer.from(\n      [...new BN(idx).toArray(\"le\", 8),\n       ...claimant.secret.toBuffer(),\n       ...claimant.seed.toBuffer(),\n       ...new BN(claimant.amount).toArray(\"le\", 8),\n       ...extra\n      ]\n    ));\n  }\n\n  const tree = new MerkleTree(leafs);\n  const root = tree.getRoot();\n\n  const [distributor, dbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"MerkleDistributor\"),\n      baseKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID);\n\n  for (let idx = 0; idx < claimants.length; ++idx) {\n    const proof = tree.getProof(idx);\n    const verified = tree.verifyProof(idx, proof, root);\n\n    if (!verified) {\n      throw new Error(\"Gumdrop merkle tree verification failed\");\n    }\n\n    const claimant = claimants[idx];\n    const params = [\n      `distributor=${distributor}`,\n      `handle=${encodeURIComponent(claimant.handle)}`,\n      `amount=${claimant.amount}`,\n      `index=${idx}`,\n      `proof=${proof.map(b => bs58.encode(b))}`,\n    ];\n    if (needsPin) {\n      params.push(`pin=${claimant.pin.toNumber()}`);\n    } else {\n      params.push(`pin=NA`);\n    }\n    if (claimIntegration === \"transfer\") {\n      params.push(`tokenAcc=${claimInfo.source}`);\n    } else if (claimIntegration === \"candy\") {\n      params.push(`config=${claimInfo.config}`);\n      params.push(`uuid=${claimInfo.uuid}`);\n    } else {\n      params.push(`master=${claimInfo.masterMint.key}`);\n      params.push(`edition=${claimant.edition}`);\n    }\n    const query = params.join(\"&\");\n\n    claimant.url = `${host}/claim?${query}`;\n  }\n\n  // initial merkle-distributor state\n  const instructions = Array<TransactionInstruction>();\n  instructions.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: baseKey                 , isSigner: true  , isWritable: false } ,\n          { pubkey: distributor             , isSigner: false , isWritable: true  } ,\n          { pubkey: walletKey               , isSigner: true  , isWritable: false } ,\n          { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:new_distributor\")).slice(0, 8),\n        ...new BN(dbump).toArray(\"le\", 1),\n        ...root,\n        ...temporalSigner.toBuffer(),\n      ])\n  }));\n\n  if (claimIntegration === \"transfer\") {\n    instructions.push(Token.createApproveInstruction(\n      TOKEN_PROGRAM_ID,\n      claimInfo.source,\n      distributor,\n      walletKey,\n      [],\n      claimInfo.total\n    ));\n  } else if (claimIntegration === \"candy\") {\n    const [distributorWalletKey, ] = await PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"Wallet\"),\n        distributor.toBuffer(),\n      ],\n      GUMDROP_DISTRIBUTOR_ID\n    );\n\n    instructions.push(new TransactionInstruction({\n        programId: CANDY_MACHINE_ID,\n        keys: [\n            { pubkey: claimInfo.candyMachineKey,isSigner: false , isWritable: true  } ,\n            { pubkey: walletKey               , isSigner: true  , isWritable: false } ,\n        ],\n        data: Buffer.from([\n          ...Buffer.from(sha256.digest(\"global:update_authority\")).slice(0, 8),\n          ...new BN(1).toArray(\"le\", 1),  // optional exists...\n          ...distributorWalletKey.toBuffer(),\n        ])\n    }));\n  } else if (claimIntegration === \"edition\") {\n    // transfer master edition to distributor\n    const [distributorTokenKey, ] = await PublicKey.findProgramAddress(\n      [\n        distributor.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        claimInfo.masterMint.key.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    );\n\n    instructions.push(Token.createAssociatedTokenAccountInstruction(\n        SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n        TOKEN_PROGRAM_ID,\n        claimInfo.masterMint.key,\n        distributorTokenKey,\n        distributor,\n        walletKey,\n      ));\n\n    instructions.push(Token.createTransferInstruction(\n        TOKEN_PROGRAM_ID,\n        claimInfo.masterTokenAccount,\n        distributorTokenKey,\n        walletKey,\n        [],\n        1\n      ));\n  }\n\n  return instructions;\n}\n\nexport const closeGumdrop = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  base : Keypair,\n  claimMethod : string,\n  candyConfig : string,\n  candyUuid : string,\n  masterMint : string,\n) : Promise<Array<TransactionInstruction>> => {\n  const [distributorKey, dbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"MerkleDistributor\"),\n      base.publicKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID);\n\n  const [distributorWalletKey, wbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"Wallet\"),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  let extraKeys;\n  if (claimMethod === \"candy\") {\n    const configKey = await getCandyConfig(connection, candyConfig);\n    const [candyMachineKey, ] = await getCandyMachineAddress(\n      configKey, candyUuid);\n\n   extraKeys = [\n          { pubkey: candyMachineKey         , isSigner: false , isWritable: true  } ,\n          { pubkey: CANDY_MACHINE_ID        , isSigner: false , isWritable: false } ,\n    ];\n  } else {\n    extraKeys = [];\n  }\n\n  const instructions = Array<TransactionInstruction>();\n  if (claimMethod === \"edition\") {\n    let masterMintKey: PublicKey;\n    try {\n      masterMintKey = new PublicKey(masterMint);\n    } catch (err) {\n      throw new Error(`Invalid mint key ${err}`);\n    }\n    const [distributorTokenKey, ] = await PublicKey.findProgramAddress(\n      [\n        distributorKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        masterMintKey.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    );\n\n    const [walletTokenKey, ] = await PublicKey.findProgramAddress(\n      [\n        walletKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        masterMintKey.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    );\n\n    instructions.push(new TransactionInstruction({\n        programId: GUMDROP_DISTRIBUTOR_ID,\n        keys: [\n            { pubkey: base.publicKey          , isSigner: true  , isWritable: false } ,\n            { pubkey: distributorKey          , isSigner: false , isWritable: false } ,\n            { pubkey: distributorTokenKey     , isSigner: false , isWritable: true  } ,\n            { pubkey: walletTokenKey          , isSigner: false , isWritable: true  } ,\n            { pubkey: walletKey               , isSigner: false , isWritable: true  } ,\n            { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\n            { pubkey: TOKEN_PROGRAM_ID        , isSigner: false , isWritable: false } ,\n        ],\n        data: Buffer.from([\n          ...Buffer.from(sha256.digest(\"global:close_distributor_token_account\")).slice(0, 8),\n          ...new BN(dbump).toArray(\"le\", 1),\n        ])\n    }));\n  }\n\n  instructions.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: base.publicKey          , isSigner: true  , isWritable: false } ,\n          { pubkey: distributorKey          , isSigner: false , isWritable: true  } ,\n          { pubkey: distributorWalletKey    , isSigner: false , isWritable: true  } ,\n          { pubkey: walletKey               , isSigner: true  , isWritable: true  } ,\n          { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_PROGRAM_ID        , isSigner: false , isWritable: false } ,\n          ...extraKeys,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:close_distributor\")).slice(0, 8),\n        ...new BN(dbump).toArray(\"le\", 1),\n        ...new BN(wbump).toArray(\"le\", 1),\n      ])\n  }));\n\n  return instructions;\n}\n","import {\n  Blockhash,\n  Commitment,\n  Connection,\n  FeeCalculator,\n  Keypair,\n  RpcResponseAndContext,\n  SignatureStatus,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n} from '@solana/web3.js';\nimport { sleep } from \"../utils/utils\";\nimport log from 'loglevel';\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport const DEFAULT_TIMEOUT = 15000;\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nexport const envFor = (\n  connection: Connection\n) : string => {\n  const endpoint = (connection as any)._rpcEndpoint;\n  const regex = /https:\\/\\/api.([^.]*).solana.com/;\n  const match = endpoint.match(regex);\n  if (match[1]) {\n    return match[1];\n  }\n  return \"mainnet-beta\";\n}\n\nexport const explorerLinkFor = (\n  txid: TransactionSignature,\n  connection: Connection\n) : string => {\n  return `https://explorer.solana.com/tx/${txid}?cluster=${envFor(connection)}`;\n}\n\nexport const sendTransactionWithRetryWithKeypair = async (\n  connection: Connection,\n  wallet: Keypair,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void,\n) => {\n  const transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.sign(...[wallet, ...signers]);\n  } else {\n    transaction.sign(wallet);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const { txid, slot } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction,\n  });\n\n  return { txid, slot };\n};\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    },\n  );\n\n  log.debug('Started awaiting confirmation for', txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      'confirmed',\n      true,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      log.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err) {\n    log.error('Timeout Error caught', err);\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, 'single')\n      ).value;\n    } catch (e) {\n      log.error('Simulate Transaction error', e);\n    }\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith('Program log: ')) {\n            throw new Error(\n              'Transaction failed: ' + line.slice('Program log: '.length),\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  log.debug('Latency (ms)', txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment,\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching,\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config: any = { encoding: 'base64', commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest('simulateTransaction', args);\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n  return res.result;\n}\n\nexport async function awaitTransactionSignatureConfirmation(\n  txid: TransactionSignature,\n  timeout: number,\n  connection: Connection,\n  commitment: Commitment = 'recent',\n  queryStatus = false,\n): Promise<SignatureStatus | null | void> {\n  let done = false;\n  let status: SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  // eslint-disable-next-line no-async-promise-executor\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      log.warn('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            log.warn('Rejected via websocket', result.err);\n            reject(status);\n          } else {\n            log.debug('Resolved via websocket', result);\n            resolve(status);\n          }\n        },\n        commitment,\n      );\n    } catch (e) {\n      done = true;\n      log.error('WS error in setup', txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          console.log(explorerLinkFor(txid, connection));\n          if (!done) {\n            if (!status) {\n              log.debug('REST null result for', txid, status);\n            } else if (status.err) {\n              log.error('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              log.error('REST no confirmations for', txid, status);\n            } else {\n              log.debug('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            log.error('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  log.debug('Returning status', status);\n  return status;\n}\n","import { useLocalStorageState } from \"../utils/utils\";\nimport {\n  Keypair,\n  Commitment,\n  Connection,\n  Transaction,\n  TransactionInstruction,\n  Blockhash,\n  FeeCalculator,\n} from \"@solana/web3.js\";\nimport React, { useContext, useEffect, useMemo, useState } from \"react\";\nimport {\n  sendSignedTransaction,\n} from \"../utils/transactions\";\nimport {\n  TokenInfo,\n  TokenListProvider,\n  ENV as ChainId,\n} from \"@solana/spl-token-registry\";\nimport { WalletSigner } from \"./WalletContext/WalletContext\";\nimport { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport type ENV = \"mainnet-beta\" | \"testnet\" | \"devnet\" | \"localnet\";\n\nexport const ENDPOINTS = [\n  {\n    name: \"mainnet-beta\" as ENV,\n    endpoint: \"https://api.mainnet-beta.solana.com\",\n    ChainId: ChainId.MainnetBeta,\n  },\n  {\n    name: \"devnet\" as ENV,\n    endpoint: \"https://api.devnet.solana.com\",\n    ChainId: ChainId.Devnet,\n  },\n];\n\nconst DEFAULT = ENDPOINTS[0].endpoint;\n\ninterface ConnectionConfig {\n  connection: Connection;\n  endpoint: string;\n  env: ENV;\n  setEndpoint: (val: string) => void;\n  tokens: TokenInfo[];\n  tokenMap: Map<string, TokenInfo>;\n}\n\nconst ConnectionContext = React.createContext<ConnectionConfig>({\n  endpoint: DEFAULT,\n  setEndpoint: () => {},\n  connection: new Connection(DEFAULT, \"recent\"),\n  env: ENDPOINTS[0].name,\n  tokens: [],\n  tokenMap: new Map<string, TokenInfo>(),\n});\n\nexport function ConnectionProvider({ children = undefined as any }) {\n  const [endpoint, setEndpoint] = useLocalStorageState(\n    \"connectionEndpoint\",\n    ENDPOINTS[0].endpoint\n  );\n\n  const connection = useMemo(\n    () => new Connection(endpoint, \"recent\"),\n    [endpoint]\n  );\n\n  const env =\n    ENDPOINTS.find((end) => end.endpoint === endpoint)?.name ||\n    ENDPOINTS[0].name;\n\n  const [tokens, setTokens] = useState<TokenInfo[]>([]);\n  const [tokenMap, setTokenMap] = useState<Map<string, TokenInfo>>(new Map());\n  useEffect(() => {\n    // fetch token files\n    new TokenListProvider().resolve().then((container) => {\n      const list = container\n        .excludeByTag(\"nft\")\n        .filterByChainId(\n          ENDPOINTS.find((end) => end.endpoint === endpoint)?.ChainId ||\n            ChainId.MainnetBeta\n        )\n        .getList();\n\n      const knownMints = [...list].reduce((map, item) => {\n        map.set(item.address, item);\n        return map;\n      }, new Map<string, TokenInfo>());\n\n      setTokenMap(knownMints);\n      setTokens(list);\n    });\n  }, [env, endpoint]);\n\n  // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n  // This is a hack to prevent the list from every getting empty\n  useEffect(() => {\n    const id = connection.onAccountChange(\n      Keypair.generate().publicKey,\n      () => {}\n    );\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    const id = connection.onSlotChange(() => null);\n    return () => {\n      connection.removeSlotChangeListener(id);\n    };\n  }, [connection]);\n\n  return (\n    <ConnectionContext.Provider\n      value={{\n        endpoint,\n        setEndpoint,\n        connection,\n        tokens,\n        tokenMap,\n        env,\n      }}\n    >\n      {children}\n    </ConnectionContext.Provider>\n  );\n}\n\nexport function useConnection() {\n  return useContext(ConnectionContext).connection as Connection;\n}\n\nexport function useConnectionConfig() {\n  const context = useContext(ConnectionContext);\n  return {\n    endpoint: context.endpoint,\n    setEndpoint: context.setEndpoint,\n    env: context.env,\n    tokens: context.tokens,\n    tokenMap: context.tokenMap,\n  };\n}\n\nexport const getErrorForTransaction = async (\n  connection: Connection,\n  txid: string\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, \"max\");\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach((log) => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport enum SequenceType {\n  Sequential,\n  Parallel,\n  StopOnFailure,\n}\n\nexport const sendTransactionWithRetry = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = \"singleGossip\",\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void\n) : Promise<string| { txid: string; slot: number }> => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach((instruction) => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map((s) => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    try {\n      transaction = await wallet.signTransaction(transaction);\n    } catch {\n      return \"Failed to sign transaction\";\n    }\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n  console.log(\"About to send\");\n  try {\n    const { txid, slot } = await sendSignedTransaction({\n      connection,\n      signedTransaction: transaction,\n    });\n\n    return { txid, slot };\n  } catch (error) {\n    console.error(error);\n    return \"See console logs\";\n  }\n};\n\n","import { keccak_256 } from \"js-sha3\";\n\nexport class MerkleTree {\n  leafs: Array<Buffer>;\n  layers: Array<Array<Buffer>>;\n\n  constructor(leafs : Array<Buffer>) {\n    this.leafs = leafs.slice();\n    this.layers = [];\n\n    let hashes = this.leafs.map(MerkleTree.nodeHash);\n    while (hashes.length > 0) {\n      console.log(\"Hashes\", this.layers.length, hashes);\n      this.layers.push(hashes.slice());\n      if (hashes.length === 1) break;\n      hashes = hashes.reduce((acc, cur, idx, arr) => {\n        if (idx % 2 === 0) {\n          const nxt = arr[idx + 1];\n          acc.push(MerkleTree.internalHash(cur, nxt));\n        }\n        return acc;\n      }, Array<Buffer>());\n    }\n  }\n\n  static nodeHash(\n    data : Buffer,\n  ) : Buffer {\n    return Buffer.from(keccak_256.digest([0x00, ...data]));\n  }\n\n\n  static internalHash(\n    first : Buffer,\n    second : Buffer | undefined,\n  ) : Buffer {\n    if (!second) return first;\n    const [fst, snd] = [first, second].sort(Buffer.compare)\n    return Buffer.from(\n      keccak_256.digest([0x01, ...fst, ...snd])\n    );\n  }\n\n  getRoot() : Buffer {\n    return this.layers[this.layers.length - 1][0];\n  }\n\n  getProof(idx : number) : Buffer[] {\n    return this.layers.reduce((proof, layer) => {\n      const sibling = idx ^ 1;\n      if (sibling < layer.length) {\n        proof.push(layer[sibling]);\n      }\n\n      idx = Math.floor(idx / 2);\n\n      return proof;\n    }, []);\n  }\n\n  getHexRoot(): string {\n    return this.getRoot().toString(\"hex\");\n  }\n\n  getHexProof(idx : number) : string[] {\n    return this.getProof(idx).map((el) => el.toString(\"hex\"));\n  }\n\n  verifyProof(\n    idx : number,\n    proof : Buffer[],\n    root : Buffer\n  ): boolean {\n    let pair = MerkleTree.nodeHash(this.leafs[idx]);\n    for (const item of proof) {\n      pair = MerkleTree.internalHash(pair, item);\n    }\n\n    return pair.equals(root);\n  }\n\n  static verifyClaim(\n    leaf : Buffer,\n    proof : Buffer[],\n    root : Buffer\n  ): boolean {\n    let pair = MerkleTree.nodeHash(leaf);\n    for (const item of proof) {\n      pair = MerkleTree.internalHash(pair, item);\n    }\n\n    return pair.equals(root);\n  }\n\n}\n","import {\n  TOKEN_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  BPF_UPGRADE_LOADER_ID,\n  SYSTEM,\n  MEMO_ID,\n} from './ids';\n\nexport const setProgramIds = async () => {};\n\nexport const programIds = () => {\n  return {\n    token: TOKEN_PROGRAM_ID,\n    associatedToken: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    bpf_upgrade_loader: BPF_UPGRADE_LOADER_ID,\n    system: SYSTEM,\n    memo: MEMO_ID,\n    // store: STORE,\n  };\n};\n","import React from \"react\";\nimport { Modal } from \"antd\";\n\nimport \"./index.css\";\n\nexport const DefaultModal = (props: any) => {\n  const { children, closeIcon, bodyStyle, width, style, ...rest } = props;\n\n  return (\n    <Modal\n      style={{ background: \"transparent\", borderRadius: 16 }}\n      bodyStyle={{\n        background: \"#333333\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        ...bodyStyle,\n      }}\n      footer={null}\n      width={\n        width || 400\n      }\n      {...rest}\n    >\n      {children}\n    </Modal>\n  );\n};\n","import React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useState,\n} from 'react';\nimport { useConnection } from './ConnectionContext';\nimport { useWallet } from '@solana/wallet-adapter-react';\nimport { AccountInfo, Connection, PublicKey } from '@solana/web3.js';\nimport { AccountLayout, MintInfo, MintLayout, u64 } from '@solana/spl-token';\nimport { TokenAccount } from '../models';\nimport { chunks } from '../utils/utils';\nimport { EventEmitter } from '../utils/eventEmitter';\nimport { StringPublicKey, WRAPPED_SOL_MINT } from '../utils/ids';\nimport { programIds } from '../utils/programIds';\n\nconst AccountsContext = React.createContext<any>(null);\n\nconst pendingCalls = new Map<string, Promise<ParsedAccountBase>>();\nconst genericCache = new Map<string, ParsedAccountBase>();\nconst pendingMintCalls = new Map<string, Promise<MintInfo>>();\nconst mintCache = new Map<string, MintInfo>();\n\nexport interface ParsedAccountBase {\n  pubkey: StringPublicKey;\n  account: AccountInfo<Buffer>;\n  info: any; // TODO: change to unknown\n}\n\nexport type AccountParser = (\n  pubkey: StringPublicKey,\n  data: AccountInfo<Buffer>,\n) => ParsedAccountBase | undefined;\n\nexport interface ParsedAccount<T> extends ParsedAccountBase {\n  info: T;\n}\n\nconst getMintInfo = async (connection: Connection, pubKey: PublicKey) => {\n  const info = await connection.getAccountInfo(pubKey);\n  if (info === null) {\n    throw new Error('Failed to find mint account');\n  }\n\n  const data = Buffer.from(info.data);\n\n  return deserializeMint(data);\n};\n\nexport const MintParser = (pubKey: string, info: AccountInfo<Buffer>) => {\n  const buffer = Buffer.from(info.data);\n\n  const data = deserializeMint(buffer);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: data,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const TokenAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  // Sometimes a wrapped sol account gets closed, goes to 0 length,\n  // triggers an update over wss which triggers this guy to get called\n  // since your UI already logged that pubkey as a token account. Check for length.\n  if (info.data.length > 0) {\n    const buffer = Buffer.from(info.data);\n    const data = deserializeAccount(buffer);\n\n    const details = {\n      pubkey: pubKey,\n      account: {\n        ...info,\n      },\n      info: data,\n    } as TokenAccount;\n\n    return details;\n  }\n};\n\nexport const GenericAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  const buffer = Buffer.from(info.data);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: buffer,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const keyToAccountParser = new Map<string, AccountParser>();\n\nexport const cache = {\n  emitter: new EventEmitter(),\n  query: async (\n    connection: Connection,\n    pubKey: string | PublicKey,\n    parser?: AccountParser,\n  ) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n\n    let account = genericCache.get(address);\n    if (account) {\n      return account;\n    }\n\n    let query = pendingCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    // TODO: refactor to use multiple accounts query with flush like behavior\n    query = connection.getAccountInfo(id).then(data => {\n      if (!data) {\n        throw new Error('Account not found');\n      }\n\n      return cache.add(id, data, parser);\n    }) as Promise<TokenAccount>;\n    pendingCalls.set(address, query as any);\n\n    return query;\n  },\n  add: (\n    id: PublicKey | string,\n    obj: AccountInfo<Buffer>,\n    parser?: AccountParser,\n    isActive?: boolean | undefined | ((parsed: any) => boolean),\n  ) => {\n    const address = typeof id === 'string' ? id : id?.toBase58();\n    const deserialize = parser ? parser : keyToAccountParser.get(address);\n    if (!deserialize) {\n      throw new Error(\n        'Deserializer needs to be registered or passed as a parameter',\n      );\n    }\n\n    cache.registerParser(id, deserialize);\n    pendingCalls.delete(address);\n    const account = deserialize(address, obj);\n    if (!account) {\n      return;\n    }\n\n    if (isActive === undefined) isActive = true;\n    else if (isActive instanceof Function) isActive = isActive(account);\n\n    const isNew = !genericCache.has(address);\n\n    genericCache.set(address, account);\n    cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);\n    return account;\n  },\n  get: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return genericCache.get(key);\n  },\n  delete: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    if (genericCache.get(key)) {\n      genericCache.delete(key);\n      cache.emitter.raiseCacheDeleted(key);\n      return true;\n    }\n    return false;\n  },\n\n  byParser: (parser: AccountParser) => {\n    const result: string[] = [];\n    for (const id of keyToAccountParser.keys()) {\n      if (keyToAccountParser.get(id) === parser) {\n        result.push(id);\n      }\n    }\n\n    return result;\n  },\n  registerParser: (pubkey: PublicKey | string, parser: AccountParser) => {\n    if (pubkey) {\n      const address = typeof pubkey === 'string' ? pubkey : pubkey?.toBase58();\n      keyToAccountParser.set(address, parser);\n    }\n\n    return pubkey;\n  },\n  queryMint: async (connection: Connection, pubKey: string | PublicKey) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    let mint = mintCache.get(address);\n    if (mint) {\n      return mint;\n    }\n\n    let query = pendingMintCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    query = getMintInfo(connection, id).then(data => {\n      pendingMintCalls.delete(address);\n\n      mintCache.set(address, data);\n      return data;\n    }) as Promise<MintInfo>;\n    pendingMintCalls.set(address, query as any);\n\n    return query;\n  },\n  getMint: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return mintCache.get(key);\n  },\n  addMint: (pubKey: PublicKey, obj: AccountInfo<Buffer>) => {\n    const mint = deserializeMint(obj.data);\n    const id = pubKey.toBase58();\n    mintCache.set(id, mint);\n    return mint;\n  },\n};\n\nexport const useAccountsContext = () => {\n  const context = useContext(AccountsContext);\n\n  return context;\n};\n\nfunction wrapNativeAccount(\n  pubkey: string,\n  account?: AccountInfo<Buffer>,\n): TokenAccount | undefined {\n  if (!account) {\n    return undefined;\n  }\n\n  const key = new PublicKey(pubkey);\n\n  return {\n    pubkey: pubkey,\n    account,\n    info: {\n      address: key,\n      mint: WRAPPED_SOL_MINT,\n      owner: key,\n      amount: new u64(account.lamports),\n      delegate: null,\n      delegatedAmount: new u64(0),\n      isInitialized: true,\n      isFrozen: false,\n      isNative: true,\n      rentExemptReserve: null,\n      closeAuthority: null,\n    },\n  };\n}\n\nexport const getCachedAccount = (\n  predicate: (account: TokenAccount) => boolean,\n) => {\n  for (const account of genericCache.values()) {\n    if (predicate(account)) {\n      return account as TokenAccount;\n    }\n  }\n};\n\nconst UseNativeAccount = () => {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n\n  const [nativeAccount, setNativeAccount] = useState<AccountInfo<Buffer>>();\n\n  const updateCache = useCallback(\n    account => {\n      if (publicKey) {\n        const wrapped = wrapNativeAccount(publicKey.toBase58(), account);\n        if (wrapped !== undefined) {\n          const id = publicKey.toBase58();\n          cache.registerParser(id, TokenAccountParser);\n          genericCache.set(id, wrapped as TokenAccount);\n          cache.emitter.raiseCacheUpdated(id, false, TokenAccountParser, true);\n        }\n      }\n    },\n    [publicKey],\n  );\n\n  useEffect(() => {\n    let subId = 0;\n    const updateAccount = (account: AccountInfo<Buffer> | null) => {\n      if (account) {\n        updateCache(account);\n        setNativeAccount(account);\n      }\n    };\n\n    (async () => {\n      if (!connection || !publicKey) {\n        return;\n      }\n\n      try {\n        const account = await connection.getAccountInfo(publicKey);\n        updateAccount(account);\n      } catch {\n        return;\n      }\n\n      subId = connection.onAccountChange(publicKey, updateAccount);\n    })();\n\n    return () => {\n      if (subId) {\n        connection.removeAccountChangeListener(subId);\n      }\n    };\n  }, [setNativeAccount, publicKey, connection, updateCache]);\n\n  return { nativeAccount };\n};\n\nconst PRECACHED_OWNERS = new Set<string>();\nconst precacheUserTokenAccounts = async (\n  connection: Connection,\n  owner?: PublicKey,\n) => {\n  if (!owner) {\n    return;\n  }\n\n  // used for filtering account updates over websocket\n  PRECACHED_OWNERS.add(owner.toBase58());\n\n  // user accounts are updated via ws subscription\n  const accounts = await connection.getTokenAccountsByOwner(owner, {\n    programId: programIds().token,\n  });\n\n  accounts.value.forEach(info => {\n    cache.add(info.pubkey.toBase58(), info.account, TokenAccountParser);\n  });\n};\n\nexport function AccountsProvider({ children = null as any }) {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n  const [tokenAccounts, setTokenAccounts] = useState<TokenAccount[]>([]);\n  const [userAccounts, setUserAccounts] = useState<TokenAccount[]>([]);\n  const { nativeAccount } = UseNativeAccount();\n  const walletKey = publicKey?.toBase58();\n\n  const selectUserAccounts = useCallback(() => {\n    return cache\n      .byParser(TokenAccountParser)\n      .map(id => cache.get(id))\n      .filter(a => a && a.info.owner.toBase58() === walletKey)\n      .map(a => a as TokenAccount);\n  }, [walletKey]);\n\n  useEffect(() => {\n    const accounts = selectUserAccounts().filter(\n      a => a !== undefined,\n    ) as TokenAccount[];\n    setUserAccounts(accounts);\n  }, [nativeAccount, tokenAccounts, selectUserAccounts]);\n\n  useEffect(() => {\n    const subs: number[] = [];\n    cache.emitter.onCache(args => {\n      if (args.isNew && args.isActive) {\n        let id = args.id;\n        let deserialize = args.parser;\n        connection.onAccountChange(new PublicKey(id), info => {\n          cache.add(id, info, deserialize);\n        });\n      }\n    });\n\n    return () => {\n      subs.forEach(id => connection.removeAccountChangeListener(id));\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    if (!connection || !publicKey) {\n      setTokenAccounts([]);\n    } else {\n      precacheUserTokenAccounts(connection, publicKey).then(() => {\n        setTokenAccounts(selectUserAccounts());\n      });\n\n      // This can return different types of accounts: token-account, mint, multisig\n      // TODO: web3.js expose ability to filter.\n      // this should use only filter syntax to only get accounts that are owned by user\n      const tokenSubID = connection.onProgramAccountChange(\n        programIds().token,\n        info => {\n          // TODO: fix type in web3.js\n          const id = info.accountId as unknown as string;\n          // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\n          if (info.accountInfo.data.length === AccountLayout.span) {\n            const data = deserializeAccount(info.accountInfo.data);\n\n            if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\n              cache.add(id, info.accountInfo, TokenAccountParser);\n              setTokenAccounts(selectUserAccounts());\n            }\n          }\n        },\n        'singleGossip',\n      );\n\n      return () => {\n        connection.removeProgramAccountChangeListener(tokenSubID);\n      };\n    }\n  }, [connection, publicKey, selectUserAccounts]);\n\n  return (\n    <AccountsContext.Provider\n      value={{\n        userAccounts,\n        nativeAccount,\n      }}\n    >\n      {children}\n    </AccountsContext.Provider>\n  );\n}\n\nexport function useNativeAccount() {\n  const context = useContext(AccountsContext);\n  return {\n    account: context.nativeAccount as AccountInfo<Buffer>,\n  };\n}\n\nexport const getMultipleAccounts = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const result = await Promise.all(\n    chunks(keys, 99).map(chunk =>\n      getMultipleAccountsCore(connection, chunk, commitment),\n    ),\n  );\n\n  const array = result\n    .map(\n      a =>\n        a.array.map(acc => {\n          if (!acc) {\n            return undefined;\n          }\n\n          const { data, ...rest } = acc;\n          const obj = {\n            ...rest,\n            data: Buffer.from(data[0], 'base64'),\n          } as AccountInfo<Buffer>;\n          return obj;\n        }) as AccountInfo<Buffer>[],\n    )\n    .flat();\n  return { keys, array };\n};\n\nconst getMultipleAccountsCore = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const args = connection._buildArgs([keys], commitment, 'base64');\n\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\n  if (unsafeRes.error) {\n    throw new Error(\n      'failed to get info about account ' + unsafeRes.error.message,\n    );\n  }\n\n  if (unsafeRes.result.value) {\n    const array = unsafeRes.result.value as AccountInfo<string[]>[];\n    return { keys, array };\n  }\n\n  // TODO: fix\n  throw new Error();\n};\n\nexport function useMint(key?: string | PublicKey) {\n  const connection = useConnection();\n  const [mint, setMint] = useState<MintInfo>();\n\n  const id = typeof key === 'string' ? key : key?.toBase58();\n\n  useEffect(() => {\n    if (!id) {\n      return;\n    }\n\n    cache\n      .query(connection, id, MintParser)\n      .then(acc => setMint(acc.info as any))\n      .catch(err => console.log(err));\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === id) {\n        cache\n          .query(connection, id, MintParser)\n          .then(mint => setMint(mint.info as any));\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, id]);\n\n  return mint;\n}\n\nexport function useAccount(pubKey?: PublicKey) {\n  const connection = useConnection();\n  const [account, setAccount] = useState<TokenAccount>();\n\n  const key = pubKey?.toBase58();\n  useEffect(() => {\n    const query = async () => {\n      try {\n        if (!key) {\n          return;\n        }\n\n        const acc = await cache\n          .query(connection, key, TokenAccountParser)\n          .catch(err => console.log(err));\n        if (acc) {\n          setAccount(acc);\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    query();\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === key) {\n        query();\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, key]);\n\n  return account;\n}\n\n// TODO: expose in spl package\nexport const deserializeAccount = (data: Buffer) => {\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n};\n\n// TODO: expose in spl package\nexport const deserializeMint = (data: Buffer) => {\n  if (data.length !== MintLayout.span) {\n    throw new Error('Not a valid Mint');\n  }\n\n  const mintInfo = MintLayout.decode(data);\n\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n\n  return mintInfo as MintInfo;\n};\n","import { EventEmitter as Emitter } from 'eventemitter3';\n\nexport class CacheUpdateEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  parser: any;\n  isNew: boolean;\n  isActive: boolean;\n  constructor(id: string, isNew: boolean, parser: any, isActive: boolean) {\n    this.id = id;\n    this.parser = parser;\n    this.isNew = isNew;\n    this.isActive = isActive;\n  }\n}\n\nexport class CacheDeleteEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  constructor(id: string) {\n    this.id = id;\n  }\n}\n\nexport class MarketUpdateEvent {\n  static type = 'MarketUpdate';\n  ids: Set<string>;\n  constructor(ids: Set<string>) {\n    this.ids = ids;\n  }\n}\n\nexport class EventEmitter {\n  private emitter = new Emitter();\n\n  onMarket(callback: (args: MarketUpdateEvent) => void) {\n    this.emitter.on(MarketUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(MarketUpdateEvent.type, callback);\n  }\n\n  onCache(callback: (args: CacheUpdateEvent) => void) {\n    this.emitter.on(CacheUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(CacheUpdateEvent.type, callback);\n  }\n\n  raiseMarketUpdated(ids: Set<string>) {\n    this.emitter.emit(MarketUpdateEvent.type, new MarketUpdateEvent(ids));\n  }\n\n  raiseCacheUpdated(\n    id: string,\n    isNew: boolean,\n    parser: any,\n    isActive: boolean,\n  ) {\n    this.emitter.emit(\n      CacheUpdateEvent.type,\n      new CacheUpdateEvent(id, isNew, parser, isActive),\n    );\n  }\n\n  raiseCacheDeleted(id: string) {\n    this.emitter.emit(CacheDeleteEvent.type, new CacheDeleteEvent(id));\n  }\n}\n","import React from \"react\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { ENDPOINTS, useColorMode, useConnectionConfig } from \"../../contexts\";\nimport { notify, shortenAddress } from \"../../utils\";\nimport { CopyOutlined } from \"@ant-design/icons\";\nimport { ModalEnum, useModal, useWalletModal } from \"../../contexts\";\nimport {\n  Box,\n  Button,\n  Collapse,\n  Divider,\n  Drawer,\n  FormControl,\n  Link,\n  List,\n  ListItem,\n  ListItemText,\n  ListItemButton,\n  MenuItem,\n  Select,\n  Stack,\n} from \"@mui/material\";\nimport { useTheme } from \"@mui/material/styles\";\n\nimport AccountBalanceWalletIcon from '@mui/icons-material/AccountBalanceWallet';\nimport Brightness4Icon from \"@mui/icons-material/Brightness4\";\nimport Brightness7Icon from \"@mui/icons-material/Brightness7\";\nimport ExpandLess from '@mui/icons-material/ExpandLess';\nimport ExpandMore from '@mui/icons-material/ExpandMore';\n\nexport const Settings = ({ narrow }) => {\n  const { disconnect, publicKey } = useWallet();\n  const { setEndpoint, env, endpoint } = useConnectionConfig();\n  const { setVisible } = useWalletModal();\n  const open = React.useCallback(() => setVisible(true), [setVisible]);\n  const { setModal } = useModal();\n  const theme = useTheme();\n  const colorModeCtx = useColorMode();\n\n  const handleConnect = React.useCallback(() => {\n    setModal(ModalEnum.WALLET);\n    setVisible(true);\n  }, [setModal, setVisible]);\n\n  const connectedActions = [\n    {\n      click: async () => {\n        if (publicKey) {\n          await navigator.clipboard.writeText(publicKey.toBase58());\n          notify({\n            message: \"Wallet update\",\n            description: \"Address copied to clipboard\",\n          });\n        }\n      },\n      innerNarrow: \"Copy Address\",\n      inner: () => (\n        <React.Fragment>\n          <CopyOutlined />\n          {publicKey && shortenAddress(publicKey.toBase58())}\n        </React.Fragment>\n      ),\n    },\n    {\n      click: open,\n      inner: () => \"Change\\u00A0Wallet\",\n    },\n    {\n      click: () => disconnect().catch(),\n      inner: () => `Disconnect\\u00A0(${env})`,\n      expandedExtra: { // these are interepreted as props. TODO: specific types\n        color: \"error\" as any,\n        variant: \"contained\" as any,\n      }\n    },\n  ];\n\n  const [drawerOpen, setDrawerOpen] = React.useState(false);\n  const [envCollapseOpen, setEnvCollapseOpen] = React.useState(false);\n\n  const hackySkipSet = \"hackySkipSet\";\n  const toggleDrawer = (open) => (event) => {\n    if (event.type === 'keydown' && (event.key === 'Tab' || event.key === 'Shift')) {\n      return;\n    }\n\n    if (event.target.classList.contains(hackySkipSet)) {\n      return;\n    }\n\n    setDrawerOpen(open);\n  };\n\n  const drawerC = (inner) => {\n    return (\n      <React.Fragment>\n        <Button onClick={toggleDrawer(true)}>\n          <AccountBalanceWalletIcon />\n        </Button>\n        <Drawer\n          anchor=\"right\"\n          open={drawerOpen}\n          onClose={toggleDrawer(false)}\n        >\n          <Box\n            sx={{ width: 250 }}\n            role=\"presentation\"\n            onClick={toggleDrawer(false)}\n            onKeyDown={toggleDrawer(false)}\n          >\n            {inner}\n          </Box>\n        </Drawer>\n      </React.Fragment>\n    );\n  };\n\n  const themeSwitch = (\n    <Button\n      sx={{ ml: 1 }}\n      onClick={colorModeCtx.toggleColorMode}\n      color=\"inherit\"\n    >\n      {theme.palette.mode === \"dark\" ? (\n        <Brightness7Icon />\n      ) : (\n        <Brightness4Icon />\n      )}\n    </Button>\n  );\n\n  if (narrow) {\n    const listHead = (\n      <ListItem>\n        <ListItemText\n          primary=\"Wallet\"\n          primaryTypographyProps={{\n            fontSize: \"1.2rem\",\n            fontWeight: 'medium',\n            letterSpacing: 0,\n          }}\n        />\n      </ListItem>\n    );\n    return (\n      <React.Fragment>\n        {!publicKey && drawerC(\n          <List>\n            {listHead}\n            <Divider />\n            <ListItemButton\n              onClick={() => setEnvCollapseOpen(!envCollapseOpen)}\n              className={hackySkipSet}\n            >\n              Change Network\n              {envCollapseOpen ? <ExpandLess /> : <ExpandMore />}\n            </ListItemButton>\n            <Collapse in={envCollapseOpen} timeout=\"auto\" unmountOnExit>\n              <List component=\"div\" disablePadding>\n                {ENDPOINTS.map(p => (\n                  <ListItemButton\n                    selected={endpoint === p.endpoint}\n                    onClick={() => setEndpoint(p.endpoint)}\n                    key={p.name}\n                    sx={{ pl: 4 }}\n                    className={hackySkipSet}\n                  >\n                    {p.name}\n                  </ListItemButton>\n                ))}\n              </List>\n            </Collapse>\n            <ListItemButton onClick={handleConnect}>\n              Connect\n            </ListItemButton>\n          </List>\n        )}\n        {publicKey && drawerC(\n          <List>\n            {listHead}\n            <Divider />\n            {connectedActions.map((a, idx) => {\n              return (\n                <ListItemButton onClick={a.click} key={idx}>\n                  {a.innerNarrow || a.inner()}\n                </ListItemButton>\n              );\n            })}\n          </List>\n        )}\n        {themeSwitch}\n      </React.Fragment>\n    );\n  } else {\n    return (\n      <Stack\n        direction=\"row\"\n        spacing={2}\n        sx={{\n          display: \"flex\",\n          justifyContent: \"flex-end\",\n          alignItems: \"center\",\n          marginRight: \"36px\",\n        }}\n      >\n        {!publicKey && (\n          <React.Fragment>\n            <FormControl variant=\"standard\" style={{minWidth: \"10ch\"}}>\n              <Select\n                id=\"connected-env-select\"\n                onChange={(e) => { setEndpoint(e.target.value); }}\n                value={endpoint}\n              >\n                {ENDPOINTS.map(({ name, endpoint }) => (\n                  <MenuItem key={name} value={endpoint}>{name}</MenuItem>\n                ))}\n              </Select>\n            </FormControl>\n            <Link underline=\"none\">\n              <Button\n                variant=\"contained\"\n                onClick={handleConnect}\n              >\n                Connect\n              </Button>\n            </Link>\n          </React.Fragment>\n        )}\n        {publicKey && connectedActions.map((a, idx) => {\n            return (\n              <Button\n                key={idx}\n                variant=\"outlined\"\n                onClick={a.click}\n                {...a.expandedExtra}\n              >\n                {a.inner()}\n              </Button>\n            );\n          })\n        }\n        {themeSwitch}\n      </Stack>\n    );\n  }\n};\n","import { useTheme } from \"@mui/material\";\nimport React, { useContext } from \"react\";\n\nexport const ColorModeContext = React.createContext({});\n\nexport const ColorModeContextProvider = ({children=null as any }) => {\n  const [mode, setMode] = React.useState<'light' | 'dark'>('dark'); \n  const theme = useTheme();\n  const toggleColorMode = () => {\n    setMode((prevMode) => (prevMode === 'light' ? 'dark' : 'light'));\n  }\n  return (\n    <ColorModeContext.Provider\n      value={{\n        toggleColorMode,\n        mode,\n        theme,\n      }}\n    >\n      {children}\n    </ColorModeContext.Provider>\n  );\n};\n\nexport const useColorMode = (): any => {\n  const context = useContext(ColorModeContext);\n  return context;\n};\n","import {\n  Coder,\n} from \"@project-serum/anchor\"\n\nconst idl = require(\"./merkle_distributor.json\");\nexport const coder = new Coder(idl);\n\n","import React from 'react';\nimport { notification } from 'antd';\n// import Link from '../components/Link';\n\nexport function notify({\n  message = '',\n  description = undefined as any,\n  txid = '',\n  type = 'info',\n  placement = 'bottomLeft',\n}) {\n  if (txid) {\n    //   <Link\n    //     external\n    //     to={'https://explorer.solana.com/tx/' + txid}\n    //     style={{ color: '#0000ff' }}\n    //   >\n    //     View transaction {txid.slice(0, 8)}...{txid.slice(txid.length - 8)}\n    //   </Link>\n\n    description = <></>;\n  }\n  (notification as any)[type]({\n    message: <span style={{ color: 'black' }}>{message}</span>,\n    description: (\n      <span style={{ color: 'black', opacity: 0.5 }}>{description}</span>\n    ),\n    placement,\n    style: {\n      backgroundColor: 'white',\n    },\n  });\n}\n","import { PublicKey } from '@solana/web3.js';\nimport { BinaryReader, BinaryWriter } from 'borsh';\nimport base58 from 'bs58';\nimport { StringPublicKey } from './ids';\n\nexport const extendBorsh = () => {\n  (BinaryReader.prototype as any).readPubkey = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return new PublicKey(array);\n  };\n\n  (BinaryWriter.prototype as any).writePubkey = function (value: PublicKey) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(value.toBuffer());\n  };\n\n  (BinaryReader.prototype as any).readPubkeyAsString = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return base58.encode(array) as StringPublicKey;\n  };\n\n  (BinaryWriter.prototype as any).writePubkeyAsString = function (\n    value: StringPublicKey,\n  ) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(base58.decode(value));\n  };\n};\n\nextendBorsh();\n","import { PublicKey, AccountInfo } from '@solana/web3.js';\n\nexport type StringPublicKey = string;\n\nexport class LazyAccountInfoProxy<T> {\n  executable: boolean = false;\n  owner: StringPublicKey = '';\n  lamports: number = 0;\n\n  get data() {\n    //\n    return undefined as unknown as T;\n  }\n}\n\nexport interface LazyAccountInfo {\n  executable: boolean;\n  owner: StringPublicKey;\n  lamports: number;\n  data: [string, string];\n}\n\nconst PubKeysInternedMap = new Map<string, PublicKey>();\n\nexport const toPublicKey = (key: string | PublicKey) => {\n  if (typeof key !== 'string') {\n    return key;\n  }\n\n  let result = PubKeysInternedMap.get(key);\n  if (!result) {\n    result = new PublicKey(key);\n    PubKeysInternedMap.set(key, result);\n  }\n\n  return result;\n};\n\nexport interface PublicKeyStringAndAccount<T> {\n  pubkey: string;\n  account: AccountInfo<T>;\n}\n\nexport const WRAPPED_SOL_MINT = new PublicKey('So11111111111111111111111111111111111111112');\n\nexport const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n\nexport const BPF_UPGRADE_LOADER_ID = new PublicKey('BPFLoaderUpgradeab1e11111111111111111111111');\n\nexport const MEMO_ID = new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');\n\nexport const SYSTEM = new PublicKey('11111111111111111111111111111111');\n\nexport const TOKEN_METADATA_PROGRAM_ID = new PublicKey(\"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\");\n\nexport const CANDY_MACHINE_ID = new PublicKey('cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ');\n\nexport const GUMDROP_DISTRIBUTOR_ID = new PublicKey(\"561gX85SDR4hYF2L7P4LcvdXsWSxWuY7Z1yGgznPwSXG\");\n\nexport const GUMDROP_TEMPORAL_SIGNER = new PublicKey(\"MSv9H2sMceAzccBganUXwGq3GXgqYAstmZAbFDZYbAV\");\n\n","import React from \"react\";\nimport { RouteComponentProps, } from \"react-router-dom\";\nimport queryString from 'query-string';\n\nimport {\n  Box,\n  Button,\n  CircularProgress,\n  FormControl,\n  Link as HyperLink,\n  InputLabel,\n  MenuItem,\n  Select,\n  Stack,\n  Step,\n  StepLabel,\n  Stepper,\n  TextField,\n} from \"@mui/material\";\n\nimport {\n  useWallet,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  Connection as RPCConnection,\n  Keypair,\n  PublicKey,\n  SystemProgram,\n  SYSVAR_RENT_PUBKEY,\n  SYSVAR_CLOCK_PUBKEY,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport {\n  AccountLayout,\n  MintLayout,\n  Token,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport { sha256 } from \"js-sha256\";\nimport BN from 'bn.js';\nimport * as bs58 from \"bs58\";\n\nimport {\n  useConnection,\n} from \"../contexts\";\nimport {\n  CANDY_MACHINE_ID,\n  GUMDROP_DISTRIBUTOR_ID,\n  GUMDROP_TEMPORAL_SIGNER,\n  TOKEN_METADATA_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  getCandyMachine,\n  getCandyMachineAddress,\n  getEdition,\n  getEditionMarkerPda,\n  getMetadata,\n  notify,\n} from \"../utils\";\nimport { MerkleTree } from \"../utils/merkleTree\";\nimport {\n  explorerLinkFor,\n  sendSignedTransaction,\n} from \"../utils/transactions\";\nimport {\n  chunk,\n} from \"../utils/claimant\";\nimport { coder } from \"../utils/merkleDistributor\";\n\nconst walletKeyOrPda = async (\n  walletKey : PublicKey,\n  handle : string,\n  pin : BN | null,\n  seed : PublicKey,\n) : Promise<[PublicKey, Array<Buffer>]> => {\n  if (pin === null) {\n    try {\n      const key = new PublicKey(handle);\n      if (!key.equals(walletKey)) {\n        throw new Error(\"Claimant wallet handle does not match connected wallet\");\n      }\n      return [key, []];\n    } catch (err) {\n      throw new Error(`Invalid claimant wallet handle ${err}`);\n    }\n  } else {\n    const seeds = [\n      seed.toBuffer(),\n      Buffer.from(handle),\n      Buffer.from(pin.toArray(\"le\", 4)),\n    ];\n\n    const [claimantPda, ] = await PublicKey.findProgramAddress(\n      [\n        seeds[0],\n        ...chunk(seeds[1], 32),\n        seeds[2],\n      ],\n      GUMDROP_DISTRIBUTOR_ID\n    );\n    return [claimantPda, seeds];\n  }\n}\n\n\nconst buildMintClaim = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  distributorKey : PublicKey,\n  distributorInfo : any,\n  tokenAcc : string,\n  proof : Array<Buffer>,\n  handle : string,\n  amount : number,\n  index : number,\n  pin : BN | null,\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\n  let tokenAccKey: PublicKey;\n  try {\n    tokenAccKey = new PublicKey(tokenAcc);\n  } catch (err) {\n    throw new Error(`Invalid tokenAcc key ${err}`);\n  }\n  const distTokenAccount = await connection.getAccountInfo(tokenAccKey);\n  if (distTokenAccount === null) {\n    throw new Error(`Could not fetch distributor token account`);\n  }\n\n  const tokenAccountInfo = AccountLayout.decode(distTokenAccount.data);\n  const mint = new PublicKey(tokenAccountInfo.mint);\n\n  console.log(mint.toBase58());\n\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, mint);\n\n  // TODO: since it's in the PDA do we need it to be in the leaf?\n  const leaf = Buffer.from(\n    [...new BN(index).toArray(\"le\", 8),\n     ...secret.toBuffer(),\n     ...mint.toBuffer(),\n     ...new BN(amount).toArray(\"le\", 8),\n    ]\n  );\n\n  const matches = MerkleTree.verifyClaim(\n    leaf, proof, Buffer.from(distributorInfo.root)\n  );\n\n  if (!matches) {\n    throw new Error(\"Gumdrop merkle proof does not match\");\n  }\n\n  const [claimStatus, cbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"ClaimStatus\"),\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  const [walletTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      walletKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      mint.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n\n  const setup : Array<TransactionInstruction> = [];\n\n  if (await connection.getAccountInfo(walletTokenKey) === null) {\n    setup.push(Token.createAssociatedTokenAccountInstruction(\n        SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n        TOKEN_PROGRAM_ID,\n        mint,\n        walletTokenKey,\n        walletKey,\n        walletKey\n      ));\n  }\n\n  const temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\n      ? walletKey : distributorInfo.temporal;\n\n  const claimAirdrop = new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: distributorKey          , isSigner: false , isWritable: true  } ,\n          { pubkey: claimStatus             , isSigner: false , isWritable: true  } ,\n          { pubkey: tokenAccKey             , isSigner: false , isWritable: true  } ,\n          { pubkey: walletTokenKey          , isSigner: false , isWritable: true  } ,\n          { pubkey: temporalSigner          , isSigner: true  , isWritable: false } ,\n          { pubkey: walletKey               , isSigner: true  , isWritable: false } ,  // payer\n          { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_PROGRAM_ID        , isSigner: false , isWritable: false } ,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:claim\")).slice(0, 8),\n        ...new BN(cbump).toArray(\"le\", 1),\n        ...new BN(index).toArray(\"le\", 8),\n        ...new BN(amount).toArray(\"le\", 8),\n        ...secret.toBuffer(),\n        ...new BN(proof.length).toArray(\"le\", 4),\n        ...Buffer.concat(proof),\n      ])\n  })\n\n  return [[...setup, claimAirdrop], pdaSeeds, []];\n}\n\nconst buildCandyClaim = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  distributorKey : PublicKey,\n  distributorInfo : any,\n  candyConfig : string,\n  candyUUID : string,\n  proof : Array<Buffer>,\n  handle : string,\n  amount : number,\n  index : number,\n  pin : BN | null,\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\n\n  let configKey : PublicKey;\n  try {\n    configKey = new PublicKey(candyConfig);\n  } catch (err) {\n    throw new Error(`Invalid candy config key ${err}`);\n  }\n\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, configKey);\n\n  // TODO: since it's in the PDA do we need it to be in the leaf?\n  const leaf = Buffer.from(\n    [...new BN(index).toArray(\"le\", 8),\n     ...secret.toBuffer(),\n     ...configKey.toBuffer(),\n     ...new BN(amount).toArray(\"le\", 8),\n    ]\n  );\n\n  const matches = MerkleTree.verifyClaim(\n    leaf, proof, Buffer.from(distributorInfo.root)\n  );\n\n  if (!matches) {\n    throw new Error(\"Gumdrop merkle proof does not match\");\n  }\n\n  const [claimCount, cbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"ClaimCount\"),\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  const [distributorWalletKey, wbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"Wallet\"),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  // atm the contract has a special case for when the temporal key is defaulted\n  // (aka always passes temporal check)\n  // TODO: more flexible\n  let temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\n      ? walletKey : distributorInfo.temporal;\n\n  const setup : Array<TransactionInstruction> = [];\n\n  const claimCountAccount = await connection.getAccountInfo(claimCount);\n  let nftsAlreadyMinted = 0;\n  if (claimCountAccount === null) {\n  } else {\n    // TODO: subtract already minted?...\n    const claimAccountInfo = coder.accounts.decode(\n      \"ClaimCount\", claimCountAccount.data);\n    nftsAlreadyMinted = claimAccountInfo.count;\n    if (claimAccountInfo.claimant.equals(walletKey)) {\n      // we already proved this claim and verified the OTP once, contract knows\n      // that this wallet is OK\n      temporalSigner = walletKey;\n    } else {\n      // need to claim with the first wallet...\n      const claimantStr = claimAccountInfo.claimant.toBase58();\n      throw new Error(`This wallet does not match existing claimant ${claimantStr}`);\n    }\n  }\n\n  const nftsAvailable = amount;\n  if (nftsAlreadyMinted >= nftsAvailable) {\n    throw new Error(`Cannot mint another NFT. ${nftsAvailable} NFT(s) were originally allocated`\n      + (nftsAlreadyMinted > 0 ? ` and ${nftsAlreadyMinted} NFT(s) were already minted` : \"\"));\n  }\n\n\n  const [candyMachineKey, ] = await getCandyMachineAddress(configKey, candyUUID);\n  const candyMachine = await getCandyMachine(connection, candyMachineKey);\n  console.log(\"Candy Machine\", candyMachine);\n\n  const candyMachineMints : Array<Keypair> = [];\n\n  const [instrs, mint] = await buildSingleCandyMint(\n    connection,\n    walletKey,\n    distributorKey,\n    distributorWalletKey,\n    claimCount,\n    temporalSigner,\n    configKey,\n    candyMachineKey,\n    candyMachine.wallet,\n    Buffer.from([\n      ...new BN(wbump).toArray(\"le\", 1),\n      ...new BN(cbump).toArray(\"le\", 1),\n      ...new BN(index).toArray(\"le\", 8),\n      ...new BN(amount).toArray(\"le\", 8),\n      ...secret.toBuffer(),\n      ...new BN(proof.length).toArray(\"le\", 4),\n      ...Buffer.concat(proof),\n    ]),\n  );\n  candyMachineMints.push(mint);\n  setup.push(...instrs);\n\n  return [setup, pdaSeeds, candyMachineMints];\n}\n\nconst buildSingleCandyMint = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  distributorKey : PublicKey,\n  distributorWalletKey : PublicKey,\n  claimCount : PublicKey,\n  temporalSigner : PublicKey,\n  configKey : PublicKey,\n  candyMachineKey : PublicKey,\n  candyMachineWallet : PublicKey,\n  data : Buffer,\n) : Promise<[Array<TransactionInstruction>, Keypair]> => {\n  const candyMachineMint = Keypair.generate();\n  const candyMachineMetadata = await getMetadata(candyMachineMint.publicKey);\n  const candyMachineMaster = await getEdition(candyMachineMint.publicKey);\n\n  const setup : Array<TransactionInstruction> = [];\n  await createMintAndAccount(connection, walletKey, candyMachineMint.publicKey, setup);\n  setup.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: distributorKey            , isSigner: false , isWritable: true  } ,\n          { pubkey: distributorWalletKey      , isSigner: false , isWritable: true  } ,\n          { pubkey: claimCount                , isSigner: false , isWritable: true  } ,\n          { pubkey: temporalSigner            , isSigner: true  , isWritable: false } ,\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // payer\n\n          { pubkey: configKey                 , isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineKey           , isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineWallet        , isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineMint.publicKey, isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineMetadata      , isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineMaster        , isSigner: false , isWritable: true  } ,\n\n          { pubkey: SystemProgram.programId   , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_PROGRAM_ID          , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_METADATA_PROGRAM_ID , isSigner: false , isWritable: false } ,\n          { pubkey: CANDY_MACHINE_ID          , isSigner: false , isWritable: false } ,\n          { pubkey: SYSVAR_RENT_PUBKEY        , isSigner: false , isWritable: false } ,\n          { pubkey: SYSVAR_CLOCK_PUBKEY       , isSigner: false , isWritable: false } ,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:claim_candy\")).slice(0, 8),\n        ...data,\n      ])\n  }));\n\n  return [setup, candyMachineMint];\n}\n\nconst createMintAndAccount = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  mint : PublicKey,\n  setup : Array<TransactionInstruction>,\n) => {\n  const [walletTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      walletKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      mint.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n\n  setup.push(SystemProgram.createAccount({\n    fromPubkey: walletKey,\n    newAccountPubkey: mint,\n    space: MintLayout.span,\n    lamports:\n      await connection.getMinimumBalanceForRentExemption(\n        MintLayout.span,\n      ),\n    programId: TOKEN_PROGRAM_ID,\n  }));\n\n  setup.push(Token.createInitMintInstruction(\n    TOKEN_PROGRAM_ID,\n    mint,\n    0,\n    walletKey,\n    walletKey,\n  ));\n\n  setup.push(Token.createAssociatedTokenAccountInstruction(\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    mint,\n    walletTokenKey,\n    walletKey,\n    walletKey\n  ));\n\n  setup.push(Token.createMintToInstruction(\n    TOKEN_PROGRAM_ID,\n    mint,\n    walletTokenKey,\n    walletKey,\n    [],\n    1,\n  ));\n\n}\n\nconst buildEditionClaim = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  distributorKey : PublicKey,\n  distributorInfo : any,\n  masterMint : string,\n  edition : number,\n  proof : Array<Buffer>,\n  handle : string,\n  amount : number,\n  index : number,\n  pin : BN | null,\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\n\n  let masterMintKey : PublicKey;\n  try {\n    masterMintKey = new PublicKey(masterMint);\n  } catch (err) {\n    throw new Error(`Invalid master mint key ${err}`);\n  }\n\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, masterMintKey);\n\n  // should we assert that the amount is 1?\n  const leaf = Buffer.from(\n    [...new BN(index).toArray(\"le\", 8),\n     ...secret.toBuffer(),\n     ...masterMintKey.toBuffer(),\n     ...new BN(amount).toArray(\"le\", 8),\n     ...new BN(edition).toArray(\"le\", 8),\n    ]\n  );\n\n  const matches = MerkleTree.verifyClaim(\n    leaf, proof, Buffer.from(distributorInfo.root)\n  );\n\n  if (!matches) {\n    throw new Error(\"Gumdrop merkle proof does not match\");\n  }\n\n  const [claimCount, cbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"ClaimCount\"),\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  // atm the contract has a special case for when the temporal key is defaulted\n  // (aka always passes temporal check)\n  // TODO: more flexible\n  let temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\n      ? walletKey : distributorInfo.temporal;\n\n  const claimCountAccount = await connection.getAccountInfo(claimCount);\n  if (claimCountAccount !== null) {\n    throw new Error(`This edition was already claimed`);\n  }\n\n  const setup : Array<TransactionInstruction> = [];\n\n  const newMint = Keypair.generate();\n  const newMetadataKey = await getMetadata(newMint.publicKey);\n  const masterMetadataKey = await getMetadata(masterMintKey);\n  const newEdition = await getEdition(newMint.publicKey);\n  const masterEdition = await getEdition(masterMintKey);\n\n  await createMintAndAccount(connection, walletKey, newMint.publicKey, setup);\n\n  const [distributorTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      distributorKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      masterMintKey.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n\n  const editionMarkKey = await getEditionMarkerPda(masterMintKey, new BN(edition));\n\n  setup.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: distributorKey            , isSigner: false , isWritable: true  } ,\n          { pubkey: claimCount                , isSigner: false , isWritable: true  } ,\n          { pubkey: temporalSigner            , isSigner: true  , isWritable: false } ,\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // payer\n\n          { pubkey: newMetadataKey            , isSigner: false , isWritable: true  } ,\n          { pubkey: newEdition                , isSigner: false , isWritable: true  } ,\n          { pubkey: masterEdition             , isSigner: false , isWritable: true  } ,\n          { pubkey: newMint.publicKey         , isSigner: false , isWritable: true  } ,\n          { pubkey: editionMarkKey            , isSigner: false , isWritable: true  } ,\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // `newMint` auth\n          { pubkey: distributorTokenKey       , isSigner: false , isWritable: false } ,\n          { pubkey: walletKey                 , isSigner: false , isWritable: false } , // new update auth\n          { pubkey: masterMetadataKey         , isSigner: false , isWritable: false } ,\n          { pubkey: masterMintKey             , isSigner: false , isWritable: false } ,\n\n          { pubkey: SystemProgram.programId   , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_PROGRAM_ID          , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_METADATA_PROGRAM_ID , isSigner: false , isWritable: false } ,\n          { pubkey: SYSVAR_RENT_PUBKEY        , isSigner: false , isWritable: false } ,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:claim_edition\")).slice(0, 8),\n        ...new BN(cbump).toArray(\"le\", 1),\n        ...new BN(index).toArray(\"le\", 8),\n        ...new BN(amount).toArray(\"le\", 8),\n        ...new BN(edition).toArray(\"le\", 8),\n        ...secret.toBuffer(),\n        ...new BN(proof.length).toArray(\"le\", 4),\n        ...Buffer.concat(proof),\n      ])\n  }));\n\n  return [setup, pdaSeeds, [newMint]];\n}\n\nconst fetchDistributor = async (\n  connection : RPCConnection,\n  distributorStr : string,\n) => {\n  let key;\n  try {\n    key = new PublicKey(distributorStr);\n  } catch (err) {\n    throw new Error(`Invalid distributor key ${err}`);\n  }\n  const account = await connection.getAccountInfo(key);\n  if (account === null) {\n    throw new Error(`Could not fetch distributor ${distributorStr}`);\n  }\n  if (!account.owner.equals(GUMDROP_DISTRIBUTOR_ID)) {\n    const ownerStr = account.owner.toBase58();\n    throw new Error(`Invalid distributor owner ${ownerStr}`);\n  }\n  const info = coder.accounts.decode(\"MerkleDistributor\", account.data);\n  return [key, info];\n};\n\nconst fetchNeedsTemporalSigner = async (\n  connection : RPCConnection,\n  distributorStr : string,\n  indexStr : string,\n  claimMethod : string,\n) => {\n  const [key, info] = await fetchDistributor(connection, distributorStr);\n  if (!info.temporal.equals(GUMDROP_TEMPORAL_SIGNER)) {\n    // default pubkey or program itself (distribution through wallets)\n    return false;\n  } else if (claimMethod === \"candy\") {\n    const [claimCount, ] = await PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"ClaimCount\"),\n        Buffer.from(new BN(Number(indexStr)).toArray(\"le\", 8)),\n        key.toBuffer(),\n      ],\n      GUMDROP_DISTRIBUTOR_ID\n    );\n    // if someone (maybe us) has already claimed this, the contract will\n    // not check the existing temporal signer anymore since presumably\n    // they have already verified the OTP. So we need to fetch the temporal\n    // signer if it is null\n    const claimCountAccount = await connection.getAccountInfo(claimCount);\n    return claimCountAccount === null;\n  } else {\n    // default to need one\n    return true;\n  }\n};\n\nexport type ClaimProps = {};\n\nexport const Claim = (\n  props : RouteComponentProps<ClaimProps>,\n) => {\n  const connection = useConnection();\n  const wallet = useWallet();\n\n  let params = queryString.parse(props.location.search);\n  const [distributor, setDistributor] = React.useState(params.distributor as string || \"\");\n  const [claimMethod, setClaimMethod] = React.useState(\n        params.tokenAcc ? \"transfer\"\n      : params.config   ? \"candy\"\n      : params.master   ? \"edition\"\n      :                   \"\");\n  const [tokenAcc, setTokenAcc] = React.useState(params.tokenAcc as string || \"\");\n  const [candyConfig, setCandyConfig] = React.useState(params.config as string || \"\");\n  const [candyUUID, setCandyUUID] = React.useState(params.uuid as string || \"\");\n  const [masterMint, setMasterMint] = React.useState(params.master as string || \"\");\n  const [editionStr, setEditionStr] = React.useState(params.edition as string || \"\");\n  const [handle, setHandle] = React.useState(params.handle as string || \"\");\n  const [amountStr, setAmount] = React.useState(params.amount as string || \"\");\n  const [indexStr, setIndex] = React.useState(params.index as string || \"\");\n  const [pinStr, setPin] = React.useState(params.pin as string || \"\");\n  const [proofStr, setProof] = React.useState(params.proof as string || \"\");\n\n  const allFieldsPopulated =\n    distributor.length > 0\n    && ( claimMethod === \"transfer\" ? tokenAcc.length > 0\n       : claimMethod === \"candy\"    ? candyConfig.length > 0 && candyUUID.length > 0\n       : claimMethod === \"edition\"  ? masterMint.length > 0 && editionStr.length > 0\n       :                              false\n       )\n    && handle.length > 0\n    && amountStr.length > 0\n    && indexStr.length > 0;\n    // NB: pin can be empty if handle is a public-key and we are claiming through wallets\n    // NB: proof can be empty!\n\n  const [editable, setEditable] = React.useState(!allFieldsPopulated);\n\n  // temporal verification\n  const [transaction, setTransaction] = React.useState<Transaction | null>(null);\n  const [OTPStr, setOTPStr] = React.useState(\"\");\n\n  // async computed\n  const [asyncNeedsTemporalSigner, setNeedsTemporalSigner] = React.useState<boolean>(true);\n\n  React.useEffect(() => {\n    const wrap = async () => {\n      try {\n        setNeedsTemporalSigner(await fetchNeedsTemporalSigner(\n          connection, distributor, indexStr, claimMethod));\n      } catch {\n        // TODO: log?\n      }\n    };\n    wrap();\n  }, [connection, distributor, indexStr, claimMethod]);\n\n  const lambdaAPIEndpoint = \"https://n82bm4ts81.execute-api.us-east-2.amazonaws.com/send-OTP\";\n\n  const skipAWSWorkflow = false;\n\n  const sendOTP = async (e : React.SyntheticEvent) => {\n    e.preventDefault();\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const index = Number(indexStr);\n    const amount = Number(amountStr);\n    let pin : BN | null = null;\n\n    if (isNaN(amount)) {\n      throw new Error(`Could not parse amount ${amountStr}`);\n    }\n    if (isNaN(index)) {\n      throw new Error(`Could not parse index ${indexStr}`);\n    }\n    if (params.pin !== \"NA\") {\n      try {\n        pin = new BN(pinStr);\n      } catch (err) {\n        throw new Error(`Could not parse pin ${pinStr}: ${err}`);\n      }\n    }\n\n    // TODO: use cached?\n    const [distributorKey, distributorInfo] =\n        await fetchDistributor(connection, distributor);\n\n    console.log(\"Distributor\", distributorInfo);\n\n    const proof = proofStr === \"\" ? [] : proofStr.split(\",\").map(b => {\n      const ret = Buffer.from(bs58.decode(b))\n      if (ret.length !== 32)\n        throw new Error(`Invalid proof hash length`);\n      return ret;\n    });\n\n    let instructions, pdaSeeds, extraSigners;\n    if (claimMethod === \"candy\") {\n      console.log(\"Building candy claim\");\n      [instructions, pdaSeeds, extraSigners] = await buildCandyClaim(\n        connection, wallet.publicKey, distributorKey, distributorInfo,\n        candyConfig, candyUUID,\n        proof, handle, amount, index, pin\n      );\n    } else if (claimMethod === \"transfer\") {\n      [instructions, pdaSeeds, extraSigners] = await buildMintClaim(\n        connection, wallet.publicKey, distributorKey, distributorInfo,\n        tokenAcc,\n        proof, handle, amount, index, pin\n      );\n    } else if (claimMethod === \"edition\") {\n      const edition = Number(editionStr);\n      if (isNaN(edition)) {\n        throw new Error(`Could not parse edition ${editionStr}`);\n      }\n      [instructions, pdaSeeds, extraSigners] = await buildEditionClaim(\n        connection, wallet.publicKey, distributorKey, distributorInfo,\n        masterMint, edition,\n        proof, handle, amount, index, pin\n      );\n    } else {\n      throw new Error(`Unknown claim method ${claimMethod}`);\n    }\n\n    // NB: if we're claiming through wallets then pdaSeeds should be empty\n    // since the secret is the wallet key (which is also a signer)\n    if (pin === null && pdaSeeds.length > 0) {\n      throw new Error(`Internal error: PDA generated when distributing to wallet directly`);\n    }\n\n    let transaction = new Transaction({\n      feePayer: wallet.publicKey,\n      recentBlockhash: (await connection.getRecentBlockhash(\"singleGossip\")).blockhash,\n    });\n\n    const signers = new Set<PublicKey>();\n    for (const instr of instructions) {\n      transaction.add(instr);\n      for (const key of instr.keys)\n        if (key.isSigner)\n          signers.add(key.pubkey);\n    }\n    console.log(`Expecting the following signers: ${[...signers].map(s => s.toBase58())}`);\n    transaction.setSigners(...signers);\n\n    if (extraSigners.length > 0) {\n      transaction.partialSign(...extraSigners);\n    }\n\n    const txnNeedsTemporalSigner =\n        transaction.signatures.some(s => s.publicKey.equals(GUMDROP_TEMPORAL_SIGNER));\n    if (txnNeedsTemporalSigner && !skipAWSWorkflow) {\n      const params = {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          method: \"send\",\n          transaction: bs58.encode(transaction.serializeMessage()),\n          seeds: pdaSeeds,\n        }),\n      };\n\n      const response = await fetch(lambdaAPIEndpoint, params);\n      console.log(response);\n\n      if (response.status !== 200) {\n        throw new Error(`Failed to send AWS OTP`);\n      }\n\n      let data;\n      try {\n        data = await response.json();\n      } catch {\n        throw new Error(`Could not parse AWS OTP response`);\n      }\n\n      console.log(\"AWS OTP response data:\", data);\n\n      if (!data.MessageId) {\n        throw new Error(`Failed to send AWS OTP`);\n      }\n\n      notify({\n        message: \"OTP sent\",\n        description: `Please check ${handle} for a OTP`,\n      });\n    }\n\n    return transaction;\n  };\n\n  const verifyOTP = async (\n    e : React.SyntheticEvent,\n    transaction : Transaction | null,\n  ) => {\n    e.preventDefault();\n\n    if (!transaction) {\n      throw new Error(`Transaction not available for OTP verification`);\n    }\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const txnNeedsTemporalSigner =\n        transaction.signatures.some(s => s.publicKey.equals(GUMDROP_TEMPORAL_SIGNER));\n    if (txnNeedsTemporalSigner && !skipAWSWorkflow) {\n      // TODO: distinguish between OTP failure and transaction-error. We can try\n      // again on the former but not the latter\n      const OTP = Number(OTPStr);\n      if (isNaN(OTP) || OTPStr.length === 0) {\n        throw new Error(`Could not parse OTP ${OTPStr}`);\n      }\n\n      const params = {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        FunctionName: \"send-OTP\",\n        body: JSON.stringify({\n          method: \"verify\",\n          otp: OTP,\n          handle: handle,  // TODO?\n        }),\n      };\n\n      const response = await fetch(lambdaAPIEndpoint, params);\n      console.log(response);\n\n      if (response.status !== 200) {\n        const blob = JSON.stringify(response);\n        throw new Error(`Failed to verify AWS OTP. ${blob}`);\n      }\n\n      let data;\n      try {\n        data = await response.json();\n      } catch {\n        throw new Error(`Could not parse AWS OTP verification response`);\n      }\n\n      console.log(\"AWS verify response data:\", data);\n\n      let sig;\n      try {\n        sig = bs58.decode(data);\n      } catch {\n        throw new Error(`Could not decode transaction signature ${data.body}`);\n      }\n\n      transaction.addSignature(GUMDROP_TEMPORAL_SIGNER, sig);\n    }\n\n    let fullySigned;\n    try {\n      fullySigned = await wallet.signTransaction(transaction);\n    } catch {\n      throw new Error(\"Failed to sign transaction\");\n    }\n\n    const claimResult = await sendSignedTransaction({\n      connection,\n      signedTransaction: fullySigned,\n    });\n\n    console.log(claimResult);\n    notify({\n      message: \"Claim succeeded\",\n      description: (\n        <HyperLink href={explorerLinkFor(claimResult.txid, connection)}>\n          View transaction on explorer\n        </HyperLink>\n      ),\n    });\n    setTransaction(null);\n    try {\n      setNeedsTemporalSigner(await fetchNeedsTemporalSigner(\n        connection, distributor, indexStr, claimMethod));\n    } catch {\n      // TODO: log?\n    }\n  };\n\n  const [loading, setLoading] = React.useState(false);\n  const loadingProgress = () => (\n    <CircularProgress\n      size={24}\n      sx={{\n        position: 'absolute',\n        top: '50%',\n        left: '50%',\n        marginTop: '-12px',\n        marginLeft: '-12px',\n      }}\n    />\n  );\n\n  const verifyOTPC = (onClick) => (\n    <React.Fragment>\n      <TextField\n        id=\"otp-text-field\"\n        label=\"OTP\"\n        value={OTPStr}\n        onChange={(e) => setOTPStr(e.target.value)}\n      />\n      <Box />\n\n      <Box sx={{ position: \"relative\" }}>\n      <Button\n        disabled={!wallet.connected || !OTPStr || loading}\n        variant=\"contained\"\n        color=\"success\"\n        style={{ width: \"100%\" }}\n        onClick={(e) => {\n          setLoading(true);\n          const wrap = async () => {\n            try {\n              await verifyOTP(e, transaction);\n              setLoading(false);\n              onClick();\n            } catch (err) {\n              notify({\n                message: \"Claim failed\",\n                description: `${err}`,\n              });\n              setLoading(false);\n            }\n          };\n          wrap();\n        }}\n      >\n        Claim Gumdrop\n      </Button>\n      {loading && loadingProgress()}\n      </Box>\n    </React.Fragment>\n  );\n\n  const claimData = (claimMethod) => {\n    if (claimMethod === \"candy\") {\n      return (\n        <React.Fragment>\n          <TextField\n            id=\"config-text-field\"\n            label=\"Candy Config\"\n            value={candyConfig}\n            onChange={e => setCandyConfig(e.target.value)}\n            disabled={!editable}\n          />\n          <TextField\n            id=\"config-uuid-text-field\"\n            label=\"Candy UUID\"\n            value={candyUUID}\n            onChange={e => setCandyUUID(e.target.value)}\n            disabled={!editable}\n          />\n        </React.Fragment>\n      );\n    } else if (claimMethod === \"transfer\") {\n      return (\n        <React.Fragment>\n          <TextField\n            id=\"token-acc-text-field\"\n            label=\"Source Token Account\"\n            value={tokenAcc}\n            onChange={(e) => setTokenAcc(e.target.value)}\n            disabled={!editable}\n          />\n        </React.Fragment>\n      );\n    } else if (claimMethod === \"edition\") {\n      return (\n        <React.Fragment>\n          <TextField\n            id=\"master-mint-text-field\"\n            label=\"Master Mint\"\n            value={masterMint}\n            onChange={(e) => setMasterMint(e.target.value)}\n            disabled={!editable}\n          />\n          <TextField\n            id=\"edition-text-field\"\n            label=\"Edition\"\n            value={editionStr}\n            onChange={(e) => setEditionStr(e.target.value)}\n            disabled={!editable}\n          />\n        </React.Fragment>\n      );\n    }\n  };\n\n  const populateClaimC = (onClick) => (\n    <React.Fragment>\n      <TextField\n        id=\"distributor-text-field\"\n        label=\"Distributor\"\n        value={distributor}\n        onChange={(e) => setDistributor(e.target.value)}\n        disabled={!editable}\n      />\n      <FormControl fullWidth>\n        <InputLabel\n          id=\"claim-method-label\"\n          disabled={!editable}\n        >\n          Claim Method\n        </InputLabel>\n        <Select\n          labelId=\"claim-method-label\"\n          id=\"claim-method-select\"\n          value={claimMethod}\n          label=\"Claim Method\"\n          onChange={(e) => { setClaimMethod(e.target.value); }}\n          style={{textAlign: \"left\"}}\n          disabled={!editable}\n        >\n          <MenuItem value={\"transfer\"}>Token Transfer</MenuItem>\n          <MenuItem value={\"candy\"}>Candy Machine</MenuItem>\n          <MenuItem value={\"edition\"}>Limited Edition</MenuItem>\n        </Select>\n      </FormControl>\n      {claimMethod !== \"\" && claimData(claimMethod)}\n      {claimMethod !== \"edition\" && <TextField\n        id=\"amount-text-field\"\n        label=\"Amount\"\n        value={amountStr}\n        onChange={(e) => setAmount(e.target.value)}\n        disabled={!editable}\n      />}\n      <TextField\n        id=\"handle-text-field\"\n        label=\"Handle\"\n        value={handle}\n        onChange={(e) => setHandle(e.target.value)}\n        disabled={!editable}\n      />\n      <TextField\n        id=\"index-text-field\"\n        label=\"Index\"\n        value={indexStr}\n        onChange={(e) => setIndex(e.target.value)}\n        disabled={!editable}\n      />\n      {params.pin !== \"NA\" && <TextField\n        id=\"pin-text-field\"\n        label=\"Pin\"\n        value={pinStr}\n        onChange={(e) => setPin(e.target.value)}\n        disabled={!editable}\n      />}\n      <TextField\n        id=\"proof-text-field\"\n        label=\"Proof\"\n        multiline\n        value={proofStr}\n        onChange={(e) => setProof(e.target.value)}\n        disabled={!editable}\n      />\n      <Button\n        color=\"info\"\n        onClick={(e) => setEditable(!editable)}\n      >\n        {!editable ? \"Edit Claim\" : \"Stop Editing\"}\n      </Button>\n      <Box />\n\n      <Box sx={{ position: \"relative\" }}>\n      <Button\n        disabled={!wallet.connected || !allFieldsPopulated || loading}\n        variant=\"contained\"\n        style={{ width: \"100%\" }}\n        color={asyncNeedsTemporalSigner ? \"primary\" : \"success\"}\n        onClick={(e) => {\n          setLoading(true);\n          const wrap = async () => {\n            try {\n              const needsTemporalSigner = await fetchNeedsTemporalSigner(\n                  connection, distributor, indexStr, claimMethod);\n              const transaction = await sendOTP(e);\n              if (!needsTemporalSigner) {\n                await verifyOTP(e, transaction);\n              } else {\n                setTransaction(transaction);\n              }\n              setLoading(false);\n              onClick();\n            } catch (err) {\n              notify({\n                message: \"Claim failed\",\n                description: `${err}`,\n              });\n              setLoading(false);\n            }\n          };\n          wrap();\n        }}\n      >\n        {asyncNeedsTemporalSigner ? \"Next\" : \"Claim Gumdrop\"}\n      </Button>\n      {loading && loadingProgress()}\n      </Box>\n    </React.Fragment>\n  );\n\n  const steps = [\n    { name: \"Populate Claim\", inner: populateClaimC },\n  ];\n  if (asyncNeedsTemporalSigner) {\n    steps.push(\n    { name: \"Verify OTP\"    , inner: verifyOTPC     }\n    );\n  }\n\n  // TODO: better interaction between setting `asyncNeedsTemporalSigner` and\n  // the stepper... this is pretty jank\n  const [activeStep, setActiveStep] = React.useState(0);\n  const stepToUse = Math.min(activeStep, steps.length - 1);\n\n  const handleNext = () => {\n    // return to start if going past the end (claim succeeded)\n    setActiveStep(prev => {\n      if (prev === steps.length - 1) {\n        return 0;\n      } else {\n        return prev + 1;\n      }\n    });\n  };\n  const handleBack = () => {\n    setActiveStep(prev => prev - 1);\n  };\n\n  const stepper = (\n    <React.Fragment>\n      <Stepper activeStep={stepToUse}>\n        {steps.map((s, index) => {\n          return (\n            <Step key={s.name}>\n              <StepLabel>{s.name}</StepLabel>\n            </Step>\n          );\n        })}\n      </Stepper>\n      <Box />\n    </React.Fragment>\n  );\n\n  return (\n    <Stack spacing={2}>\n      {asyncNeedsTemporalSigner && stepper}\n      {steps[stepToUse].inner(handleNext)}\n      {stepToUse > 0 && (\n        <Button\n          color=\"info\"\n          onClick={handleBack}\n        >\n          Back\n        </Button>\n      )}\n    </Stack>\n  );\n};\n\n","import { WalletAdapter, WalletError } from \"@solana/wallet-adapter-base\";\nimport {\n  useWallet,\n  WalletProvider as BaseWalletProvider,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  getLedgerWallet,\n  getMathWallet,\n  getPhantomWallet,\n  getSolflareWallet,\n  getSolletWallet,\n  getSolongWallet,\n  getTorusWallet,\n} from \"@solana/wallet-adapter-wallets\";\nimport { Button } from \"antd\";\nimport React, {\n  createContext,\n  FC,\n  ReactNode,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\nimport { notify } from \"../../utils\";\nimport { DefaultModal } from \"../../components\";\n\nimport \"./wallet.less\";\n\nexport interface WalletModalContextState {\n  visible: boolean;\n  setVisible: (open: boolean) => void;\n}\n\nexport const WalletModalContext = createContext<WalletModalContextState>(\n  {} as WalletModalContextState\n);\n\nexport function useWalletModal(): WalletModalContextState {\n  return useContext(WalletModalContext);\n}\n\nexport const WalletModal: FC = () => {\n  const { wallets, wallet: selected, select } = useWallet();\n  const { visible, setVisible } = useWalletModal();\n  const [ , setShowWallets] = useState(false);\n  const close = useCallback(() => {\n    setVisible(false);\n    setShowWallets(false);\n  }, [setVisible, setShowWallets]);\n\n  return (\n    <DefaultModal visible={visible} onCancel={close}>\n      <div\n        style={{\n          background:\n            \"linear-gradient(180deg, #D329FC 0%, #8F6DDE 49.48%, #19E6AD 100%)\",\n          borderRadius: 36,\n          width: 50,\n          height: 50,\n          textAlign: \"center\",\n          verticalAlign: \"middle\",\n          fontWeight: 700,\n          fontSize: \"1.3rem\",\n          lineHeight: 2.4,\n          marginBottom: 10,\n        }}\n      ></div>\n      <h2\n        style={{\n          color: \"white\",\n          fontWeight: \"bold\",\n          fontSize: \"1.2rem\",\n        }}\n      >\n        {selected ? \"Change provider\" : \"\"}\n      </h2>\n      <p style={{ color: \"white\", fontSize: \"1rem\"}}>\n        {selected\n          ? \"Choose from the following options:\"\n          : \"Please sign into your wallet\"}\n      </p>\n\n      <br />\n      {wallets.map((wallet) => {\n        return (\n          <Button\n            key={wallet.name}\n            size=\"large\"\n            type={wallet === selected ? \"primary\" : \"ghost\"}\n            onClick={() => {\n              select(wallet.name);\n              close();\n            }}\n            icon={\n              <img\n                alt={`${wallet.name}`}\n                width={20}\n                height={20}\n                src={wallet.icon}\n                style={{ marginRight: 30, float: \"left\" }}\n              />\n            }\n            style={{\n              display: \"block\",\n              width: \"100%\",\n              textAlign: \"left\",\n              marginBottom: 8,\n              color: \"white\",\n            }}\n          >\n            {wallet.name}\n          </Button>\n        );\n      })}\n    </DefaultModal>\n  );\n};\n\nexport const WalletModalProvider: FC<{ children: ReactNode }> = ({\n  children,\n}) => {\n  const { publicKey } = useWallet();\n  const [connected, setConnected] = useState(!!publicKey);\n  const [visible, setVisible] = useState(false);\n\n  useEffect(() => {\n    if (publicKey) {\n      const base58 = publicKey.toBase58();\n      const keyToDisplay =\n        base58.length > 20\n          ? `${base58.substring(0, 7)}.....${base58.substring(\n              base58.length - 7,\n              base58.length\n            )}`\n          : base58;\n\n      notify({\n        message: \"Wallet update\",\n        description: \"Connected to wallet \" + keyToDisplay,\n      });\n    }\n  }, [publicKey]);\n\n  useEffect(() => {\n    if (!publicKey && connected) {\n      notify({\n        message: \"Wallet update\",\n        description: \"Disconnected from wallet\",\n      });\n    }\n    setConnected(!!publicKey);\n  }, [publicKey, connected, setConnected]);\n\n  return (\n    <WalletModalContext.Provider\n      value={{\n        visible,\n        setVisible,\n      }}\n    >\n      {children}\n      <WalletModal />\n    </WalletModalContext.Provider>\n  );\n};\n\nexport const WalletProvider: FC<{ children: ReactNode }> = ({ children }) => {\n  const wallets = useMemo(\n    () => [\n      getPhantomWallet(),\n      getSolflareWallet(),\n      getTorusWallet({\n        options: {\n          clientId:\n            \"BEB_D44HovHuXH0Ace97QVqSu1ahCKndjpGhzhVcMy_9XmDTbHyqTbzQTufcyaN0kFwtlVbfPzJwpJXg94gWJqE\",\n          uxMode: \"redirect\",\n        },\n      }),\n      getLedgerWallet(),\n      getSolongWallet(),\n      getMathWallet(),\n      getSolletWallet(),\n    ],\n    []\n  );\n\n  const onError = useCallback((error: WalletError) => {\n    console.error(error);\n    notify({\n      message: \"Wallet error\",\n      description: JSON.stringify(error, Object.getOwnPropertyNames(error)),\n    });\n  }, []);\n\n  return (\n    <BaseWalletProvider wallets={wallets} onError={onError} autoConnect>\n      <WalletModalProvider>{children}</WalletModalProvider>\n    </BaseWalletProvider>\n  );\n};\n\nexport type WalletSigner = Pick<\n  WalletAdapter,\n  \"publicKey\" | \"signTransaction\" | \"signAllTransactions\"\n>;\n","export default __webpack_public_path__ + \"static/media/wallet.c746d144.less\";","import React, { useState, useContext, useCallback } from 'react';\n\nimport { WalletModal } from './WalletContext/WalletContext';\n\nexport enum ModalEnum {\n  WALLET = 'wallet',\n}\n\ntype ModalContextProps = {\n  setModal: (modal: ModalEnum | undefined) => void;\n  removeModal: () => void;\n};\n\nexport const ModalContext = React.createContext<ModalContextProps>({\n  setModal: () => null,\n  removeModal: () => null,\n});\n\nexport const ModalProvider: React.FC = ({ children }) => {\n  const [modal, setModal] = useState<ModalEnum | undefined>(undefined);\n\n  const removeModal = useCallback(() => {\n    setModal(undefined);\n  }, [setModal]);\n\n  return (\n    <ModalContext.Provider\n      value={{\n        setModal,\n        removeModal,\n      }}\n    >\n      {children}\n      {modal === ModalEnum.WALLET && <WalletModal />}\n    </ModalContext.Provider>\n  );\n};\n\nexport const useModal = (): ModalContextProps => {\n  const context = useContext(ModalContext);\n  if (context === undefined) {\n    throw new Error('useModal must be used within a ModalProvider');\n  }\n  return context;\n};\n","import React from \"react\";\nimport {\n  Link,\n} from \"react-router-dom\";\nimport {\n  Box,\n  Button,\n  Divider,\n  Drawer,\n  List,\n  ListItem,\n  ListItemText,\n  Stack,\n} from \"@mui/material\";\nimport HomeIcon from '@mui/icons-material/Home';\nimport MenuIcon from '@mui/icons-material/Menu';\n\nimport { Settings } from \"../Settings\";\n\nexport const Header = ({ narrow }) => {\n  const navs = [\n    {\n      href: `${window.location.pathname}`,\n      innerNarrow: \"About\",\n      inner: <HomeIcon />,\n    },\n    {\n      href: `${window.location.pathname}create`,\n      inner: \"Create\",\n    },\n    {\n      href: `${window.location.pathname}claim`,\n      inner: \"Claim\",\n    },\n    {\n      href: `${window.location.pathname}close`,\n      inner: \"Close\",\n    },\n  ];\n\n  const [drawerOpen, setDrawerOpen] = React.useState(false);\n\n  const toggleDrawer = (open) => (event) => {\n    if (event.type === 'keydown' && (event.key === 'Tab' || event.key === 'Shift')) {\n      return;\n    }\n\n    setDrawerOpen(open);\n  };\n\n  return (\n    <Box\n      sx={{\n        height: \"52px\",\n        display: \"flex\",\n        bgcolor: \"action.disabledBackground\",\n        overflow: \"auto\",\n      }}\n    >\n      {narrow\n        ? (\n          <React.Fragment>\n            <Button onClick={toggleDrawer(true)}>\n              <MenuIcon />\n            </Button>\n            <Drawer\n              open={drawerOpen}\n              onClose={toggleDrawer(false)}\n            >\n              <Box\n                sx={{ width: 250 }}\n                role=\"presentation\"\n                onClick={toggleDrawer(false)}\n                onKeyDown={toggleDrawer(false)}\n              >\n                <List>\n                  <ListItem>\n                    <ListItemText\n                      primary=\"Gumdrop\"\n                      primaryTypographyProps={{\n                        fontSize: \"1.2rem\",\n                        fontWeight: 'medium',\n                        letterSpacing: 0,\n                      }}\n                    />\n                  </ListItem>\n                  <Divider />\n                  {navs.map((nav, idx) => {\n                    return (\n                      <ListItem key={idx}>\n                        <Link to={nav.href}>\n                          {nav.innerNarrow || nav.inner}\n                        </Link>\n                      </ListItem>\n                    );\n                  })}\n                </List>\n              </Box>\n            </Drawer>\n          </React.Fragment>\n        )\n        : (\n          <Stack\n            direction=\"row\"\n            spacing={2}\n            sx={{\n              display: \"flex\",\n              justifyContent: \"flex-start\",\n              alignItems: \"center\",\n              marginLeft: \"36px\",\n            }}\n          >\n            {navs.map((nav, idx) => {\n              return (\n                <Link to={nav.href} key={idx}>\n                  <Button variant=\"outlined\" style={{minWidth:0}}>\n                    {nav.inner}\n                  </Button>\n                </Link>\n              );\n            })}\n          </Stack>\n        )\n      }\n      <Box sx={{flexGrow: 1, minWidth: \"36px\"}}></Box>\n      <Settings narrow={narrow}/>\n    </Box>\n  );\n};\n","import React from \"react\";\n\nimport {\n  Button,\n  FormControl,\n  InputLabel,\n  Link as HyperLink,\n  MenuItem,\n  Stack,\n  Select,\n  TextField,\n} from \"@mui/material\";\n\nimport {\n  useWallet,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  Keypair,\n} from \"@solana/web3.js\";\n\nimport {\n  useConnection,\n  Connection,\n} from \"../contexts\";\nimport {\n  notify,\n} from \"../utils\";\nimport {\n  closeGumdrop,\n} from \"../utils/claimant\";\nimport {\n  explorerLinkFor,\n} from \"../utils/transactions\";\n\nexport const Close = () => {\n  const connection = useConnection();\n  const wallet = useWallet();\n\n  const [baseKey, setBaseKey] = React.useState(\"\");\n  const [claimMethod, setClaimMethod] = React.useState(localStorage.getItem(\"claimMethod\") || \"transfer\");\n  const [candyConfig, setCandyConfig] = React.useState(localStorage.getItem(\"candyConfig\") || \"\");\n  const [candyUUID, setCandyUUID] = React.useState(localStorage.getItem(\"candyUUID\") || \"\");\n  const [masterMint, setMasterMint] = React.useState(localStorage.getItem(\"masterMint\") || \"\");\n\n  const submit = async (e : React.SyntheticEvent) => {\n    e.preventDefault();\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const base = Keypair.fromSecretKey(\n      new Uint8Array(JSON.parse(baseKey)));\n\n    const instructions = await closeGumdrop(\n      connection,\n      wallet.publicKey,\n      base,\n      claimMethod,\n      candyConfig,\n      candyUUID,\n      masterMint,\n    );\n\n    const closeResult = await Connection.sendTransactionWithRetry(\n      connection,\n      wallet,\n      instructions,\n      [base]\n    );\n\n    console.log(closeResult);\n    if (typeof closeResult === \"string\") {\n      notify({\n        message: \"Close failed\",\n        description: closeResult,\n      });\n    } else {\n      notify({\n        message: \"Close succeeded\",\n        description: (\n          <HyperLink href={explorerLinkFor(closeResult.txid, connection)}>\n            View transaction on explorer\n          </HyperLink>\n        ),\n      });\n    }\n  };\n\n  const claimData = (claimMethod) => {\n    if (claimMethod === \"candy\") {\n      return (\n        <React.Fragment>\n          <TextField\n            id=\"config-text-field\"\n            label=\"Candy Config\"\n            value={candyConfig}\n            onChange={e => setCandyConfig(e.target.value)}\n          />\n          <TextField\n            id=\"config-uuid-text-field\"\n            label=\"Candy UUID\"\n            value={candyUUID}\n            onChange={e => setCandyUUID(e.target.value)}\n          />\n        </React.Fragment>\n      );\n    } else if (claimMethod === \"transfer\") {\n      return null;\n    } else if (claimMethod === \"edition\") {\n      return (\n        <React.Fragment>\n          <TextField\n            id=\"master-mint-text-field\"\n            label=\"Master Mint\"\n            value={masterMint}\n            onChange={(e) => setMasterMint(e.target.value)}\n          />\n        </React.Fragment>\n      );\n    }\n  };\n\n  return (\n    <Stack spacing={2}>\n      <TextField\n        id=\"base-text-field\"\n        label=\"Base Private Key\"\n        value={baseKey}\n        onChange={(e) => setBaseKey(e.target.value)}\n      />\n      <FormControl fullWidth>\n        <InputLabel id=\"claim-method-label\">Claim Method</InputLabel>\n        <Select\n          labelId=\"claim-method-label\"\n          id=\"claim-method-select\"\n          value={claimMethod}\n          label=\"Claim Method\"\n          onChange={(e) => {\n            localStorage.setItem(\"claimMethod\", e.target.value);\n            setClaimMethod(e.target.value);\n          }}\n          style={{textAlign: \"left\"}}\n        >\n          <MenuItem value={\"transfer\"}>Token Transfer</MenuItem>\n          <MenuItem value={\"candy\"}>Candy Machine</MenuItem>\n          <MenuItem value={\"edition\"}>Limited Edition</MenuItem>\n        </Select>\n      </FormControl>\n      {claimMethod !== \"\" && claimData(claimMethod)}\n      <Button\n        disabled={!wallet.connected || !baseKey}\n        variant=\"contained\"\n        onClick={(e) => {\n          const wrap = async () => {\n            try {\n              await submit(e);\n            } catch (err) {\n              notify({\n                message: \"Close failed\",\n                description: `${err}`,\n              });\n            }\n          };\n          wrap();\n        }}\n      >\n        Close Gumdrop\n      </Button>\n    </Stack>\n  );\n};\n","import log from 'loglevel';\nimport { SESv2Client, SendEmailCommand } from \"@aws-sdk/client-sesv2\"\nimport { SNSClient, PublishCommand } from \"@aws-sdk/client-sns\";\n\nimport {\n  ClaimantInfo,\n  Claimants,\n} from \"./claimant\"\n\nexport type AuthKeys = { [key: string] : string }\nexport type Response = { [key: string] : any }\n\nexport type DropInfo = {\n  type : string,\n  meta : string,\n};\n\nexport const formatDropMessage = (\n  info : ClaimantInfo,\n  drop : DropInfo,\n  html : boolean,\n) => {\n  const wrap = (url, text) => {\n    if (html) {\n      return `<a href=\"${url}\">${text}</a>`;\n    } else {\n      return `${text} ${url}`;\n    }\n  }\n  if (drop.type === \"Token\") {\n    return {\n      subject: \"Gumdrop Token Drop\",\n      message: `You received ${info.amount} token(s) `\n             + `(click ${wrap(drop.meta, \"here\")} to view more information about the token mint). `\n             +  wrap(info.url, \"Click here to claim them!\"),\n    };\n  } else if (drop.type === \"Candy\") {\n    return {\n      subject: \"Gumdrop NFT Drop\",\n      message: `You received ${info.amount} Candy Machine pre-sale mint(s) `\n             + `(click ${wrap(drop.meta, \"here\")} to view the candy machine configuration on explorer). `\n             +  wrap(info.url, \"Click here to claim them!\"),\n    };\n  } else if (drop.type === \"Edition\") {\n    return {\n      subject: \"Gumdrop NFT Drop\",\n      message: `You received ${info.amount} limited-edition print(s) `\n             + `(click ${wrap(drop.meta, \"here\")} to view the master edition mint on explorer). `\n             +  wrap(info.url, \"Click here to claim them!\"),\n    };\n  } else {\n    throw new Error(`Internal Error: Unknown drop type ${drop.type}`);\n  }\n};\n\nexport const distributeAwsSns = async (\n  auth : AuthKeys,\n  source : string,\n  claimants : Claimants,\n  drop : DropInfo,\n) => {\n  if (!auth.accessKeyId || !auth.secretAccessKey) {\n    throw new Error(\"AWS SES auth keys not supplied\");\n  }\n  if (claimants.length === 0) return [];\n\n  log.debug(\"SES auth\", auth);\n  const client = new SNSClient({\n    region: \"us-east-2\",\n    credentials: {\n      accessKeyId: auth.accessKeyId,\n      secretAccessKey: auth.secretAccessKey,\n    },\n  });\n\n  const single = async (\n    info : ClaimantInfo,\n    drop : DropInfo,\n  ) => {\n    const formatted = formatDropMessage(info, drop, true);\n    const message = {\n      Message: formatted.message,\n      PhoneNumber: info.handle,\n    };\n\n    try {\n      const response = await client.send(new PublishCommand(message));\n      return {\n        status: \"success\",\n        handle: info.handle,\n        messageId: response.MessageId,\n      };\n    } catch (err) {\n      return {\n        status: \"error\",\n        handle: info.handle,\n        error: err,\n      };\n    }\n  };\n\n  const responses = Array<Response>();\n  for (const c of claimants) {\n    responses.push(await single(c, drop));\n  }\n  return responses;\n}\n\nexport const distributeAwsSes = async (\n  auth : AuthKeys,\n  source : string,\n  claimants : Claimants,\n  drop : DropInfo,\n) => {\n  if (!auth.accessKeyId || !auth.secretAccessKey) {\n    throw new Error(\"AWS SES auth keys not supplied\");\n  }\n  if (claimants.length === 0) return [];\n\n  log.debug(\"SES auth\", auth);\n  const client = new SESv2Client({\n    region: \"us-east-2\",\n    credentials: {\n      accessKeyId: auth.accessKeyId,\n      secretAccessKey: auth.secretAccessKey,\n    },\n  });\n\n  // TODO: move to template + bulk message?\n  const single = async (\n    info : ClaimantInfo,\n    drop : DropInfo,\n  ) => {\n    const formatted = formatDropMessage(info, drop, true);\n    const message = {\n      Destination: {\n        ToAddresses: [\n          info.handle,\n        ]\n      },\n      Content: {\n        Simple: {\n          Subject: {\n            Data: formatted.subject,\n            Charset: \"utf-8\",\n          },\n          Body: {\n            Html: {\n              Data: formatted.message\n                + \"<br><br>\"\n                + \"<div>\"\n                +   \"If you would like to unsubscribe from new Gumdrops, \"\n                +   \"change your subscription preferences here: \"\n                +   \"<a href='{{amazonSESUnsubscribeUrl}}'>AWS subscription preferences</a>\"\n                + \"</div>\",\n              Charset: \"utf-8\",\n            },\n          },\n        },\n      },\n      FromEmailAddress: source,\n      ListManagementOptions: {\n        ContactListName: \"Gumdrop\",\n        TopicName: drop.type,\n      },\n    };\n\n    try {\n      const response = await client.send(new SendEmailCommand(message));\n      return {\n        status: \"success\",\n        handle: info.handle,\n        messageId: response.MessageId,\n      };\n    } catch (err) {\n      return {\n        status: \"error\",\n        handle: info.handle,\n        error: err,\n      };\n    }\n  };\n\n  const responses = Array<Response>();\n  for (const c of claimants) {\n    responses.push(await single(c, drop));\n  }\n  return responses;\n}\n\nexport const distributeManual = async (\n  auth : AuthKeys,\n  source : string,\n  claimants : Claimants,\n  drop : DropInfo,\n) => {\n  return Array<Response>();\n}\n\nexport const distributeWallet = async (\n  auth : AuthKeys,\n  source : string,\n  claimants : Claimants,\n  drop : DropInfo,\n) => {\n  return Array<Response>();\n}\n\nexport const urlAndHandleFor = (claimants : Array<ClaimantInfo>) => {\n  return claimants.map(info => {\n    return {\n      handle: info.handle,\n      amount: info.amount,\n      url: info.url,\n    };\n  });\n}\n","import React from \"react\"\nimport {\n  useColorMode,\n} from \"../contexts/ColorModeContext\";\n\nexport const DragAndDrop = (props) => {\n  const dropRef = React.useRef<HTMLDivElement>(null);\n  const [dragCounter, setDragCounter] = React.useState(0);\n  const [dragging, setDragging] = React.useState(false);\n\n  const handleDrag = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n  };\n\n  const handleDragIn = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    setDragCounter(dragCounter + 1);\n    if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {\n      setDragging(true);\n    }\n  };\n\n  const handleDragOut = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    const remainingDrags = dragCounter - 1;\n    setDragCounter(remainingDrags);\n    if (remainingDrags === 0) {\n      setDragging(false);\n    }\n  };\n\n  const handleDrop = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    setDragging(false);\n    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\n      props.handleDrop(e.dataTransfer.files);\n      e.dataTransfer.clearData();\n      setDragCounter(0);\n    }\n  };\n\n  React.useEffect(() => {\n    const node = dropRef.current;\n    if (node === null) return;\n    node.addEventListener(\"dragenter\" , handleDragIn);\n    node.addEventListener(\"dragleave\" , handleDragOut);\n    node.addEventListener(\"dragover\"  , handleDrag);\n    node.addEventListener(\"drop\"      , handleDrop);\n\n    return () => {\n      node.removeEventListener(\"dragenter\" , handleDragIn);\n      node.removeEventListener(\"dragleave\" , handleDragOut);\n      node.removeEventListener(\"dragover\"  , handleDrag);\n      node.removeEventListener(\"drop\"      , handleDrop);\n    };\n  });\n\n  const colorModeCtx = useColorMode();\n  const shade = colorModeCtx.mode === 'dark' ? \"rgba(255,255,255,.1)\" : \"rgba(0, 0, 0,.1)\";\n\n  return (\n    <div\n      ref={dropRef}\n      style={dragging ? { backgroundColor: shade} : {}}\n    >\n      {props.children}\n    </div>\n  );\n};\n\n\nexport default DragAndDrop;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport {\n  Box,\n  Button,\n  CircularProgress,\n  FormControl,\n  Link as HyperLink,\n  InputLabel,\n  MenuItem,\n  Stack,\n  Select,\n  Table,\n  TableBody,\n  TableCell,\n  TableContainer,\n  TableHead,\n  TableRow,\n  TextField,\n} from \"@mui/material\";\nimport FilePresentIcon from '@mui/icons-material/FilePresent';\n\nimport {\n  useWallet,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  Keypair,\n  PublicKey,\n} from \"@solana/web3.js\";\nimport {\n  MintInfo,\n} from \"@solana/spl-token\";\nimport BN from 'bn.js';\n\nimport {\n  useConnection,\n  Connection,\n} from \"../contexts\";\nimport {\n  GUMDROP_DISTRIBUTOR_ID,\n  GUMDROP_TEMPORAL_SIGNER,\n  notify,\n  shortenAddress,\n} from \"../utils\";\nimport {\n  ClaimantInfo,\n  Claimants,\n  buildGumdrop,\n  dropInfoFor,\n  parseClaimants,\n  validateTransferClaims,\n  validateCandyClaims,\n  validateEditionClaims,\n} from \"../utils/claimant\";\nimport {\n  AuthKeys,\n  DropInfo,\n  Response as DResponse,\n  distributeAwsSes,\n  distributeManual,\n  distributeWallet,\n  urlAndHandleFor,\n} from \"../utils/communication\";\nimport {\n  envFor,\n  explorerLinkFor,\n} from \"../utils/transactions\";\nimport { DragAndDrop } from \"./DragAndDrop\";\nimport { DefaultModal } from \"./DefaultModal\";\n\n// NB: assumes no overflow\nconst randomBytes = () : Uint8Array => {\n  // TODO: some predictable seed? sha256?\n  const buf = new Uint8Array(4);\n  window.crypto.getRandomValues(buf);\n  return buf;\n}\n\nconst WHITESPACE = \"\\u00A0\";\n\nconst distribute = (\n  method : string,\n  auth : AuthKeys,\n  source : string,\n  claimants : Claimants,\n  drop : DropInfo,\n) => {\n  if (method === \"AWS SES\") {\n    return distributeAwsSes(auth, source, claimants, drop);\n  } else if (method === \"Manual\") {\n    return distributeManual(auth, source, claimants, drop);\n  } else if (method === \"Wallets\") {\n    return distributeWallet(auth, source, claimants, drop);\n  } else {\n    throw new Error(`Unrecognized claim distribution method ${method}`);\n  }\n}\n\nconst reactModal = (renderModal) => {\n  const container = document.createElement('div');\n  document.body.appendChild(container);\n\n  const displayModal = ({ onSubmit, onDismiss }) => {\n    ReactDOM.render(renderModal({ onSubmit, onDismiss, show: true }), container);\n  };\n\n  const hideModal = ({ onSubmit, onDismiss }, callback) => {\n    ReactDOM.render(renderModal({ onSubmit, onDismiss, show: false }), container, callback);\n  };\n\n  const destroyModal = () => {\n    ReactDOM.unmountComponentAtNode(container);\n    document.body.removeChild(container);\n  };\n\n  const confirmation = new Promise((resolve) => {\n    const onSubmit = (value) => resolve(value);\n    const onDismiss = () => resolve(undefined);\n    displayModal({ onSubmit, onDismiss });\n  });\n\n  return confirmation.finally(() => {\n    const onSubmit = () => {};\n    const onDismiss = () => {};\n    hideModal({ onSubmit, onDismiss }, destroyModal);\n  });\n};\n\nconst resendOnlyRender = ({ show, onSubmit, onDismiss }) => {\n  const options = [\n    { click: () => onSubmit(\"create\"), name: \"Create and Send\" },\n    { click: () => onSubmit(\"send\")  , name: \"Send only\"       },\n  ];\n  return (\n    <DefaultModal visible={show} onCancel={onDismiss} width=\"70ch\">\n      <p style={{\n        color: \"white\",\n        fontSize: \"0.9rem\",\n        marginTop: 8,\n        width: \"90%\",\n      }}>\n        Uploaded distribution list has URLs for all claimants.\n        Skip creation of airdrop and only re-send links?\n      </p>\n      <br />\n      <Stack direction=\"row\" spacing={2} style={{width: \"100%\"}}>\n      {options.map((opt) => {\n        return (\n          <Button\n            key={opt.name}\n            style={{\n              width: \"100%\",\n              color: \"white\",\n              marginBottom: 8,\n            }}\n            variant=\"outlined\"\n            onClick={opt.click}\n          >\n            {opt.name}\n          </Button>\n        );\n      })}\n      </Stack>\n    </DefaultModal>\n  );\n};\n\nconst displayMintTokens = (amount : number, mintInfo : MintInfo) : string => {\n  // TODO: better decimal rounding\n  return String(amount / Math.pow(10, mintInfo.decimals));\n};\n\nconst hyperLinkData = (data) => {\n  const encoded = encodeURIComponent(JSON.stringify(data));\n  return `data:text/plain;charset=utf-8,${encoded}`;\n};\n\nconst shouldSendRender = (claimants, needsPin, claimMethod, claimInfo, baseKey) => {\n  const limit = 1000;\n  return ({ show, onSubmit, onDismiss }) => {\n    return (\n      <DefaultModal visible={show} onCancel={onDismiss} width=\"70ch\">\n        <h2\n          style={{\n            color: \"white\",\n            fontWeight: \"bold\",\n            fontSize: \"1.2rem\",\n          }}\n        >\n          Claim Distribution Preview{claimants.length > limit ? ` (First ${limit})` : \"\"}\n        </h2>\n        <p style={{ color: \"white\", fontSize: \"1rem\", textAlign: \"center\" }}>\n          Approving will save the keypair authority generated for gumdrop\n          state. This keypair is necessary to close the gumdrop later!\n        </p>\n        <TableContainer\n          sx={{\n            \"td, th\": { color: \"white\" },\n            backgroundColor: \"#444444\",\n            borderRadius: \"5px\",\n            maxHeight: \"30ch\",\n          }}\n        >\n          <Table size=\"small\">\n            <TableHead>\n              <TableRow>\n                <TableCell>Handle</TableCell>\n                <TableCell>\n                  {claimMethod === \"edition\"\n                    ? \"Edition\"\n                    : \"Tokens\"\n                  }\n                </TableCell>\n                {needsPin && <TableCell>Pin</TableCell>}\n              </TableRow>\n            </TableHead>\n            <TableBody>\n              {claimants.slice(0, limit).map((c, idx) => (\n                <TableRow\n                  key={idx}\n                  sx={{ 'td, th': { border: 0 } }}\n                >\n                  <TableCell component=\"th\" scope=\"row\">{c.handle} </TableCell>\n                  <TableCell>\n                    { claimMethod === \"transfer\" ? displayMintTokens(c.amount, claimInfo.mint.info)\n                    : claimMethod === \"candy\"    ? c.amount\n                    : /* === \"edition\" */          c.edition\n                    }\n                  </TableCell>\n                  {needsPin && <TableCell>{c.pin.toNumber()}</TableCell>}\n                </TableRow>\n              ))}\n            </TableBody>\n          </Table>\n        </TableContainer>\n        <Box style={{ height: \"3ch\" }} />\n        <Stack direction=\"row\" spacing={2} style={{width: \"100%\"}}>\n          <Button\n            style={{\n              width: \"100%\",\n              color: \"white\",\n              marginBottom: 8,\n            }}\n            variant=\"outlined\"\n            onClick={() => onSubmit(false)}\n          >\n            Cancel\n          </Button>\n          <HyperLink\n            href={hyperLinkData(Array.from(baseKey.secretKey))}\n            download={`${baseKey.publicKey.toBase58()}.json`}\n            underline=\"none\"\n            style={{width: \"100%\"}}\n          >\n            <Button\n              style={{\n                width: \"100%\",\n                color: \"white\",\n                marginBottom: 8,\n              }}\n              variant=\"outlined\"\n              onClick={() => onSubmit(true)}\n            >\n              Approve\n            </Button>\n          </HyperLink>\n        </Stack>\n      </DefaultModal>\n    );\n  }\n};\n\nexport type CreateProps = {};\n\nexport const Create = (\n  props : CreateProps,\n) => {\n  const connection = useConnection();\n  const wallet = useWallet();\n\n  // claim state\n  const [claimMethod, setClaimMethod] = React.useState(localStorage.getItem(\"claimMethod\") || \"\");\n  const [candyConfig, setCandyConfig] = React.useState(localStorage.getItem(\"candyConfig\") || \"\");\n  const [candyUUID, setCandyUUID] = React.useState(localStorage.getItem(\"candyUUID\") || \"\");\n  const [mint, setMint] = React.useState(localStorage.getItem(\"mint\") || \"\");\n  const [masterMint, setMasterMint] = React.useState(localStorage.getItem(\"masterMint\") || \"\");\n  const [filename, setFilename] = React.useState(\"\");\n  const [text, setText] = React.useState(\"\");\n\n  // response state\n  const [claimURLs, setClaimURLs] = React.useState<Array<{ [key: string]: any }>>([]);\n  const [responses, setResponses] = React.useState<Array<DResponse>>([]);\n\n  // auth state\n  const [otpAuth, setOtpAuth] = React.useState(localStorage.getItem(\"otpAuth\") || \"default\");\n  const [commMethod, setCommMethod] = React.useState(localStorage.getItem(\"commMethod\") || \"\");\n  const [commAuth, setCommAuth] = React.useState<AuthKeys>({});\n  const [commSource, setCommSource] = React.useState(localStorage.getItem(\"commSource\") || \"\");\n  const [awsAccessKeyId, setAwsAccessKeyId] = React.useState(\"\");\n  const [awsSecretKey, setAwsSecretKey] = React.useState(\"\");\n\n  const explorerUrlFor = (key : PublicKey) => {\n    return `https://explorer.solana.com/address/${key.toBase58()}?cluster=${envFor(connection)}`;\n  }\n\n  const distributeClaims = async (claimants, drop) => {\n    const responses = await distribute(\n      commMethod, commAuth, commSource, claimants, drop);\n\n    console.log(\"Responses\", responses);\n    setResponses(responses);\n\n    // notify if the above routine is actually supposed to do anything\n    // (manual and wallet do nothing atm)\n    if (commMethod === \"AWS SES\") {\n      notify({\n        message: \"Gumdrop email distribution completed\",\n      });\n    }\n  }\n\n  const submit = async (e : React.SyntheticEvent) => {\n    e.preventDefault();\n\n    setClaimURLs([]);\n    setResponses([]);\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const claimants = parseClaimants(text, filename, commMethod);\n    if (claimants.length === 0) {\n      throw new Error(`No claimants provided`);\n    }\n\n    const dropInfo = dropInfoFor(envFor(connection), claimMethod, mint, candyConfig, masterMint);\n    // check that auth is correct...\n    await distribute(\n      commMethod, commAuth, commSource, [], dropInfo);\n\n    const mightHaveExisting = (info : ClaimantInfo) => {\n      return info.url !== undefined && info.url !== null;\n    };\n    if (claimants.reduce((acc, c) => acc && mightHaveExisting(c), true)) {\n      const resendOnly = await reactModal(resendOnlyRender);\n      console.log(\"Resend only\", resendOnly);\n      if (resendOnly === \"send\") {\n        setClaimURLs(urlAndHandleFor(claimants));\n        await distributeClaims(claimants, dropInfo);\n        return;\n      } else if (resendOnly === \"create\") {\n        // fallthrough to full create\n      } else {\n        // dismissed. don't use exceptions for control flow?\n        throw new Error(\"Dismissed\");\n      }\n    }\n\n\n    let claimInfo;\n    switch (claimMethod) {\n      case \"transfer\": {\n        claimInfo = await validateTransferClaims(\n          connection,\n          wallet.publicKey,\n          claimants,\n          mint,\n        );\n        break;\n      }\n      case \"candy\": {\n        claimInfo = await validateCandyClaims(\n          connection,\n          wallet.publicKey,\n          claimants,\n          candyConfig,\n          candyUUID,\n        );\n        break;\n      }\n      case \"edition\": {\n        claimInfo = await validateEditionClaims(\n          connection,\n          wallet.publicKey,\n          claimants,\n          masterMint,\n        );\n        break;\n      }\n      default:\n        throw new Error(`Unknown claim method ${claimMethod}`);\n    }\n    console.log(\"Claims info\", claimInfo);\n\n    claimants.forEach(c => {\n      c.pin = new BN(randomBytes());\n      c.seed = claimMethod === \"transfer\" ? claimInfo.mint.key\n             : claimMethod === \"candy\"    ? claimInfo.config\n             : /* === edition */            claimInfo.masterMint.key;\n    });\n\n    // temporal auth is the AWS signer by 'default' and a no-op key otherwise\n    let temporalSigner;\n    if (commMethod === \"Wallets\") {\n      // TODO: this is a bit jank. There should be no form option to set the\n      // OTP auth if we are using a wallet but there's still a defaulted value\n      // atm...\n      // NB: We also need this to not be 'none' since there is a special check\n      // for claimant_secret==accounts.temporal\n      temporalSigner = GUMDROP_DISTRIBUTOR_ID;\n    } else if (otpAuth === \"default\") {\n      temporalSigner = GUMDROP_TEMPORAL_SIGNER;\n    } else if (otpAuth === \"none\") {\n      temporalSigner = PublicKey.default;\n    } else {\n      throw new Error(`Unknown OTP authorization type ${otpAuth}`);\n    }\n\n    console.log(`Temporal signer: ${temporalSigner.toBase58()}`);\n\n    const base = Keypair.generate();\n    console.log(`Base ${base.publicKey.toBase58()}`);\n\n    const needsPin = commMethod !== \"Wallets\";\n    const instructions = await buildGumdrop(\n      connection,\n      wallet.publicKey,\n      needsPin,\n      claimMethod,\n      `${window.location.origin}${window.location.pathname}`,\n      base.publicKey,\n      temporalSigner,\n      claimants,\n      claimInfo\n    );\n\n    const shouldSend = await reactModal(\n      shouldSendRender(claimants, needsPin, claimMethod, claimInfo, base)\n    ) as boolean | undefined;\n    if (shouldSend === true) {\n    } else {\n      // dismissed. don't use exceptions for control flow?\n      throw new Error(\"Claim distribution preview not approved\");\n    }\n\n\n    setClaimURLs(urlAndHandleFor(claimants));\n\n    const createResult = await Connection.sendTransactionWithRetry(\n      connection,\n      wallet,\n      instructions,\n      [base]\n    );\n\n    console.log(createResult);\n    if (typeof createResult === \"string\") {\n      throw new Error(createResult);\n    } else {\n      notify({\n        message: \"Gumdrop creation succeeded\",\n        description: (\n          <HyperLink href={explorerLinkFor(createResult.txid, connection)}>\n            View transaction on explorer\n          </HyperLink>\n        ),\n      });\n    }\n\n    console.log(\"Distributing claim URLs\");\n    await distributeClaims(claimants, dropInfo);\n  };\n\n  const handleFiles = (files) => {\n    if (files.length !== 1) {\n      notify({\n        message: \"File upload failed\",\n        description: `Received ${files.length} files`,\n      });\n      return;\n    }\n\n    const file = files[0];\n    const reader = new FileReader();\n    reader.onload = (e) => {\n      if (e !== null && e.target !== null) {\n        if (typeof e.target.result === \"string\") {\n          try {\n            parseClaimants(e.target.result, file.name, commMethod);\n          } catch {\n            notify({\n              message: `File upload failed for: ${file.name}`,\n              description: (\n                <span>\n                  Could not parse uploaded file.{WHITESPACE}\n                  <HyperLink href=\"#/\">\n                    Does it follow the JSON scheme?\n                  </HyperLink>\n                </span>\n              ),\n            });\n            setFilename(\"\");\n            setText(\"\");\n            return;\n          }\n          setFilename(file.name);\n          setText(e.target.result);\n        } else {\n          notify({\n            message: `File upload failed for: ${file.name}`,\n            description: \"Could not read uploaded file\",\n          });\n        }\n      }\n    };\n    reader.readAsText(file);\n  };\n\n  const claimData = (claimMethod) => {\n    if (claimMethod === \"candy\") {\n      return (\n        <React.Fragment>\n          <TextField\n            id=\"config-text-field\"\n            label=\"Candy Config\"\n            value={candyConfig}\n            onChange={e => {\n              setCandyConfig(e.target.value);\n              localStorage.setItem(\"candyConfig\", e.target.value);\n            }}\n          />\n          <TextField\n            id=\"config-uuid-text-field\"\n            label=\"Candy UUID\"\n            value={candyUUID}\n            onChange={e => {\n              setCandyUUID(e.target.value);\n              localStorage.setItem(\"candyUUID\", e.target.value);\n            }}\n          />\n        </React.Fragment>\n      );\n    } else if (claimMethod === \"transfer\") {\n      return (\n        <TextField\n          id=\"mint-text-field\"\n          label=\"Mint\"\n          value={mint}\n          onChange={(e) => {\n            localStorage.setItem(\"mint\", e.target.value);\n            setMint(e.target.value);\n          }}\n        />\n      );\n    } else if (claimMethod === \"edition\") {\n      // transfers master mint token from this account to the distributor\n      // wallet ATA\n      return (\n        <TextField\n          id=\"master-mint-text-field\"\n          label=\"Master Mint\"\n          value={masterMint}\n          onChange={(e) => {\n            localStorage.setItem(\"masterMint\", e.target.value);\n            setMasterMint(e.target.value);\n          }}\n        />\n      );\n    }\n  };\n\n  const commAuthorization = (commMethod) => {\n    if (commMethod === \"AWS SES\") {\n      return (\n        <React.Fragment>\n          <TextField\n            id=\"comm-access-key-id-field\"\n            label={`${commMethod} Access Key Id`}\n            value={awsAccessKeyId}\n            onChange={(e) => {\n              setCommAuth(prev => ({...prev, accessKeyId: e.target.value}));\n              setAwsAccessKeyId(e.target.value)\n            }}\n          />\n          <TextField\n            id=\"comm-secret-access-key-field\"\n            label={`${commMethod} Secret Access Key`}\n            value={awsSecretKey}\n            onChange={(e) => {\n              setCommAuth(prev => ({...prev, secretAccessKey: e.target.value}));\n              setAwsSecretKey(e.target.value)\n            }}\n          />\n          <TextField\n            id=\"comm-source-field\"\n            label={`${commMethod} Source`}\n            value={commSource}\n            onChange={(e) => {\n              localStorage.setItem(\"commSource\", e.target.value);\n              setCommSource(e.target.value)\n            }}\n          />\n        </React.Fragment>\n      );\n    }\n\n    // commMethod === \"Manual\" || commMethod === \"Wallets\"\n    return null;\n  };\n\n  const fileUpload = (\n    <React.Fragment>\n      <DragAndDrop handleDrop={handleFiles} >\n        <Stack\n          direction=\"row\"\n          style={{\n            height: \"15ch\",\n          }}\n          sx={{\n            border: '1px dashed grey',\n            justifyContent: \"center\",\n            alignContent: \"center\",\n          }}\n        >\n          <Button\n            variant=\"text\"\n            component=\"label\"\n            style={{\n              padding: 0,\n              // don't make the button click field too large...\n              marginTop: \"5ch\",\n              marginBottom: \"5ch\",\n            }}\n          >\n            Upload a {filename === \"\" ? \"distribution\" : \"different\"} list\n            <input\n              type=\"file\"\n              onChange={(e) => {\n                handleFiles(e.target.files);\n                // re-parse every time...\n                e.target.value = '';\n              }}\n              hidden\n            />\n          </Button>\n          {WHITESPACE}\n          {/*For display alignment...*/}\n          <Button\n            variant=\"text\"\n            component=\"label\"\n            disabled={true}\n            style={{\n              padding: 0,\n              color: \"#eee\",\n            }}\n          >\n            or drag it here\n          </Button>\n        </Stack>\n      </DragAndDrop>\n      {filename !== \"\"\n      ? (<Button\n            variant=\"text\"\n            component=\"label\"\n            disabled={true}\n            style={{\n              padding: 0,\n              color: \"#eee\",\n            }}\n          >\n            <FilePresentIcon />\n            <span>{WHITESPACE} Uploaded {filename}</span>\n          </Button>\n        )\n      : (<Box/>)}\n    </React.Fragment>\n  );\n\n  const [loading, setLoading] = React.useState(false);\n  const loadingProgress = () => (\n    <CircularProgress\n      size={24}\n      sx={{\n        position: 'absolute',\n        top: '50%',\n        left: '50%',\n        marginTop: '-12px',\n        marginLeft: '-12px',\n      }}\n    />\n  );\n  const createAirdrop = (\n    <Box sx={{ position: \"relative\" }}>\n    <Button\n      disabled={!wallet.connected || !commMethod || !filename || loading}\n      variant=\"contained\"\n      style={{ width: \"100%\" }}\n      onClick={(e) => {\n        setLoading(true);\n        const wrap = async () => {\n          try {\n            await submit(e);\n            setLoading(false);\n          } catch (err) {\n            notify({\n              message: \"Create failed\",\n              description: `${err}`,\n            });\n            setLoading(false);\n          }\n        };\n        wrap();\n      }}\n    >\n      Create{claimURLs.length > 0 ? \" Another \" : \" \"}Gumdrop\n    </Button>\n    {loading && loadingProgress()}\n    </Box>\n  );\n\n  const otpAuthC = (\n    <React.Fragment>\n      <FormControl fullWidth>\n        <InputLabel id=\"otp-auth-label\">OTP Authorization</InputLabel>\n        <Select\n          labelId=\"otp-auth-label\"\n          id=\"otp-auth-select\"\n          value={otpAuth}\n          label=\"OTP Authorization\"\n          onChange={(e) => {\n            localStorage.setItem(\"otpAuth\", e.target.value);\n            setOtpAuth(e.target.value);\n          }}\n          style={{textAlign: \"left\"}}\n        >\n          <MenuItem value={\"default\"}>\n            Default{WHITESPACE}\n            <HyperLink\n              href={explorerUrlFor(GUMDROP_TEMPORAL_SIGNER)}\n              underline=\"none\"\n              target=\"_blank\" rel=\"noopener noreferrer\"\n            >\n              ({shortenAddress(GUMDROP_TEMPORAL_SIGNER.toBase58())})\n            </HyperLink>\n          </MenuItem>\n          <MenuItem value={\"none\"}>None</MenuItem>\n        </Select>\n      </FormControl>\n    </React.Fragment>\n  );\n\n  return (\n    <Stack spacing={2}>\n      <FormControl fullWidth>\n        <InputLabel id=\"claim-method-label\">Claim Method</InputLabel>\n        <Select\n          labelId=\"claim-method-label\"\n          id=\"claim-method-select\"\n          value={claimMethod}\n          label=\"Claim Method\"\n          onChange={(e) => {\n            localStorage.setItem(\"claimMethod\", e.target.value);\n            setClaimMethod(e.target.value);\n          }}\n          style={{textAlign: \"left\"}}\n        >\n          <MenuItem value={\"transfer\"}>Token Transfer</MenuItem>\n          <MenuItem value={\"candy\"}>Candy Machine</MenuItem>\n          <MenuItem value={\"edition\"}>Limited Edition</MenuItem>\n        </Select>\n      </FormControl>\n      {claimMethod !== \"\" && claimData(claimMethod)}\n      <FormControl fullWidth>\n        <InputLabel id=\"comm-method-label\">Distribution Method</InputLabel>\n        <Select\n          labelId=\"comm-method-label\"\n          id=\"comm-method-select\"\n          value={commMethod}\n          label=\"Distribution Method\"\n          onChange={(e) => {\n            if (e.target.value === \"Discord\") {\n              notify({\n                message: \"Discord distribution unavailable\",\n                description: \"Please use the CLI for this. Discord does not support browser-connection requests\",\n              });\n              return;\n            }\n            localStorage.setItem(\"commMethod\", e.target.value);\n            setCommMethod(e.target.value);\n          }}\n          style={{textAlign: \"left\"}}\n        >\n          <MenuItem value={\"AWS SES\"}>AWS SES</MenuItem>\n          <MenuItem value={\"Discord\"}>Discord</MenuItem>\n          <MenuItem value={\"Wallets\"}>Wallets</MenuItem>\n          <MenuItem value={\"Manual\"}>Manual</MenuItem>\n        </Select>\n      </FormControl>\n      {commMethod !== \"\" && commAuthorization(commMethod)}\n      {commMethod !== \"\" && commMethod !== \"Wallets\" && otpAuthC}\n      {commMethod !== \"\" && fileUpload}\n      {createAirdrop}\n      {claimURLs.length > 0 && (\n        <HyperLink\n          href={hyperLinkData(claimURLs)}\n          download=\"claimURLs.json\"\n          underline=\"none\"\n          style={{width: \"100%\"}}\n        >\n          <Button\n            variant=\"contained\"\n            style={{width: \"100%\"}}\n          >\n            Download claim URLs\n          </Button>\n        </HyperLink>\n      )}\n      {responses.length > 0 && (\n        <HyperLink\n          href={hyperLinkData(responses)}\n          download=\"responses.json\"\n          underline=\"none\"\n          style={{width: \"100%\"}}\n        >\n          <Button\n            variant=\"contained\"\n            style={{width: \"100%\"}}\n          >\n            Download distribution responses\n          </Button>\n        </HyperLink>\n      )}\n    </Stack>\n  );\n};\n","import React from \"react\";\nimport {\n  BrowserRouter,\n  Link,\n  Route,\n  Switch,\n} from \"react-router-dom\";\n\nimport { createTheme, ThemeProvider } from \"@mui/material/styles\";\nimport CssBaseline from \"@mui/material/CssBaseline\";\nimport {\n  Box,\n  Link as HyperLink,\n  Stack,\n} from \"@mui/material\";\n\nimport \"./App.css\";\nimport {\n  useColorMode,\n} from \"./contexts\";\nimport { Header } from \"./components/Header/Header\";\nimport { Claim } from \"./components/Claim\";\nimport { Close } from \"./components/Close\";\nimport { Create } from \"./components/Create\";\n\nconst WHITESPACE = \"\\u00A0\";\n\ntype AboutProps = {};\n\nconst About = (\n  props : AboutProps,\n) => {\n  const summary = (\n    <Stack spacing={1}>\n      <div>\n      The Gumdrop program leverages the Solana blockchain and merkle trees to\n      facilitate airdrops to a large number of whitelisted users at a low cost\n      to creators.\n      </div>\n\n      <div>\n      In the Solana ecosystem, the cost of token airdrops is currently largely\n      due to rent costs being{WHITESPACE}\n      <HyperLink\n        href=\"https://docs.solana.com/implemented-proposals/rent\"\n        underline=\"none\"\n      >\n        \"fixed at the genesis\"\n      </HyperLink>\n      . With the large increase in SOLUSD since genesis, rent costs when\n      creating accounts for thousands of users have duly skyrocketed.\n      </div>\n\n      <div>\n      Simultaneously, NFT projects often have a presale to early project\n      followers and contributors. However, the candy-machine doesn't have the\n      ability to grant early minting to a whitelisted subset of wallets while\n      also using the same asset configuration for open launch.\n      </div>\n\n      <div>\n      Gumdrop (originally pioneered for token airdrops by{\" \"}\n      <HyperLink\n        href=\"https://github.com/Uniswap/merkle-distributor\"\n        underline=\"none\"\n      >\n        Uniswap\n      </HyperLink>\n      {\" \"}and ported to Solana by{WHITESPACE}\n      <HyperLink\n        href=\"https://github.com/saber-hq/merkle-distributor\"\n        underline=\"none\"\n      >\n        Saber\n      </HyperLink>) solves both these issues by building a space-efficient hash\n      structure (the merkle tree) such that an on-chain program can validate\n      whether the user is part of a whitelist. Moreover, Gumdrop\n      allows creators to directly send whitelisted users an airdrop reclamation\n      link by building the tree with off-chain handles (e.g email, discord,\n      etc) and allowing the user to redeem into any wallet.\n      </div>\n    </Stack>\n  );\n\n  const create= (\n    <Stack spacing={1}>\n      <Link to={`${window.location.pathname}create`}>\n        CREATION\n      </Link>\n\n      <div>\n      Creation builds a whitelist of users that can claim either existing\n      fungible tokens or directly mint from a pre-sale candy-machine.\n      </div>\n\n      <div>\n      Creators must choose a mint or a candy-machine config and UUID, an\n      off-chain notification method (based on the handles supplied below, e.g\n      email, discord, etc), and supply a list of recipients and balances with\n      the following JSON schema{WHITESPACE}\n      <HyperLink\n        href={`data:text/plain;charset=utf-8,${JSON.stringify(require(\"./example.json\"))}`}\n        download=\"example.json\"\n        underline=\"none\"\n      >\n      (Click here for an example)\n      </HyperLink>\n      </div>\n\n      <pre style={{ fontSize: 14 }}>{`\n[\n  {\n    \"handle\": \"<DISTRIBUTION-SPECIFIC-HANDLE>\"\n    \"amount\": <#-TOKENS-OR-CANDY-MINTS>\n  },\n  ...\n]`}</pre>\n\n      <div>\n      NB: When a candy-machine is supplied, update authority for the\n      candy-machine will be transferred to the Gumdrop state. This can\n      be reclaimed by closing the Gumdrop.\n      </div>\n    </Stack>\n  );\n\n  const claim = (\n    <Stack spacing={1}>\n      <Link to={`${window.location.pathname}claim`}>\n        CLAIMS\n      </Link>\n\n      <div>\n      Claims are redeemed through a URL with query parameters holding\n      claim-specific keys. Claimants will need to verify ownership of the\n      specified handle by answering a OTP challenge and pay the rent and\n      minting fees if applicable.\n      </div>\n    </Stack>\n  );\n\n  const close = (\n    <Stack spacing={1}>\n      <Link to={`${window.location.pathname}close`}>\n        CLOSING\n      </Link>\n\n      <div>\n      Closing the Gumdrop cleans up the on-chain state and allows\n      creators to recycle any lamports held for rent-exemption after the\n      airdrop is complete.\n      </div>\n\n      <div>\n      When closing a candy-machine-integrated distributor, update authority\n      will be transferred back to the wallet owner.\n      </div>\n    </Stack>\n  );\n\n  const steps = [\n    { name: \"summary\" , inner: summary } ,\n    { name: \"create\"  , inner: create  } ,\n    { name: \"claim\"   , inner: claim   } ,\n    { name: \"close\"   , inner: close   } ,\n  ];\n  return (\n    <Stack\n      alignContent=\"left\"\n      textAlign=\"left\"\n      spacing={2}\n    >\n      {steps.map((s, idx) => <div key={idx}>{s.inner}</div>)}\n    </Stack>\n  );\n};\n\nconst getWindowDimensions = () => {\n  const { innerWidth: width, innerHeight: height } = window;\n  return {\n    width,\n    height,\n  };\n};\n\n// eslint-disable-next-line\nconst useWindowDimensions = () => {\n  const [windowDimensions, setWindowDimensions] = React.useState(\n    getWindowDimensions()\n  );\n\n  React.useEffect(() => {\n    const handleResize = () => {\n      setWindowDimensions(getWindowDimensions());\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []);\n\n  return windowDimensions;\n};\n\nfunction App() {\n  const colorModeCtx = useColorMode();\n\n  React.useEffect(() => {}, [colorModeCtx.mode]);\n\n  const theme = React.useMemo(\n    () => {\n      let mode;\n      if (colorModeCtx.mode === \"dark\" || !colorModeCtx.mode) {\n        mode = \"dark\";\n      } else {\n        mode = \"light\";\n      }\n\n      return createTheme({\n        palette: {\n          mode,\n        },\n      })\n    },\n    [colorModeCtx.mode]\n  );\n\n  const { width } = useWindowDimensions();\n\n  return (\n    <div className=\"App\" style={{ backgroundColor: \"transparent\" }}>\n      <ThemeProvider theme={theme}>\n        <BrowserRouter>\n          <CssBaseline />\n          <Header narrow={width < 670}/>\n          <Box\n            maxWidth=\"60ch\"\n            width=\"calc(100% - 60px)\"\n            style={{\n              marginLeft: \"auto\",\n              marginRight: \"auto\",\n            }}\n          >\n            <Box height=\"40px\" />\n              <Switch>\n                <Route path=\"/create\" component={Create} />\n                <Route path=\"/claim\" component={Claim} />\n                <Route path=\"/close\" component={Close} />\n                <Route path=\"/\" component={About} />\n              </Switch>\n            <Box height=\"80px\" />\n          </Box>\n        </BrowserRouter>\n      </ThemeProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport {\n  AccountsProvider,\n  WalletProvider,\n  ConnectionProvider,\n  ColorModeContextProvider,\n} from \"./contexts\";\n\nimport \"antd/dist/antd.css\";\nimport \"@fontsource/open-sans\";\nimport \"@fontsource/roboto\";\nimport \"@fontsource/sora\";\n\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <ConnectionProvider>\n      <WalletProvider>\n        <AccountsProvider>\n          <ColorModeContextProvider>\n            <App />\n          </ColorModeContextProvider>\n        </AccountsProvider>\n      </WalletProvider>\n    </ConnectionProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\nreportWebVitals();\n","import * as anchor from '@project-serum/anchor';\nimport { Connection, PublicKey } from '@solana/web3.js';\nimport {\n  AccountLayout,\n  MintInfo,\n  MintLayout,\n} from \"@solana/spl-token\";\nimport BN from 'bn.js';\n\nimport {\n  CANDY_MACHINE_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  TOKEN_METADATA_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n} from \"./ids\";\n\nexport const getMintInfo = async (\n  connection : Connection,\n  mint : string\n) : Promise<{ key: PublicKey, info: MintInfo }> => {\n  let mintKey : PublicKey;\n  try {\n    mintKey = new PublicKey(mint);\n  } catch (err) {\n    throw new Error(`Invalid mint key ${err}`);\n  }\n  const mintAccount = await connection.getAccountInfo(mintKey);\n  if (mintAccount === null) {\n    throw new Error(`Could not fetch mint`);\n  }\n  if (!mintAccount.owner.equals(TOKEN_PROGRAM_ID)) {\n    const mintOwner = mintAccount.owner.toBase58();\n    throw new Error(`Invalid mint owner ${mintOwner}`);\n  }\n  if (mintAccount.data.length !== MintLayout.span) {\n    throw new Error(`Invalid mint size ${mintAccount.data.length}`);\n  }\n  const mintInfo = MintLayout.decode(Buffer.from(mintAccount.data));\n  return {\n    key: mintKey,\n    info: mintInfo,\n  };\n};\n\nexport const getCreatorTokenAccount = async (\n  walletKey : PublicKey,\n  connection : Connection,\n  mintKey : PublicKey,\n  totalClaim : number,\n) => {\n  const [creatorTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      walletKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      mintKey.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n  const creatorTokenAccount = await connection.getAccountInfo(creatorTokenKey);\n  if (creatorTokenAccount === null) {\n    throw new Error(`Could not fetch creator token account`);\n  }\n  if (creatorTokenAccount.data.length !== AccountLayout.span) {\n    throw new Error(`Invalid token account size ${creatorTokenAccount.data.length}`);\n  }\n  const creatorTokenInfo = AccountLayout.decode(Buffer.from(creatorTokenAccount.data));\n  if (new BN(creatorTokenInfo.amount, 8, \"le\").toNumber() < totalClaim) {\n    throw new Error(`Creator token account does not have enough tokens`);\n  }\n  return creatorTokenKey;\n};\n\nexport const fetchCoder = async (\n  address : anchor.Address,\n  connection : Connection,\n) : Promise<anchor.Coder | null> => {\n  return new anchor.Coder(await anchor.Program.fetchIdl(\n      address, { connection: connection } as anchor.Provider));\n}\n\nexport const getCandyConfig = async (\n  connection : Connection,\n  config : string\n) : Promise<PublicKey> => {\n  let configKey : PublicKey;\n  try {\n    configKey = new PublicKey(config);\n  } catch (err) {\n    throw new Error(`Invalid config key ${err}`);\n  }\n  const configAccount = await connection.getAccountInfo(configKey);\n  if (configAccount === null) {\n    throw new Error(`Could not fetch config`);\n  }\n  if (!configAccount.owner.equals(CANDY_MACHINE_ID)) {\n    throw new Error(`Invalid config owner ${configAccount.owner.toBase58()}`);\n  }\n  return configKey;\n};\n\nexport const getCandyMachineAddress = async (\n  config: PublicKey,\n  uuid: string,\n) => {\n  return await PublicKey.findProgramAddress(\n    [Buffer.from(\"candy_machine\"), config.toBuffer(), Buffer.from(uuid)],\n    CANDY_MACHINE_ID,\n  );\n};\n\nexport const getCandyMachine = async (\n  connection : Connection,\n  candyMachineKey : PublicKey,\n) => {\n  const candyMachineCoder = await fetchCoder(CANDY_MACHINE_ID, connection);\n  if (candyMachineCoder === null) {\n    throw new Error(`Could not fetch candy machine IDL`);\n  }\n  const candyMachineAccount = await connection.getAccountInfo(candyMachineKey);\n  if (candyMachineAccount === null) {\n    throw new Error(`Could not fetch candy machine`);\n  }\n  return candyMachineCoder.accounts.decode(\n      \"CandyMachine\", candyMachineAccount.data);\n}\n\nexport const getMetadata = async (\n  mint: PublicKey,\n): Promise<PublicKey> => {\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const getEdition = async (\n  mint: PublicKey,\n): Promise<PublicKey> => {\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('edition'),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const getEditionMarkerPda = async (\n  mint: PublicKey,\n  edition: BN,\n) : Promise<PublicKey> => {\n  // editions are divided into pages of 31-bytes (248-bits) for more efficient\n  // packing to check if an edition is occupied. The offset is determined from\n  // the edition passed in through data\n  const editionPageNumber = edition.div(new BN(248)).toNumber();\n\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('edition'),\n        Buffer.from(String(editionPageNumber)),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n}\n","import BN from 'bn.js';\n\nexport const TEN = new BN(10);\nexport const HALF_WAD = TEN.pow(new BN(18));\nexport const WAD = TEN.pow(new BN(18));\nexport const RAY = TEN.pow(new BN(27));\nexport const ZERO = new BN(0);\n","import { useCallback, useState } from 'react';\nimport { MintInfo } from '@solana/spl-token';\n\nimport { TokenAccount } from './../models';\nimport { PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport { WAD, ZERO } from '../constants';\nimport { TokenInfo } from '@solana/spl-token-registry';\n\nexport type KnownTokenMap = Map<string, TokenInfo>;\n\nexport const formatPriceNumber = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 8,\n});\n\nexport function useLocalStorageState(key: string, defaultState?: string) {\n  const [state, setState] = useState(() => {\n    // NOTE: Not sure if this is ok\n    const storedState = localStorage.getItem(key);\n    if (storedState) {\n      return JSON.parse(storedState);\n    }\n    return defaultState;\n  });\n\n  const setLocalStorageState = useCallback(\n    newState => {\n      const changed = state !== newState;\n      if (!changed) {\n        return;\n      }\n      setState(newState);\n      if (newState === null) {\n        localStorage.removeItem(key);\n      } else {\n        try {\n          localStorage.setItem(key, JSON.stringify(newState));\n        } catch {\n          // ignore\n        }\n      }\n    },\n    [state, key],\n  );\n\n  return [state, setLocalStorageState];\n}\n\nexport const findProgramAddress = async (\n  seeds: (Buffer | Uint8Array)[],\n  programId: PublicKey,\n) => {\n  const key =\n    'pda-' +\n    seeds.reduce((agg, item) => agg + item.toString('hex'), '') +\n    programId.toString();\n  let cached = localStorage.getItem(key);\n  if (cached) {\n    const value = JSON.parse(cached);\n\n    return [value.key, parseInt(value.nonce)] as [string, number];\n  }\n\n  const result = await PublicKey.findProgramAddress(seeds, programId);\n\n  try {\n    localStorage.setItem(\n      key,\n      JSON.stringify({\n        key: result[0].toBase58(),\n        nonce: result[1],\n      }),\n    );\n  } catch {\n    // ignore\n  }\n\n  return [result[0].toBase58(), result[1]] as [string, number];\n};\n\n// shorten the checksummed version of the input address to have 4 characters at start and end\nexport function shortenAddress(address: string, chars = 4): string {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n}\n\nexport function getTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownSymbol = map.get(mintAddress)?.symbol;\n  if (knownSymbol) {\n    return knownSymbol;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\nexport function getVerboseTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownName = map.get(mintAddress)?.name;\n  if (knownName) {\n    return knownName;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\n\nexport function getTokenByName(tokenMap: KnownTokenMap, name: string) {\n  let token: TokenInfo | null = null;\n  for (const val of tokenMap.values()) {\n    if (val.symbol === name) {\n      token = val;\n      break;\n    }\n  }\n  return token;\n}\n\nexport function getTokenIcon(\n  map: KnownTokenMap,\n  mintAddress?: string | PublicKey,\n): string | undefined {\n  const address =\n    typeof mintAddress === 'string' ? mintAddress : mintAddress?.toBase58();\n  if (!address) {\n    return;\n  }\n\n  return map.get(address)?.logoURI;\n}\n\nexport function isKnownMint(map: KnownTokenMap, mintAddress: string) {\n  return !!map.get(mintAddress);\n}\n\nexport const STABLE_COINS = new Set(['USDC', 'wUSDC', 'USDT']);\n\nexport function chunks<T>(array: T[], size: number): T[][] {\n  return Array.apply<number, T[], T[][]>(\n    0,\n    new Array(Math.ceil(array.length / size)),\n  ).map((_, index) => array.slice(index * size, (index + 1) * size));\n}\n\nexport function toLamports(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  return Math.floor(amount * precision);\n}\n\nexport function wadToLamports(amount?: BN): BN {\n  return amount?.div(WAD) || ZERO;\n}\n\nexport function fromLamports(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount = Math.floor(\n    typeof account === 'number'\n      ? account\n      : BN.isBN(account)\n      ? account.toNumber()\n      : account.info.amount.toNumber(),\n  );\n\n  const precision = Math.pow(10, mint?.decimals || 9);\n  return (amount / precision) * rate;\n}\n\nexport const tryParseKey = (key: string): PublicKey | null => {\n  try {\n    return new PublicKey(key);\n  } catch (error) {\n    return null;\n  }\n};\n\nvar SI_SYMBOL = ['', 'k', 'M', 'G', 'T', 'P', 'E'];\n\nconst abbreviateNumber = (number: number, precision: number) => {\n  let tier = (Math.log10(number) / 3) | 0;\n  let scaled = number;\n  let suffix = SI_SYMBOL[tier];\n  if (tier !== 0) {\n    let scale = Math.pow(10, tier * 3);\n    scaled = number / scale;\n  }\n\n  return scaled.toFixed(precision) + suffix;\n};\n\nexport const formatAmount = (\n  val: number,\n  precision: number = 2,\n  abbr: boolean = true,\n) => (abbr ? abbreviateNumber(val, precision) : val.toFixed(precision));\n\nexport function formatTokenAmount(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n  prefix = '',\n  suffix = '',\n  precision = 2,\n  abbr = false,\n): string {\n  if (!account) {\n    return '';\n  }\n\n  return `${[prefix]}${formatAmount(\n    fromLamports(account, mint, rate),\n    precision,\n    abbr,\n  )}${suffix}`;\n}\n\nexport const formatUSD = new Intl.NumberFormat('en-US', {\n  style: 'currency',\n  currency: 'USD',\n});\n\nconst numberFormater = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport const formatNumber = {\n  format: (val?: number) => {\n    if (!val) {\n      return '--';\n    }\n\n    return numberFormater.format(val);\n  },\n};\n\nexport const formatPct = new Intl.NumberFormat('en-US', {\n  style: 'percent',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport function convert(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  let result = (amount / precision) * rate;\n\n  return result;\n}\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n"],"sourceRoot":""}