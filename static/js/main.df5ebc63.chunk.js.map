{"version":3,"sources":["contexts/ConnectionContext.tsx","utils/claimant.ts","utils/merkleTree.ts","utils/programIds.ts","components/DefaultModal/index.tsx","contexts/AccountContext.tsx","utils/eventEmitter.ts","components/Settings/index.tsx","contexts/ColorModeContext.tsx","utils/merkleDistributor.ts","utils/notifications.tsx","utils/borsh.ts","utils/ids.ts","components/Claim.tsx","contexts/WalletContext/WalletContext.tsx","contexts/WalletContext/wallet.less","contexts/ModalContext.tsx","utils/accounts.ts","components/Centered.tsx","components/ConnectButton.tsx","components/Header/Header.tsx","components/Close.tsx","utils/communication.ts","components/DragAndDrop.tsx","components/Create.tsx","App.tsx","reportWebVitals.ts","index.tsx","utils/transactions.ts","constants/math.ts","utils/utils.ts"],"names":["ENDPOINTS","name","endpoint","ChainId","MainnetBeta","Devnet","DEFAULT","ConnectionContext","React","createContext","setEndpoint","connection","Connection","env","tokens","tokenMap","Map","ConnectionProvider","children","undefined","useLocalStorageState","useMemo","find","end","useState","setTokens","setTokenMap","useEffect","TokenListProvider","resolve","then","container","list","excludeByTag","filterByChainId","getList","knownMints","reduce","map","item","set","address","id","onAccountChange","Keypair","generate","publicKey","removeAccountChangeListener","onSlotChange","removeSlotChangeListener","Provider","value","useConnection","useContext","useConnectionConfig","context","SequenceType","getErrorForTransaction","txid","a","confirmTransaction","getParsedConfirmedTransaction","tx","errors","meta","logMessages","forEach","log","m","regex","exec","index","lastIndex","length","push","sendTransactionWithRetry","wallet","instructions","signers","commitment","includesFeePayer","block","beforeSend","WalletNotConnectedError","transaction","Transaction","instruction","add","getRecentBlockhash","recentBlockhash","blockhash","setSigners","s","partialSign","signTransaction","console","sendSignedTransaction","signedTransaction","slot","error","parseClaimants","input","JSON","parse","obj","handle","amount","edition","url","explorerUrlFor","key","toBase58","validateTransferClaims","walletKey","claimants","mintStr","c","idx","Error","total","acc","getMintInfo","mint","getCreatorTokenAccount","source","info","type","validateCandyClaims","candyConfig","candyUuid","getCandyConfig","configKey","getCandyMachineAddress","candyMachineKey","getCandyMachine","candyMachine","remaining","data","itemsAvailable","toNumber","itemsRedeemed","isNaN","authority","equals","config","uuid","getIndex","offsetFromStart","div","BN","getOffsetFromRight","sub","mod","getIndexAndMask","getOffsetFromStart","mask","shln","editionTaken","marker","setEditionTaken","validateEditionClaims","masterMintStr","masterMint","masterTokenAccount","getEdition","masterEditionKey","getAccountInfo","masterEdition","currentSupply","slice","maxSupply","editions","editionMarkers","getEditionMarkerPda","markerKey","markerData","pm","markerAcc","Array","buildGumdrop","needsPin","claimIntegration","host","baseKey","temporalSigner","claimInfo","leafs","claimant","secret","PublicKey","seeds","seed","toBuffer","Buffer","from","pin","toArray","findProgramAddress","GUMDROP_DISTRIBUTOR_ID","claimantPda","extra","tree","MerkleTree","root","getRoot","distributor","dbump","proof","getProof","verifyProof","params","b","bs58","query","join","TransactionInstruction","programId","keys","pubkey","isSigner","isWritable","SystemProgram","sha256","digest","Token","createApproveInstruction","TOKEN_PROGRAM_ID","distributorWalletKey","CANDY_MACHINE_ID","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","distributorTokenKey","createAssociatedTokenAccountInstruction","createTransferInstruction","closeGumdrop","base","claimMethod","distributorKey","wbump","extraKeys","masterMintKey","walletTokenKey","layers","this","hashes","nodeHash","cur","arr","nxt","internalHash","layer","sibling","Math","floor","toString","el","pair","keccak_256","first","second","sort","compare","fst","snd","leaf","programIds","token","associatedToken","bpf_upgrade_loader","BPF_UPGRADE_LOADER_ID","system","SYSTEM","memo","MEMO_ID","DefaultModal","props","bodyStyle","closeIcon","width","rest","style","background","borderRadius","display","flexDirection","alignItems","footer","AccountsContext","pendingCalls","genericCache","pendingMintCalls","mintCache","pubKey","deserializeMint","TokenAccountParser","buffer","deserializeAccount","account","keyToAccountParser","cache","emitter","EventEmitter","parser","get","isActive","deserialize","registerParser","delete","Function","isNew","has","raiseCacheUpdated","raiseCacheDeleted","byParser","result","queryMint","getMint","addMint","UseNativeAccount","useWallet","nativeAccount","setNativeAccount","updateCache","useCallback","wrapped","WRAPPED_SOL_MINT","owner","u64","lamports","delegate","delegatedAmount","isInitialized","isFrozen","isNative","rentExemptReserve","closeAuthority","wrapNativeAccount","subId","updateAccount","PRECACHED_OWNERS","Set","precacheUserTokenAccounts","getTokenAccountsByOwner","AccountsProvider","tokenAccounts","setTokenAccounts","userAccounts","setUserAccounts","selectUserAccounts","filter","accounts","subs","onCache","args","tokenSubID","onProgramAccountChange","accountId","accountInfo","AccountLayout","span","removeProgramAccountChangeListener","decode","fromBuffer","delegateOption","state","isNativeOption","closeAuthorityOption","MintLayout","mintInfo","mintAuthorityOption","mintAuthority","supply","freezeAuthorityOption","freezeAuthority","CacheUpdateEvent","CacheDeleteEvent","MarketUpdateEvent","ids","Emitter","callback","on","removeListener","emit","Settings","additionalSettings","connected","disconnect","setVisible","useWalletModal","open","setModal","useModal","theme","useTheme","colorModeCtx","useColorMode","handleConnect","ModalEnum","WALLET","sx","minWidth","marginBottom","onChange","e","target","variant","onClick","marginLeft","navigator","clipboard","writeText","notify","message","description","shortenAddress","color","catch","ml","toggleColorMode","palette","mode","ColorModeContext","ColorModeContextProvider","setMode","prevMode","idl","require","coder","Coder","placement","notification","opacity","backgroundColor","BinaryReader","prototype","readPubkey","array","readFixedArray","BinaryWriter","writePubkey","writeFixedArray","readPubkeyAsString","base58","encode","writePubkeyAsString","TOKEN_METADATA_PROGRAM_ID","GUMDROP_TEMPORAL_SIGNER","walletKeyOrPda","pdaSeeds","buildMintClaim","distributorInfo","tokenAcc","tokenAccKey","distTokenAccount","tokenAccountInfo","verifyClaim","claimStatus","cbump","setup","temporal","default","claimAirdrop","concat","buildCandyClaim","candyUUID","claimCount","claimCountAccount","nftsAlreadyMinted","claimAccountInfo","count","claimantStr","nftsAvailable","candyMachineMints","buildSingleCandyMint","instrs","candyMachineWallet","candyMachineMint","getMetadata","candyMachineMetadata","candyMachineMaster","createMintAndAccount","SYSVAR_RENT_PUBKEY","SYSVAR_CLOCK_PUBKEY","getMinimumBalanceForRentExemption","fromPubkey","newAccountPubkey","space","createAccount","createInitMintInstruction","createMintToInstruction","buildEditionClaim","newMint","newMetadataKey","masterMetadataKey","newEdition","editionMarkKey","fetchDistributor","distributorStr","ownerStr","fetchNeedsTemporalSigner","indexStr","Number","Claim","queryString","location","search","setDistributor","master","setClaimMethod","setTokenAcc","setCandyConfig","setCandyUUID","setMasterMint","editionStr","setEditionStr","setHandle","amountStr","setAmount","setIndex","pinStr","setPin","proofStr","setProof","allFieldsPopulated","editable","setEditable","setTransaction","OTPStr","setOTPStr","asyncNeedsTemporalSigner","setNeedsTemporalSigner","wrap","lambdaAPIEndpoint","sendOTP","preventDefault","split","ret","extraSigners","feePayer","instr","signatures","some","method","headers","body","stringify","serializeMessage","fetch","response","status","json","MessageId","verifyOTP","OTP","FunctionName","otp","blob","sig","addSignature","fullySigned","claimResult","href","explorerLinkFor","loading","setLoading","loadingProgress","size","position","top","left","marginTop","claimData","Fragment","label","disabled","steps","inner","fullWidth","labelId","textAlign","multiline","needsTemporalSigner","activeStep","setActiveStep","stepToUse","min","stepper","spacing","prev","WalletModalContext","WalletModal","wallets","selected","select","visible","setShowWallets","close","onCancel","height","verticalAlign","fontWeight","fontSize","lineHeight","icon","alt","src","marginRight","float","WalletModalProvider","setConnected","keyToDisplay","substring","WalletProvider","getPhantomWallet","getSolflareWallet","getTorusWallet","options","clientId","getLedgerWallet","getSolongWallet","getMathWallet","getSolletWallet","onError","autoConnect","ModalContext","removeModal","mintKey","mintAccount","mintOwner","totalClaim","creatorTokenKey","creatorTokenAccount","creatorTokenInfo","fetchCoder","anchor","fetchIdl","configAccount","candyMachineCoder","candyMachineAccount","editionPageNumber","String","Centered","ConnectButton","isConnected","onClickConnect","onClickChange","restProps","ButtonGroup","Header","handleChange","AppBar","Box","bgcolor","Stack","direction","justifyContent","Link","underline","Button","flexGrow","Close","setBaseKey","localStorage","getItem","submit","fromSecretKey","Uint8Array","closeResult","TextField","FormControl","InputLabel","Select","setItem","MenuItem","formatDropMessage","drop","subject","DragAndDrop","dropRef","useRef","dragCounter","setDragCounter","dragging","setDragging","handleDrag","stopPropagation","handleDragIn","dataTransfer","items","handleDragOut","remainingDrags","handleDrop","files","clearData","node","current","addEventListener","removeEventListener","shade","ref","randomBytes","buf","window","crypto","getRandomValues","WHITESPACE","setupSender","auth","debug","client","SESClient","region","credentials","accessKeyId","secretAccessKey","formatted","Destination","ToAddresses","Message","Subject","Data","Charset","Body","Html","Source","send","SendEmailCommand","$metadata","httpStatusCode","setupSes","mintUrl","toUpload","setupWalletListUpload","reactModal","renderModal","document","createElement","appendChild","destroyModal","ReactDOM","unmountComponentAtNode","removeChild","Promise","onSubmit","onDismiss","render","show","displayModal","finally","hideModal","resendOnlyRender","click","opt","hyperLinkData","encoded","encodeURIComponent","shouldSendRender","TableContainer","maxHeight","Table","TableHead","TableRow","TableCell","TableBody","border","component","scope","pow","decimals","secretKey","download","Create","setMint","filename","setFilename","text","setText","claimURLs","setClaimURLs","otpAuth","setOtpAuth","commMethod","setCommMethod","commAuth","setCommAuth","commSource","setCommSource","awsAccessKeyId","setAwsAccessKeyId","awsSecretKey","setAwsSecretKey","mailcAPIKey","setMailcAPIKey","envFor","mightHaveExisting","resendOnly","sender","origin","pathname","createResult","handleFiles","file","reader","FileReader","onload","readAsText","fileUpload","alignContent","padding","hidden","createAirdrop","CircularProgress","otpAuthC","rel","apiKey","commAuthorization","About","to","getWindowDimensions","innerWidth","innerHeight","App","disabledColor","createTheme","action","windowDimensions","setWindowDimensions","handleResize","useWindowDimensions","className","ThemeProvider","CssBaseline","path","reportWebVitals","onPerfEntry","getCLS","getFID","getFCP","getLCP","getTTFB","StrictMode","getElementById","getUnixTs","Date","getTime","match","_rpcEndpoint","timeout","rawTransaction","serialize","startTime","sendRawTransaction","skipPreflight","done","sleep","awaitTransactionSignatureConfirmation","confirmation","err","simulateResult","simulateTransaction","logs","i","line","startsWith","_recentBlockhash","_disableBlockhashCaching","signData","wireTransaction","_serialize","encodedTransaction","encoding","_rpcRequest","res","queryStatus","confirmations","reject","setTimeout","warn","onSignature","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener","TEN","Intl","NumberFormat","minimumFractionDigits","maximumFractionDigits","defaultState","storedState","setState","setLocalStorageState","newState","removeItem","chars","chunks","apply","ceil","_","currency","ms"],"mappings":"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","file":"static/js/main.df5ebc63.chunk.js","sourcesContent":["import { useLocalStorageState } from \"../utils/utils\";\nimport {\n  Keypair,\n  Commitment,\n  Connection,\n  Transaction,\n  TransactionInstruction,\n  Blockhash,\n  FeeCalculator,\n} from \"@solana/web3.js\";\nimport React, { useContext, useEffect, useMemo, useState } from \"react\";\nimport {\n  sendSignedTransaction,\n} from \"../utils/transactions\";\nimport {\n  TokenInfo,\n  TokenListProvider,\n  ENV as ChainId,\n} from \"@solana/spl-token-registry\";\nimport { WalletSigner } from \"./WalletContext/WalletContext\";\nimport { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport type ENV = \"mainnet-beta\" | \"testnet\" | \"devnet\" | \"localnet\";\n\nexport const ENDPOINTS = [\n  {\n    name: \"mainnet-beta\" as ENV,\n    endpoint: \"https://api.mainnet-beta.solana.com\",\n    ChainId: ChainId.MainnetBeta,\n  },\n  {\n    name: \"devnet\" as ENV,\n    endpoint: \"https://api.devnet.solana.com\",\n    ChainId: ChainId.Devnet,\n  },\n];\n\nconst DEFAULT = ENDPOINTS[0].endpoint;\n\ninterface ConnectionConfig {\n  connection: Connection;\n  endpoint: string;\n  env: ENV;\n  setEndpoint: (val: string) => void;\n  tokens: TokenInfo[];\n  tokenMap: Map<string, TokenInfo>;\n}\n\nconst ConnectionContext = React.createContext<ConnectionConfig>({\n  endpoint: DEFAULT,\n  setEndpoint: () => {},\n  connection: new Connection(DEFAULT, \"recent\"),\n  env: ENDPOINTS[0].name,\n  tokens: [],\n  tokenMap: new Map<string, TokenInfo>(),\n});\n\nexport function ConnectionProvider({ children = undefined as any }) {\n  const [endpoint, setEndpoint] = useLocalStorageState(\n    \"connectionEndpoint\",\n    ENDPOINTS[0].endpoint\n  );\n\n  const connection = useMemo(\n    () => new Connection(endpoint, \"recent\"),\n    [endpoint]\n  );\n\n  const env =\n    ENDPOINTS.find((end) => end.endpoint === endpoint)?.name ||\n    ENDPOINTS[0].name;\n\n  const [tokens, setTokens] = useState<TokenInfo[]>([]);\n  const [tokenMap, setTokenMap] = useState<Map<string, TokenInfo>>(new Map());\n  useEffect(() => {\n    // fetch token files\n    new TokenListProvider().resolve().then((container) => {\n      const list = container\n        .excludeByTag(\"nft\")\n        .filterByChainId(\n          ENDPOINTS.find((end) => end.endpoint === endpoint)?.ChainId ||\n            ChainId.MainnetBeta\n        )\n        .getList();\n\n      const knownMints = [...list].reduce((map, item) => {\n        map.set(item.address, item);\n        return map;\n      }, new Map<string, TokenInfo>());\n\n      setTokenMap(knownMints);\n      setTokens(list);\n    });\n  }, [env, endpoint]);\n\n  // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n  // This is a hack to prevent the list from every getting empty\n  useEffect(() => {\n    const id = connection.onAccountChange(\n      Keypair.generate().publicKey,\n      () => {}\n    );\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    const id = connection.onSlotChange(() => null);\n    return () => {\n      connection.removeSlotChangeListener(id);\n    };\n  }, [connection]);\n\n  return (\n    <ConnectionContext.Provider\n      value={{\n        endpoint,\n        setEndpoint,\n        connection,\n        tokens,\n        tokenMap,\n        env,\n      }}\n    >\n      {children}\n    </ConnectionContext.Provider>\n  );\n}\n\nexport function useConnection() {\n  return useContext(ConnectionContext).connection as Connection;\n}\n\nexport function useConnectionConfig() {\n  const context = useContext(ConnectionContext);\n  return {\n    endpoint: context.endpoint,\n    setEndpoint: context.setEndpoint,\n    env: context.env,\n    tokens: context.tokens,\n    tokenMap: context.tokenMap,\n  };\n}\n\nexport const getErrorForTransaction = async (\n  connection: Connection,\n  txid: string\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, \"max\");\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach((log) => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport enum SequenceType {\n  Sequential,\n  Parallel,\n  StopOnFailure,\n}\n\nexport const sendTransactionWithRetry = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = \"singleGossip\",\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void\n) : Promise<string| { txid: string; slot: number }> => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach((instruction) => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map((s) => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    try {\n      transaction = await wallet.signTransaction(transaction);\n    } catch {\n      return \"Failed to sign transaction\";\n    }\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n  console.log(\"About to send\");\n  try {\n    const { txid, slot } = await sendSignedTransaction({\n      connection,\n      signedTransaction: transaction,\n    });\n\n    return { txid, slot };\n  } catch (error) {\n    console.error(error);\n    return \"See console logs\";\n  }\n};\n\n","import {\n  Connection as RPCConnection,\n  Keypair,\n  PublicKey,\n  SystemProgram,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport {\n  Token,\n} from \"@solana/spl-token\";\nimport { sha256 } from \"js-sha256\";\nimport BN from 'bn.js';\nimport * as bs58 from \"bs58\";\n\nimport {\n  getCandyConfig,\n  getCandyMachineAddress,\n  getCandyMachine,\n  getCreatorTokenAccount,\n  getEdition,\n  getEditionMarkerPda,\n  getMintInfo,\n} from \"./accounts\";\nimport {\n  CANDY_MACHINE_ID,\n  GUMDROP_DISTRIBUTOR_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n} from \"./ids\";\nimport {\n  MerkleTree,\n} from \"./merkleTree\";\n\nexport type ClaimantInfo = {\n  handle : string,\n  amount : number,\n  edition : number,\n\n  pin    : BN,\n  url    : string,\n\n  seed   : PublicKey,\n  secret : PublicKey,\n};\n\nexport type Claimants = Array<ClaimantInfo>;\nexport const parseClaimants = (\n  input : string\n) : Claimants => {\n  const json = JSON.parse(input);\n  return json.map(obj => {\n    return {\n      handle : obj.handle,\n      amount : obj.amount,\n      edition: obj.edition,\n      url    : obj.url,\n    };\n  });\n};\n\nconst explorerUrlFor = (env : string, key : PublicKey) => {\n  return `https://explorer.solana.com/address/${key.toBase58()}?cluster=${env}`;\n}\n\nexport type ClaimInfo = { [key: string]: any };\n\nexport const validateTransferClaims = async (\n  connection : RPCConnection,\n  env : string,\n  walletKey : PublicKey,\n  claimants : Claimants,\n  mintStr : string,\n) : Promise<ClaimInfo> => {\n  claimants.forEach((c, idx) => {\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\n    if (!c.amount) throw new Error(`Claimant ${idx} doesn't have amount`);\n    if (c.amount === 0) throw new Error(`Claimant ${idx} amount is 0`);\n  });\n\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\n  const mint = await getMintInfo(connection, mintStr);\n  const source = await getCreatorTokenAccount(\n    walletKey,\n    connection,\n    mint.key,\n    total\n  );\n\n  return {\n    total: total,\n    mint: mint,\n    source: source,\n    info: { type: \"Token\", meta: explorerUrlFor(env, mint.key) },\n  };\n}\n\nexport const validateCandyClaims = async (\n  connection : RPCConnection,\n  env : string,\n  walletKey : PublicKey,\n  claimants : Claimants,\n  candyConfig : string,\n  candyUuid : string,\n) : Promise<ClaimInfo> => {\n  claimants.forEach((c, idx) => {\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\n    if (!c.amount) throw new Error(`Claimant ${idx} doesn't have amount`);\n    if (c.amount === 0) throw new Error(`Claimant ${idx} amount is 0`);\n  });\n\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\n  const configKey = await getCandyConfig(connection, candyConfig);\n  const [candyMachineKey, ] = await getCandyMachineAddress(configKey, candyUuid);\n\n  const candyMachine = await getCandyMachine(connection, candyMachineKey);\n\n  const remaining = candyMachine.data.itemsAvailable.toNumber() - candyMachine.itemsRedeemed.toNumber();\n  if (isNaN(remaining)) {\n    // TODO: should this have an override?\n    throw new Error(`Could not calculate how many candy machine items are remaining`);\n  }\n  if (remaining < total) {\n    throw new Error(`Distributor is allocated more mints (${total}) `\n                  + `than the candy machine has remaining (${remaining})`);\n  }\n  if (!candyMachine.authority.equals(walletKey)) {\n    throw new Error(`Candy machine authority does not match wallet public key`);\n  }\n\n  return {\n    total: total,\n    config: configKey,\n    uuid: candyUuid,\n    candyMachineKey: candyMachineKey,\n    info: { type: \"Candy\", meta: explorerUrlFor(env, configKey) },\n  };\n}\n\nconst getOffsetFromStart = (edition: BN) => {\n  return edition.mod(new BN(31 * 8));\n};\n\nconst getIndex = (offsetFromStart: BN) => {\n  return offsetFromStart.div(new BN(8));\n};\n\nconst getOffsetFromRight = (offsetFromStart: BN) => {\n  return new BN(7).sub(offsetFromStart.mod(new BN(8)));\n};\n\nconst getIndexAndMask = (edition: BN) => {\n  const offsetFromStart = getOffsetFromStart(edition);\n  return {\n    index: getIndex(offsetFromStart).toNumber(),\n    mask: new BN(1).shln(getOffsetFromRight(offsetFromStart).toNumber()).toNumber(),\n  };\n};\n\nconst editionTaken = (marker : Array<number>, edition : BN) : boolean => {\n  let m = getIndexAndMask(edition);\n  return (marker[m.index] & m.mask) !== 0;\n}\n\nconst setEditionTaken = (marker : Array<number>, edition : BN) => {\n  let m = getIndexAndMask(edition);\n  marker[m.index] = marker[m.index] | m.mask;\n}\n\nexport const validateEditionClaims = async (\n  connection : RPCConnection,\n  env : string,\n  walletKey : PublicKey,\n  claimants : Claimants,\n  masterMintStr : string,\n) : Promise<ClaimInfo> => {\n  claimants.forEach((c, idx) => {\n    if (!c.handle) throw new Error(`Claimant ${idx} doesn't have handle`);\n    if (c.amount !== 1) {\n      throw new Error(`Claimant ${idx} has amount ${c.amount}. Expected 1 for edition gumdrop`);\n    }\n  });\n\n  const total = claimants.reduce((acc, c) => acc + c.amount, 0);\n  const masterMint = await getMintInfo(connection, masterMintStr);\n  const masterTokenAccount = await getCreatorTokenAccount(\n    walletKey,\n    connection,\n    masterMint.key,\n    1 // just check that the creator has the master mint\n  );\n\n  const masterEditionKey = await getEdition(masterMint.key);\n  const masterEdition = await connection.getAccountInfo(masterEditionKey);\n  if (masterEdition === null) {\n    throw new Error(`Could not fetch master edition`);\n  }\n  console.log(\"Master edition\", masterEdition);\n\n  // maxSupply is an option, 9 bytes, first is 0 means is none\n  const currentSupply = new BN(masterEdition.data.slice(1, 1+8), 8, \"le\").toNumber();\n  let maxSupply;\n  if (masterEdition.data[9] === 0) {\n      maxSupply = null;\n  } else {\n      maxSupply = new BN(masterEdition.data.slice(10, 10+8), 8, \"le\").toNumber();\n  }\n  console.log(\"Max supply\", maxSupply);\n  console.log(\"Current supply\", currentSupply);\n\n  if (maxSupply !== null && maxSupply < total) {\n    throw new Error(`Distributor is allocated more editions (${total}) `\n                  + `than the master has total (${maxSupply})`);\n  }\n\n  // Whether an edition has been claimed is a single bit in a paginated account\n  // (pda off of master mint). The following code does some sanity checks\n  // around max supply and internally whether the distribution list has\n  // duplicate editions, and also checks if the editions were already taken on\n  // chain.\n  //\n  // There is a race condition since the authority to mint is still currently\n  // the wallet but it seems like a user error to have other editions being\n  // minted while a gumdrop is being created\n  const editions : { [key: number]: number } = {};\n  const editionMarkers : Array<[PublicKey, Array<number>]> = [];\n  for (let idx = 0; idx < claimants.length; ++idx ) {\n    const c = claimants[idx];\n    if (c.edition === undefined) throw new Error(`Claimant ${idx} doesn't have edition`);\n    if (c.edition >= maxSupply) {\n      throw new Error(`Claimant ${idx} assigned edition ${c.edition} which is beyond the max supply`);\n    }\n    if (c.edition in editions) {\n      throw new Error(`Claimant ${idx} and ${editions[c.edition]} are both assigned to edition ${c.edition}`);\n    }\n    const edition = new BN(c.edition);\n    const markerKey = await getEditionMarkerPda(masterMint.key, edition);\n    let markerData = editionMarkers.find(pm => pm[0].equals(markerKey));\n    if (markerData === undefined) {\n      const markerAcc = await connection.getAccountInfo(markerKey);\n      if (markerAcc === null) {\n        editionMarkers.push([markerKey, Array<number>(31)]);\n      } else {\n        editionMarkers.push([markerKey, [...markerAcc.data.slice(1, 32)]]);\n      }\n      markerData = editionMarkers[editionMarkers.length - 1];\n    }\n\n    if (markerData === undefined) {\n      throw new Error(`Internal Error: Edition marker info still undefined ${c.edition}`);\n    }\n\n    if (editionTaken(markerData[1], edition)) {\n      throw new Error(`Claimant ${idx} is assigned to edition ${c.edition} which is already taken`);\n    }\n\n    setEditionTaken(markerData[1], edition);\n\n    editions[c.edition] = idx;\n  }\n\n  return {\n    total: total,\n    masterMint: masterMint,\n    masterTokenAccount: masterTokenAccount,\n    info: { type: \"Edition\", meta: explorerUrlFor(env, masterMint.key) },\n  };\n}\n\n\nexport const buildGumdrop = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  needsPin : boolean,\n  claimIntegration : string,\n  host : string,\n  baseKey : PublicKey,\n  temporalSigner : PublicKey,\n  claimants : Claimants,\n  claimInfo  : ClaimInfo,\n) : Promise<Array<TransactionInstruction>> => {\n\n  const leafs : Array<Buffer> = [];\n  for (let idx = 0; idx < claimants.length; ++idx ) {\n    const claimant = claimants[idx];\n    if (!needsPin) {\n      try {\n        claimant.secret = new PublicKey(claimant.handle);\n      } catch (err) {\n        throw new Error(`Invalid claimant wallet handle ${err}`);\n      }\n    } else {\n      const seeds = [\n        claimant.seed.toBuffer(),\n        Buffer.from(claimant.handle),\n        Buffer.from(claimant.pin.toArray(\"le\", 4)),\n      ];\n      const [claimantPda, ] = await PublicKey.findProgramAddress(\n          seeds, GUMDROP_DISTRIBUTOR_ID);\n      claimant.secret = claimantPda;\n    }\n    // TODO: get this clarified with jordan... we can either just assign some\n    // range of editions to a user or give them an amount and just keep a\n    // counter on the distributor... the latter is much less work but we lose\n    // the ability to use gumdrop for auction house winnings and such?\n    const extra = claimIntegration === \"edition\"\n      ? [...new BN(claimant.edition).toArray(\"le\", 8)]\n      : []\n    leafs.push(Buffer.from(\n      [...new BN(idx).toArray(\"le\", 8),\n       ...claimant.secret.toBuffer(),\n       ...claimant.seed.toBuffer(),\n       ...new BN(claimant.amount).toArray(\"le\", 8),\n       ...extra\n      ]\n    ));\n  }\n\n  const tree = new MerkleTree(leafs);\n  const root = tree.getRoot();\n\n  const [distributor, dbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"MerkleDistributor\"),\n      baseKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID);\n\n  for (let idx = 0; idx < claimants.length; ++idx) {\n    const proof = tree.getProof(idx);\n    const verified = tree.verifyProof(idx, proof, root);\n\n    if (!verified) {\n      throw new Error(\"Gumdrop merkle tree verification failed\");\n    }\n\n    const claimant = claimants[idx];\n    const params = [\n      `distributor=${distributor}`,\n      `handle=${claimant.handle}`,\n      `amount=${claimant.amount}`,\n      `index=${idx}`,\n      `proof=${proof.map(b => bs58.encode(b))}`,\n    ];\n    if (needsPin) {\n      params.push(`pin=${claimant.pin.toNumber()}`);\n    }\n    if (claimIntegration === \"transfer\") {\n      params.push(`tokenAcc=${claimInfo.source}`);\n    } else if (claimIntegration === \"candy\") {\n      params.push(`config=${claimInfo.config}`);\n      params.push(`uuid=${claimInfo.uuid}`);\n    } else {\n      params.push(`master=${claimInfo.masterMint.key}`);\n      params.push(`edition=${claimant.edition}`);\n    }\n    const query = params.join(\"&\");\n\n    claimant.url = `${host}#/claim?${query}`;\n  }\n\n  // initial merkle-distributor state\n  const instructions = Array<TransactionInstruction>();\n  instructions.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: baseKey                 , isSigner: true  , isWritable: false } ,\n          { pubkey: distributor             , isSigner: false , isWritable: true  } ,\n          { pubkey: walletKey               , isSigner: true  , isWritable: false } ,\n          { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:new_distributor\")).slice(0, 8),\n        ...new BN(dbump).toArray(\"le\", 1),\n        ...root,\n        ...temporalSigner.toBuffer(),\n      ])\n  }));\n\n  if (claimIntegration === \"transfer\") {\n    instructions.push(Token.createApproveInstruction(\n      TOKEN_PROGRAM_ID,\n      claimInfo.source,\n      distributor,\n      walletKey,\n      [],\n      claimInfo.total\n    ));\n  } else if (claimIntegration === \"candy\") {\n    const [distributorWalletKey, ] = await PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"Wallet\"),\n        distributor.toBuffer(),\n      ],\n      GUMDROP_DISTRIBUTOR_ID\n    );\n\n    instructions.push(new TransactionInstruction({\n        programId: CANDY_MACHINE_ID,\n        keys: [\n            { pubkey: claimInfo.candyMachineKey,isSigner: false , isWritable: true  } ,\n            { pubkey: walletKey               , isSigner: true  , isWritable: false } ,\n        ],\n        data: Buffer.from([\n          ...Buffer.from(sha256.digest(\"global:update_authority\")).slice(0, 8),\n          ...new BN(1).toArray(\"le\", 1),  // optional exists...\n          ...distributorWalletKey.toBuffer(),\n        ])\n    }));\n  } else if (claimIntegration === \"edition\") {\n    // transfer master edition to distributor\n    const [distributorTokenKey, ] = await PublicKey.findProgramAddress(\n      [\n        distributor.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        claimInfo.masterMint.key.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    );\n\n    instructions.push(Token.createAssociatedTokenAccountInstruction(\n        SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n        TOKEN_PROGRAM_ID,\n        claimInfo.masterMint.key,\n        distributorTokenKey,\n        distributor,\n        walletKey,\n      ));\n\n    instructions.push(Token.createTransferInstruction(\n        TOKEN_PROGRAM_ID,\n        claimInfo.masterTokenAccount,\n        distributorTokenKey,\n        walletKey,\n        [],\n        1\n      ));\n  }\n\n  return instructions;\n}\n\nexport const closeGumdrop = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  base : Keypair,\n  claimMethod : string,\n  candyConfig : string,\n  candyUuid : string,\n  masterMint : string,\n) : Promise<Array<TransactionInstruction>> => {\n  const [distributorKey, dbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"MerkleDistributor\"),\n      base.publicKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID);\n\n  const [distributorWalletKey, wbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"Wallet\"),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  let extraKeys;\n  if (claimMethod === \"candy\") {\n    const configKey = await getCandyConfig(connection, candyConfig);\n    const [candyMachineKey, ] = await getCandyMachineAddress(\n      configKey, candyUuid);\n\n   extraKeys = [\n          { pubkey: candyMachineKey         , isSigner: false , isWritable: true  } ,\n          { pubkey: CANDY_MACHINE_ID        , isSigner: false , isWritable: false } ,\n    ];\n  } else {\n    extraKeys = [];\n  }\n\n  const instructions = Array<TransactionInstruction>();\n  if (claimMethod === \"edition\") {\n    let masterMintKey: PublicKey;\n    try {\n      masterMintKey = new PublicKey(masterMint);\n    } catch (err) {\n      throw new Error(`Invalid mint key ${err}`);\n    }\n    const [distributorTokenKey, ] = await PublicKey.findProgramAddress(\n      [\n        distributorKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        masterMintKey.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    );\n\n    const [walletTokenKey, ] = await PublicKey.findProgramAddress(\n      [\n        walletKey.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        masterMintKey.toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    );\n\n    instructions.push(new TransactionInstruction({\n        programId: GUMDROP_DISTRIBUTOR_ID,\n        keys: [\n            { pubkey: base.publicKey          , isSigner: true  , isWritable: false } ,\n            { pubkey: distributorKey          , isSigner: false , isWritable: false } ,\n            { pubkey: distributorTokenKey     , isSigner: false , isWritable: true  } ,\n            { pubkey: walletTokenKey          , isSigner: false , isWritable: true  } ,\n            { pubkey: walletKey               , isSigner: false , isWritable: true  } ,\n            { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\n            { pubkey: TOKEN_PROGRAM_ID        , isSigner: false , isWritable: false } ,\n        ],\n        data: Buffer.from([\n          ...Buffer.from(sha256.digest(\"global:close_distributor_token_account\")).slice(0, 8),\n          ...new BN(dbump).toArray(\"le\", 1),\n        ])\n    }));\n  }\n\n  instructions.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: base.publicKey          , isSigner: true  , isWritable: false } ,\n          { pubkey: distributorKey          , isSigner: false , isWritable: true  } ,\n          { pubkey: distributorWalletKey    , isSigner: false , isWritable: true  } ,\n          { pubkey: walletKey               , isSigner: true  , isWritable: true  } ,\n          { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_PROGRAM_ID        , isSigner: false , isWritable: false } ,\n          ...extraKeys,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:close_distributor\")).slice(0, 8),\n        ...new BN(dbump).toArray(\"le\", 1),\n        ...new BN(wbump).toArray(\"le\", 1),\n      ])\n  }));\n\n  return instructions;\n}\n","import { keccak_256 } from \"js-sha3\";\n\nexport class MerkleTree {\n  leafs: Array<Buffer>;\n  layers: Array<Array<Buffer>>;\n\n  constructor(leafs : Array<Buffer>) {\n    this.leafs = leafs.slice();\n    this.layers = [];\n\n    let hashes = this.leafs.map(MerkleTree.nodeHash);\n    while (hashes.length > 0) {\n      console.log(\"Hashes\", this.layers.length, hashes);\n      this.layers.push(hashes.slice());\n      if (hashes.length === 1) break;\n      hashes = hashes.reduce((acc, cur, idx, arr) => {\n        if (idx % 2 === 0) {\n          const nxt = arr[idx + 1];\n          acc.push(MerkleTree.internalHash(cur, nxt));\n        }\n        return acc;\n      }, Array<Buffer>());\n    }\n  }\n\n  static nodeHash(\n    data : Buffer,\n  ) : Buffer {\n    return Buffer.from(keccak_256.digest([0x00, ...data]));\n  }\n\n\n  static internalHash(\n    first : Buffer,\n    second : Buffer | undefined,\n  ) : Buffer {\n    if (!second) return first;\n    const [fst, snd] = [first, second].sort(Buffer.compare)\n    return Buffer.from(\n      keccak_256.digest([0x01, ...fst, ...snd])\n    );\n  }\n\n  getRoot() : Buffer {\n    return this.layers[this.layers.length - 1][0];\n  }\n\n  getProof(idx : number) : Buffer[] {\n    return this.layers.reduce((proof, layer) => {\n      const sibling = idx ^ 1;\n      if (sibling < layer.length) {\n        proof.push(layer[sibling]);\n      }\n\n      idx = Math.floor(idx / 2);\n\n      return proof;\n    }, []);\n  }\n\n  getHexRoot(): string {\n    return this.getRoot().toString(\"hex\");\n  }\n\n  getHexProof(idx : number) : string[] {\n    return this.getProof(idx).map((el) => el.toString(\"hex\"));\n  }\n\n  verifyProof(\n    idx : number,\n    proof : Buffer[],\n    root : Buffer\n  ): boolean {\n    let pair = MerkleTree.nodeHash(this.leafs[idx]);\n    for (const item of proof) {\n      pair = MerkleTree.internalHash(pair, item);\n    }\n\n    return pair.equals(root);\n  }\n\n  static verifyClaim(\n    leaf : Buffer,\n    proof : Buffer[],\n    root : Buffer\n  ): boolean {\n    let pair = MerkleTree.nodeHash(leaf);\n    for (const item of proof) {\n      pair = MerkleTree.internalHash(pair, item);\n    }\n\n    return pair.equals(root);\n  }\n\n}\n","import {\n  TOKEN_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  BPF_UPGRADE_LOADER_ID,\n  SYSTEM,\n  MEMO_ID,\n} from './ids';\n\nexport const setProgramIds = async () => {};\n\nexport const programIds = () => {\n  return {\n    token: TOKEN_PROGRAM_ID,\n    associatedToken: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    bpf_upgrade_loader: BPF_UPGRADE_LOADER_ID,\n    system: SYSTEM,\n    memo: MEMO_ID,\n    // store: STORE,\n  };\n};\n","import React from \"react\";\nimport { Modal } from \"antd\";\n\nimport \"./index.css\";\n\nexport const DefaultModal = (props: any) => {\n  const { children, closeIcon, bodyStyle, width, style, ...rest } = props;\n\n  return (\n    <Modal\n      style={{ background: \"transparent\", borderRadius: 16 }}\n      bodyStyle={{\n        background: \"#333333\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        ...bodyStyle,\n      }}\n      footer={null}\n      width={\n        width || 400\n      }\n      {...rest}\n    >\n      {children}\n    </Modal>\n  );\n};\n","import React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useState,\n} from 'react';\nimport { useConnection } from './ConnectionContext';\nimport { useWallet } from '@solana/wallet-adapter-react';\nimport { AccountInfo, Connection, PublicKey } from '@solana/web3.js';\nimport { AccountLayout, MintInfo, MintLayout, u64 } from '@solana/spl-token';\nimport { TokenAccount } from '../models';\nimport { chunks } from '../utils/utils';\nimport { EventEmitter } from '../utils/eventEmitter';\nimport { StringPublicKey, WRAPPED_SOL_MINT } from '../utils/ids';\nimport { programIds } from '../utils/programIds';\n\nconst AccountsContext = React.createContext<any>(null);\n\nconst pendingCalls = new Map<string, Promise<ParsedAccountBase>>();\nconst genericCache = new Map<string, ParsedAccountBase>();\nconst pendingMintCalls = new Map<string, Promise<MintInfo>>();\nconst mintCache = new Map<string, MintInfo>();\n\nexport interface ParsedAccountBase {\n  pubkey: StringPublicKey;\n  account: AccountInfo<Buffer>;\n  info: any; // TODO: change to unknown\n}\n\nexport type AccountParser = (\n  pubkey: StringPublicKey,\n  data: AccountInfo<Buffer>,\n) => ParsedAccountBase | undefined;\n\nexport interface ParsedAccount<T> extends ParsedAccountBase {\n  info: T;\n}\n\nconst getMintInfo = async (connection: Connection, pubKey: PublicKey) => {\n  const info = await connection.getAccountInfo(pubKey);\n  if (info === null) {\n    throw new Error('Failed to find mint account');\n  }\n\n  const data = Buffer.from(info.data);\n\n  return deserializeMint(data);\n};\n\nexport const MintParser = (pubKey: string, info: AccountInfo<Buffer>) => {\n  const buffer = Buffer.from(info.data);\n\n  const data = deserializeMint(buffer);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: data,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const TokenAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  // Sometimes a wrapped sol account gets closed, goes to 0 length,\n  // triggers an update over wss which triggers this guy to get called\n  // since your UI already logged that pubkey as a token account. Check for length.\n  if (info.data.length > 0) {\n    const buffer = Buffer.from(info.data);\n    const data = deserializeAccount(buffer);\n\n    const details = {\n      pubkey: pubKey,\n      account: {\n        ...info,\n      },\n      info: data,\n    } as TokenAccount;\n\n    return details;\n  }\n};\n\nexport const GenericAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  const buffer = Buffer.from(info.data);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: buffer,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const keyToAccountParser = new Map<string, AccountParser>();\n\nexport const cache = {\n  emitter: new EventEmitter(),\n  query: async (\n    connection: Connection,\n    pubKey: string | PublicKey,\n    parser?: AccountParser,\n  ) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n\n    let account = genericCache.get(address);\n    if (account) {\n      return account;\n    }\n\n    let query = pendingCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    // TODO: refactor to use multiple accounts query with flush like behavior\n    query = connection.getAccountInfo(id).then(data => {\n      if (!data) {\n        throw new Error('Account not found');\n      }\n\n      return cache.add(id, data, parser);\n    }) as Promise<TokenAccount>;\n    pendingCalls.set(address, query as any);\n\n    return query;\n  },\n  add: (\n    id: PublicKey | string,\n    obj: AccountInfo<Buffer>,\n    parser?: AccountParser,\n    isActive?: boolean | undefined | ((parsed: any) => boolean),\n  ) => {\n    const address = typeof id === 'string' ? id : id?.toBase58();\n    const deserialize = parser ? parser : keyToAccountParser.get(address);\n    if (!deserialize) {\n      throw new Error(\n        'Deserializer needs to be registered or passed as a parameter',\n      );\n    }\n\n    cache.registerParser(id, deserialize);\n    pendingCalls.delete(address);\n    const account = deserialize(address, obj);\n    if (!account) {\n      return;\n    }\n\n    if (isActive === undefined) isActive = true;\n    else if (isActive instanceof Function) isActive = isActive(account);\n\n    const isNew = !genericCache.has(address);\n\n    genericCache.set(address, account);\n    cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);\n    return account;\n  },\n  get: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return genericCache.get(key);\n  },\n  delete: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    if (genericCache.get(key)) {\n      genericCache.delete(key);\n      cache.emitter.raiseCacheDeleted(key);\n      return true;\n    }\n    return false;\n  },\n\n  byParser: (parser: AccountParser) => {\n    const result: string[] = [];\n    for (const id of keyToAccountParser.keys()) {\n      if (keyToAccountParser.get(id) === parser) {\n        result.push(id);\n      }\n    }\n\n    return result;\n  },\n  registerParser: (pubkey: PublicKey | string, parser: AccountParser) => {\n    if (pubkey) {\n      const address = typeof pubkey === 'string' ? pubkey : pubkey?.toBase58();\n      keyToAccountParser.set(address, parser);\n    }\n\n    return pubkey;\n  },\n  queryMint: async (connection: Connection, pubKey: string | PublicKey) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    let mint = mintCache.get(address);\n    if (mint) {\n      return mint;\n    }\n\n    let query = pendingMintCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    query = getMintInfo(connection, id).then(data => {\n      pendingMintCalls.delete(address);\n\n      mintCache.set(address, data);\n      return data;\n    }) as Promise<MintInfo>;\n    pendingMintCalls.set(address, query as any);\n\n    return query;\n  },\n  getMint: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return mintCache.get(key);\n  },\n  addMint: (pubKey: PublicKey, obj: AccountInfo<Buffer>) => {\n    const mint = deserializeMint(obj.data);\n    const id = pubKey.toBase58();\n    mintCache.set(id, mint);\n    return mint;\n  },\n};\n\nexport const useAccountsContext = () => {\n  const context = useContext(AccountsContext);\n\n  return context;\n};\n\nfunction wrapNativeAccount(\n  pubkey: string,\n  account?: AccountInfo<Buffer>,\n): TokenAccount | undefined {\n  if (!account) {\n    return undefined;\n  }\n\n  const key = new PublicKey(pubkey);\n\n  return {\n    pubkey: pubkey,\n    account,\n    info: {\n      address: key,\n      mint: WRAPPED_SOL_MINT,\n      owner: key,\n      amount: new u64(account.lamports),\n      delegate: null,\n      delegatedAmount: new u64(0),\n      isInitialized: true,\n      isFrozen: false,\n      isNative: true,\n      rentExemptReserve: null,\n      closeAuthority: null,\n    },\n  };\n}\n\nexport const getCachedAccount = (\n  predicate: (account: TokenAccount) => boolean,\n) => {\n  for (const account of genericCache.values()) {\n    if (predicate(account)) {\n      return account as TokenAccount;\n    }\n  }\n};\n\nconst UseNativeAccount = () => {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n\n  const [nativeAccount, setNativeAccount] = useState<AccountInfo<Buffer>>();\n\n  const updateCache = useCallback(\n    account => {\n      if (publicKey) {\n        const wrapped = wrapNativeAccount(publicKey.toBase58(), account);\n        if (wrapped !== undefined) {\n          const id = publicKey.toBase58();\n          cache.registerParser(id, TokenAccountParser);\n          genericCache.set(id, wrapped as TokenAccount);\n          cache.emitter.raiseCacheUpdated(id, false, TokenAccountParser, true);\n        }\n      }\n    },\n    [publicKey],\n  );\n\n  useEffect(() => {\n    let subId = 0;\n    const updateAccount = (account: AccountInfo<Buffer> | null) => {\n      if (account) {\n        updateCache(account);\n        setNativeAccount(account);\n      }\n    };\n\n    (async () => {\n      if (!connection || !publicKey) {\n        return;\n      }\n\n      try {\n        const account = await connection.getAccountInfo(publicKey);\n        updateAccount(account);\n      } catch {\n        return;\n      }\n\n      subId = connection.onAccountChange(publicKey, updateAccount);\n    })();\n\n    return () => {\n      if (subId) {\n        connection.removeAccountChangeListener(subId);\n      }\n    };\n  }, [setNativeAccount, publicKey, connection, updateCache]);\n\n  return { nativeAccount };\n};\n\nconst PRECACHED_OWNERS = new Set<string>();\nconst precacheUserTokenAccounts = async (\n  connection: Connection,\n  owner?: PublicKey,\n) => {\n  if (!owner) {\n    return;\n  }\n\n  // used for filtering account updates over websocket\n  PRECACHED_OWNERS.add(owner.toBase58());\n\n  // user accounts are updated via ws subscription\n  const accounts = await connection.getTokenAccountsByOwner(owner, {\n    programId: programIds().token,\n  });\n\n  accounts.value.forEach(info => {\n    cache.add(info.pubkey.toBase58(), info.account, TokenAccountParser);\n  });\n};\n\nexport function AccountsProvider({ children = null as any }) {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n  const [tokenAccounts, setTokenAccounts] = useState<TokenAccount[]>([]);\n  const [userAccounts, setUserAccounts] = useState<TokenAccount[]>([]);\n  const { nativeAccount } = UseNativeAccount();\n  const walletKey = publicKey?.toBase58();\n\n  const selectUserAccounts = useCallback(() => {\n    return cache\n      .byParser(TokenAccountParser)\n      .map(id => cache.get(id))\n      .filter(a => a && a.info.owner.toBase58() === walletKey)\n      .map(a => a as TokenAccount);\n  }, [walletKey]);\n\n  useEffect(() => {\n    const accounts = selectUserAccounts().filter(\n      a => a !== undefined,\n    ) as TokenAccount[];\n    setUserAccounts(accounts);\n  }, [nativeAccount, tokenAccounts, selectUserAccounts]);\n\n  useEffect(() => {\n    const subs: number[] = [];\n    cache.emitter.onCache(args => {\n      if (args.isNew && args.isActive) {\n        let id = args.id;\n        let deserialize = args.parser;\n        connection.onAccountChange(new PublicKey(id), info => {\n          cache.add(id, info, deserialize);\n        });\n      }\n    });\n\n    return () => {\n      subs.forEach(id => connection.removeAccountChangeListener(id));\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    if (!connection || !publicKey) {\n      setTokenAccounts([]);\n    } else {\n      precacheUserTokenAccounts(connection, publicKey).then(() => {\n        setTokenAccounts(selectUserAccounts());\n      });\n\n      // This can return different types of accounts: token-account, mint, multisig\n      // TODO: web3.js expose ability to filter.\n      // this should use only filter syntax to only get accounts that are owned by user\n      const tokenSubID = connection.onProgramAccountChange(\n        programIds().token,\n        info => {\n          // TODO: fix type in web3.js\n          const id = info.accountId as unknown as string;\n          // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\n          if (info.accountInfo.data.length === AccountLayout.span) {\n            const data = deserializeAccount(info.accountInfo.data);\n\n            if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\n              cache.add(id, info.accountInfo, TokenAccountParser);\n              setTokenAccounts(selectUserAccounts());\n            }\n          }\n        },\n        'singleGossip',\n      );\n\n      return () => {\n        connection.removeProgramAccountChangeListener(tokenSubID);\n      };\n    }\n  }, [connection, publicKey, selectUserAccounts]);\n\n  return (\n    <AccountsContext.Provider\n      value={{\n        userAccounts,\n        nativeAccount,\n      }}\n    >\n      {children}\n    </AccountsContext.Provider>\n  );\n}\n\nexport function useNativeAccount() {\n  const context = useContext(AccountsContext);\n  return {\n    account: context.nativeAccount as AccountInfo<Buffer>,\n  };\n}\n\nexport const getMultipleAccounts = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const result = await Promise.all(\n    chunks(keys, 99).map(chunk =>\n      getMultipleAccountsCore(connection, chunk, commitment),\n    ),\n  );\n\n  const array = result\n    .map(\n      a =>\n        a.array.map(acc => {\n          if (!acc) {\n            return undefined;\n          }\n\n          const { data, ...rest } = acc;\n          const obj = {\n            ...rest,\n            data: Buffer.from(data[0], 'base64'),\n          } as AccountInfo<Buffer>;\n          return obj;\n        }) as AccountInfo<Buffer>[],\n    )\n    .flat();\n  return { keys, array };\n};\n\nconst getMultipleAccountsCore = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const args = connection._buildArgs([keys], commitment, 'base64');\n\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\n  if (unsafeRes.error) {\n    throw new Error(\n      'failed to get info about account ' + unsafeRes.error.message,\n    );\n  }\n\n  if (unsafeRes.result.value) {\n    const array = unsafeRes.result.value as AccountInfo<string[]>[];\n    return { keys, array };\n  }\n\n  // TODO: fix\n  throw new Error();\n};\n\nexport function useMint(key?: string | PublicKey) {\n  const connection = useConnection();\n  const [mint, setMint] = useState<MintInfo>();\n\n  const id = typeof key === 'string' ? key : key?.toBase58();\n\n  useEffect(() => {\n    if (!id) {\n      return;\n    }\n\n    cache\n      .query(connection, id, MintParser)\n      .then(acc => setMint(acc.info as any))\n      .catch(err => console.log(err));\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === id) {\n        cache\n          .query(connection, id, MintParser)\n          .then(mint => setMint(mint.info as any));\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, id]);\n\n  return mint;\n}\n\nexport function useAccount(pubKey?: PublicKey) {\n  const connection = useConnection();\n  const [account, setAccount] = useState<TokenAccount>();\n\n  const key = pubKey?.toBase58();\n  useEffect(() => {\n    const query = async () => {\n      try {\n        if (!key) {\n          return;\n        }\n\n        const acc = await cache\n          .query(connection, key, TokenAccountParser)\n          .catch(err => console.log(err));\n        if (acc) {\n          setAccount(acc);\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    query();\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === key) {\n        query();\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, key]);\n\n  return account;\n}\n\n// TODO: expose in spl package\nexport const deserializeAccount = (data: Buffer) => {\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n};\n\n// TODO: expose in spl package\nexport const deserializeMint = (data: Buffer) => {\n  if (data.length !== MintLayout.span) {\n    throw new Error('Not a valid Mint');\n  }\n\n  const mintInfo = MintLayout.decode(data);\n\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n\n  return mintInfo as MintInfo;\n};\n","import { EventEmitter as Emitter } from 'eventemitter3';\n\nexport class CacheUpdateEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  parser: any;\n  isNew: boolean;\n  isActive: boolean;\n  constructor(id: string, isNew: boolean, parser: any, isActive: boolean) {\n    this.id = id;\n    this.parser = parser;\n    this.isNew = isNew;\n    this.isActive = isActive;\n  }\n}\n\nexport class CacheDeleteEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  constructor(id: string) {\n    this.id = id;\n  }\n}\n\nexport class MarketUpdateEvent {\n  static type = 'MarketUpdate';\n  ids: Set<string>;\n  constructor(ids: Set<string>) {\n    this.ids = ids;\n  }\n}\n\nexport class EventEmitter {\n  private emitter = new Emitter();\n\n  onMarket(callback: (args: MarketUpdateEvent) => void) {\n    this.emitter.on(MarketUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(MarketUpdateEvent.type, callback);\n  }\n\n  onCache(callback: (args: CacheUpdateEvent) => void) {\n    this.emitter.on(CacheUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(CacheUpdateEvent.type, callback);\n  }\n\n  raiseMarketUpdated(ids: Set<string>) {\n    this.emitter.emit(MarketUpdateEvent.type, new MarketUpdateEvent(ids));\n  }\n\n  raiseCacheUpdated(\n    id: string,\n    isNew: boolean,\n    parser: any,\n    isActive: boolean,\n  ) {\n    this.emitter.emit(\n      CacheUpdateEvent.type,\n      new CacheUpdateEvent(id, isNew, parser, isActive),\n    );\n  }\n\n  raiseCacheDeleted(id: string) {\n    this.emitter.emit(CacheDeleteEvent.type, new CacheDeleteEvent(id));\n  }\n}\n","import { useCallback } from \"react\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { ENDPOINTS, useColorMode, useConnectionConfig } from \"../../contexts\";\nimport { notify, shortenAddress } from \"../../utils\";\nimport { CopyOutlined } from \"@ant-design/icons\";\nimport { ModalEnum, useModal, useWalletModal } from \"../../contexts\";\nimport { Box } from \"@mui/system\";\nimport { Button, FormControl, NativeSelect } from \"@mui/material\";\nimport { useTheme } from \"@mui/material/styles\";\nimport IconButton from \"@mui/material/IconButton\";\nimport Brightness4Icon from \"@mui/icons-material/Brightness4\";\nimport Brightness7Icon from \"@mui/icons-material/Brightness7\";\n\nexport const Settings = ({\n  additionalSettings,\n}: {\n  additionalSettings?: JSX.Element;\n}) => {\n  const { connected, disconnect, publicKey } = useWallet();\n  const { setEndpoint, env, endpoint } = useConnectionConfig();\n  const { setVisible } = useWalletModal();\n  const open = useCallback(() => setVisible(true), [setVisible]);\n  const { setModal } = useModal();\n  const theme = useTheme();\n  const colorModeCtx = useColorMode();\n\n  const handleConnect = useCallback(() => {\n    setModal(ModalEnum.WALLET);\n    setVisible(true);\n  }, [setModal, setVisible]);\n\n  return (\n    <>\n      <Box sx={{ display: \"flex\", minWidth: \"100%\" }}>\n        {!connected && (\n          <>\n            <FormControl>\n              <NativeSelect\n                style={{ marginBottom: 5 }}\n                onChange={(e) => {\n                  setEndpoint(e.target.value);\n                }}\n                value={endpoint}\n              >\n                {ENDPOINTS.map(({ name, endpoint }) => (\n                  <option key={name} value={endpoint}>{name}</option>\n                ))}\n              </NativeSelect>\n            </FormControl>\n            <Button\n              variant=\"contained\"\n              onClick={handleConnect}\n              sx={{ marginLeft: \"10px\" }}\n            >\n              Connect\n            </Button>\n          </>\n        )}\n        {connected && (\n          <>\n            {publicKey && (\n              <Button\n                variant=\"outlined\"\n                onClick={async () => {\n                  if (publicKey) {\n                    await navigator.clipboard.writeText(publicKey.toBase58());\n                    notify({\n                      message: \"Wallet update\",\n                      description: \"Address copied to clipboard\",\n                    });\n                  }\n                }}\n              >\n                <CopyOutlined />\n                {shortenAddress(publicKey.toBase58())}\n              </Button>\n            )}\n            <Button\n              variant=\"outlined\"\n              onClick={open}\n              sx={{ marginLeft: \"10px\" }}\n            >\n              Change Wallet\n            </Button>\n            <Button\n              variant=\"contained\"\n              color=\"error\"\n              onClick={() => disconnect().catch()}\n              sx={{ marginLeft: \"10px\" }}\n            >\n              Disconnect ({env})\n            </Button>\n          </>\n        )}\n        <IconButton\n          sx={{ ml: 1 }}\n          onClick={colorModeCtx.toggleColorMode}\n          color=\"inherit\"\n        >\n          {theme.palette.mode === \"dark\" ? (\n            <Brightness7Icon />\n          ) : (\n            <Brightness4Icon />\n          )}\n        </IconButton>\n        {additionalSettings}\n      </Box>\n    </>\n  );\n};\n","import { useTheme } from \"@mui/material\";\nimport React, { useContext } from \"react\";\n\nexport const ColorModeContext = React.createContext({});\n\nexport const ColorModeContextProvider = ({children=null as any }) => {\n  const [mode, setMode] = React.useState<'light' | 'dark'>('dark'); \n  const theme = useTheme();\n  const toggleColorMode = () => {\n    setMode((prevMode) => (prevMode === 'light' ? 'dark' : 'light'));\n  }\n  return (\n    <ColorModeContext.Provider\n      value={{\n        toggleColorMode,\n        mode,\n        theme,\n      }}\n    >\n      {children}\n    </ColorModeContext.Provider>\n  );\n};\n\nexport const useColorMode = (): any => {\n  const context = useContext(ColorModeContext);\n  return context;\n};\n","import {\n  Coder,\n} from \"@project-serum/anchor\"\n\nconst idl = require(\"./merkle_distributor.json\");\nexport const coder = new Coder(idl);\n\n","import React from 'react';\nimport { notification } from 'antd';\n// import Link from '../components/Link';\n\nexport function notify({\n  message = '',\n  description = undefined as any,\n  txid = '',\n  type = 'info',\n  placement = 'bottomLeft',\n}) {\n  if (txid) {\n    //   <Link\n    //     external\n    //     to={'https://explorer.solana.com/tx/' + txid}\n    //     style={{ color: '#0000ff' }}\n    //   >\n    //     View transaction {txid.slice(0, 8)}...{txid.slice(txid.length - 8)}\n    //   </Link>\n\n    description = <></>;\n  }\n  (notification as any)[type]({\n    message: <span style={{ color: 'black' }}>{message}</span>,\n    description: (\n      <span style={{ color: 'black', opacity: 0.5 }}>{description}</span>\n    ),\n    placement,\n    style: {\n      backgroundColor: 'white',\n    },\n  });\n}\n","import { PublicKey } from '@solana/web3.js';\nimport { BinaryReader, BinaryWriter } from 'borsh';\nimport base58 from 'bs58';\nimport { StringPublicKey } from './ids';\n\nexport const extendBorsh = () => {\n  (BinaryReader.prototype as any).readPubkey = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return new PublicKey(array);\n  };\n\n  (BinaryWriter.prototype as any).writePubkey = function (value: PublicKey) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(value.toBuffer());\n  };\n\n  (BinaryReader.prototype as any).readPubkeyAsString = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return base58.encode(array) as StringPublicKey;\n  };\n\n  (BinaryWriter.prototype as any).writePubkeyAsString = function (\n    value: StringPublicKey,\n  ) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(base58.decode(value));\n  };\n};\n\nextendBorsh();\n","import { PublicKey, AccountInfo } from '@solana/web3.js';\n\nexport type StringPublicKey = string;\n\nexport class LazyAccountInfoProxy<T> {\n  executable: boolean = false;\n  owner: StringPublicKey = '';\n  lamports: number = 0;\n\n  get data() {\n    //\n    return undefined as unknown as T;\n  }\n}\n\nexport interface LazyAccountInfo {\n  executable: boolean;\n  owner: StringPublicKey;\n  lamports: number;\n  data: [string, string];\n}\n\nconst PubKeysInternedMap = new Map<string, PublicKey>();\n\nexport const toPublicKey = (key: string | PublicKey) => {\n  if (typeof key !== 'string') {\n    return key;\n  }\n\n  let result = PubKeysInternedMap.get(key);\n  if (!result) {\n    result = new PublicKey(key);\n    PubKeysInternedMap.set(key, result);\n  }\n\n  return result;\n};\n\nexport interface PublicKeyStringAndAccount<T> {\n  pubkey: string;\n  account: AccountInfo<T>;\n}\n\nexport const WRAPPED_SOL_MINT = new PublicKey('So11111111111111111111111111111111111111112');\n\nexport const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n\nexport const BPF_UPGRADE_LOADER_ID = new PublicKey('BPFLoaderUpgradeab1e11111111111111111111111');\n\nexport const MEMO_ID = new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');\n\nexport const SYSTEM = new PublicKey('11111111111111111111111111111111');\n\nexport const TOKEN_METADATA_PROGRAM_ID = new PublicKey(\"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\");\n\nexport const CANDY_MACHINE_ID = new PublicKey('cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ');\n\nexport const GUMDROP_DISTRIBUTOR_ID = new PublicKey(\"561gX85SDR4hYF2L7P4LcvdXsWSxWuY7Z1yGgznPwSXG\");\n\nexport const GUMDROP_TEMPORAL_SIGNER = new PublicKey(\"MSv9H2sMceAzccBganUXwGq3GXgqYAstmZAbFDZYbAV\");\n\n","import React from \"react\";\nimport { RouteComponentProps, } from \"react-router-dom\";\nimport queryString from 'query-string';\n\nimport {\n  Box,\n  Button,\n  CircularProgress,\n  FormControl,\n  Link as HyperLink,\n  InputLabel,\n  MenuItem,\n  Select,\n  Stack,\n  Step,\n  StepLabel,\n  Stepper,\n  TextField,\n} from \"@mui/material\";\n\nimport {\n  useWallet,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  Connection as RPCConnection,\n  Keypair,\n  PublicKey,\n  SystemProgram,\n  SYSVAR_RENT_PUBKEY,\n  SYSVAR_CLOCK_PUBKEY,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport {\n  AccountLayout,\n  MintLayout,\n  Token,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport { sha256 } from \"js-sha256\";\nimport BN from 'bn.js';\nimport * as bs58 from \"bs58\";\n\nimport {\n  useConnection,\n} from \"../contexts\";\nimport {\n  CANDY_MACHINE_ID,\n  GUMDROP_DISTRIBUTOR_ID,\n  GUMDROP_TEMPORAL_SIGNER,\n  TOKEN_METADATA_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  getCandyMachine,\n  getCandyMachineAddress,\n  getEdition,\n  getEditionMarkerPda,\n  getMetadata,\n  notify,\n} from \"../utils\";\nimport { MerkleTree } from \"../utils/merkleTree\";\nimport {\n  explorerLinkFor,\n  sendSignedTransaction,\n} from \"../utils/transactions\";\nimport { coder } from \"../utils/merkleDistributor\";\n\nconst walletKeyOrPda = async (\n  walletKey : PublicKey,\n  handle : string,\n  pin : BN | null,\n  seed : PublicKey,\n) : Promise<[PublicKey, Array<Buffer>]> => {\n  if (pin === null) {\n    try {\n      const key = new PublicKey(handle);\n      if (!key.equals(walletKey)) {\n        throw new Error(\"Claimant wallet handle does not match connected wallet\");\n      }\n      return [key, []];\n    } catch (err) {\n      throw new Error(`Invalid claimant wallet handle ${err}`);\n    }\n  } else {\n    const pdaSeeds = [\n      seed.toBuffer(),\n      Buffer.from(handle),\n      Buffer.from(pin.toArray(\"le\", 4)),\n    ];\n\n    const [claimantPda, ] = await PublicKey.findProgramAddress(\n      pdaSeeds,\n      GUMDROP_DISTRIBUTOR_ID\n    );\n    return [claimantPda, pdaSeeds];\n  }\n}\n\n\nconst buildMintClaim = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  distributorKey : PublicKey,\n  distributorInfo : any,\n  tokenAcc : string,\n  proof : Array<Buffer>,\n  handle : string,\n  amount : number,\n  index : number,\n  pin : BN | null,\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\n  let tokenAccKey: PublicKey;\n  try {\n    tokenAccKey = new PublicKey(tokenAcc);\n  } catch (err) {\n    throw new Error(`Invalid tokenAcc key ${err}`);\n  }\n  const distTokenAccount = await connection.getAccountInfo(tokenAccKey);\n  if (distTokenAccount === null) {\n    throw new Error(`Could not fetch distributor token account`);\n  }\n\n  const tokenAccountInfo = AccountLayout.decode(distTokenAccount.data);\n  const mint = new PublicKey(tokenAccountInfo.mint);\n\n  console.log(mint.toBase58());\n\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, mint);\n\n  // TODO: since it's in the PDA do we need it to be in the leaf?\n  const leaf = Buffer.from(\n    [...new BN(index).toArray(\"le\", 8),\n     ...secret.toBuffer(),\n     ...mint.toBuffer(),\n     ...new BN(amount).toArray(\"le\", 8),\n    ]\n  );\n\n  const matches = MerkleTree.verifyClaim(\n    leaf, proof, Buffer.from(distributorInfo.root)\n  );\n\n  if (!matches) {\n    throw new Error(\"Gumdrop merkle proof does not match\");\n  }\n\n  const [claimStatus, cbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"ClaimStatus\"),\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  const [walletTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      walletKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      mint.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n\n  const setup : Array<TransactionInstruction> = [];\n\n  if (await connection.getAccountInfo(walletTokenKey) === null) {\n    setup.push(Token.createAssociatedTokenAccountInstruction(\n        SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n        TOKEN_PROGRAM_ID,\n        mint,\n        walletTokenKey,\n        walletKey,\n        walletKey\n      ));\n  }\n\n  const temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\n      ? walletKey : distributorInfo.temporal;\n\n  const claimAirdrop = new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: distributorKey          , isSigner: false , isWritable: true  } ,\n          { pubkey: claimStatus             , isSigner: false , isWritable: true  } ,\n          { pubkey: tokenAccKey             , isSigner: false , isWritable: true  } ,\n          { pubkey: walletTokenKey          , isSigner: false , isWritable: true  } ,\n          { pubkey: temporalSigner          , isSigner: true  , isWritable: false } ,\n          { pubkey: walletKey               , isSigner: true  , isWritable: false } ,  // payer\n          { pubkey: SystemProgram.programId , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_PROGRAM_ID        , isSigner: false , isWritable: false } ,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:claim\")).slice(0, 8),\n        ...new BN(cbump).toArray(\"le\", 1),\n        ...new BN(index).toArray(\"le\", 8),\n        ...new BN(amount).toArray(\"le\", 8),\n        ...secret.toBuffer(),\n        ...new BN(proof.length).toArray(\"le\", 4),\n        ...Buffer.concat(proof),\n      ])\n  })\n\n  return [[...setup, claimAirdrop], pdaSeeds, []];\n}\n\nconst buildCandyClaim = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  distributorKey : PublicKey,\n  distributorInfo : any,\n  candyConfig : string,\n  candyUUID : string,\n  proof : Array<Buffer>,\n  handle : string,\n  amount : number,\n  index : number,\n  pin : BN | null,\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\n\n  let configKey : PublicKey;\n  try {\n    configKey = new PublicKey(candyConfig);\n  } catch (err) {\n    throw new Error(`Invalid candy config key ${err}`);\n  }\n\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, configKey);\n\n  // TODO: since it's in the PDA do we need it to be in the leaf?\n  const leaf = Buffer.from(\n    [...new BN(index).toArray(\"le\", 8),\n     ...secret.toBuffer(),\n     ...configKey.toBuffer(),\n     ...new BN(amount).toArray(\"le\", 8),\n    ]\n  );\n\n  const matches = MerkleTree.verifyClaim(\n    leaf, proof, Buffer.from(distributorInfo.root)\n  );\n\n  if (!matches) {\n    throw new Error(\"Gumdrop merkle proof does not match\");\n  }\n\n  const [claimCount, cbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"ClaimCount\"),\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  const [distributorWalletKey, wbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"Wallet\"),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  // atm the contract has a special case for when the temporal key is defaulted\n  // (aka always passes temporal check)\n  // TODO: more flexible\n  let temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\n      ? walletKey : distributorInfo.temporal;\n\n  const setup : Array<TransactionInstruction> = [];\n\n  const claimCountAccount = await connection.getAccountInfo(claimCount);\n  let nftsAlreadyMinted = 0;\n  if (claimCountAccount === null) {\n  } else {\n    // TODO: subtract already minted?...\n    const claimAccountInfo = coder.accounts.decode(\n      \"ClaimCount\", claimCountAccount.data);\n    nftsAlreadyMinted = claimAccountInfo.count;\n    if (claimAccountInfo.claimant.equals(walletKey)) {\n      // we already proved this claim and verified the OTP once, contract knows\n      // that this wallet is OK\n      temporalSigner = walletKey;\n    } else {\n      // need to claim with the first wallet...\n      const claimantStr = claimAccountInfo.claimant.toBase58();\n      throw new Error(`This wallet does not match existing claimant ${claimantStr}`);\n    }\n  }\n\n  const nftsAvailable = amount;\n  if (nftsAlreadyMinted >= nftsAvailable) {\n    throw new Error(`Cannot mint another NFT. ${nftsAvailable} NFT(s) were originally allocated`\n      + (nftsAlreadyMinted > 0 ? ` and ${nftsAlreadyMinted} NFT(s) were already minted` : \"\"));\n  }\n\n\n  const [candyMachineKey, ] = await getCandyMachineAddress(configKey, candyUUID);\n  const candyMachine = await getCandyMachine(connection, candyMachineKey);\n  console.log(\"Candy Machine\", candyMachine);\n\n  const candyMachineMints : Array<Keypair> = [];\n\n  const [instrs, mint] = await buildSingleCandyMint(\n    connection,\n    walletKey,\n    distributorKey,\n    distributorWalletKey,\n    claimCount,\n    temporalSigner,\n    configKey,\n    candyMachineKey,\n    candyMachine.wallet,\n    Buffer.from([\n      ...new BN(wbump).toArray(\"le\", 1),\n      ...new BN(cbump).toArray(\"le\", 1),\n      ...new BN(index).toArray(\"le\", 8),\n      ...new BN(amount).toArray(\"le\", 8),\n      ...secret.toBuffer(),\n      ...new BN(proof.length).toArray(\"le\", 4),\n      ...Buffer.concat(proof),\n    ]),\n  );\n  candyMachineMints.push(mint);\n  setup.push(...instrs);\n\n  return [setup, pdaSeeds, candyMachineMints];\n}\n\nconst buildSingleCandyMint = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  distributorKey : PublicKey,\n  distributorWalletKey : PublicKey,\n  claimCount : PublicKey,\n  temporalSigner : PublicKey,\n  configKey : PublicKey,\n  candyMachineKey : PublicKey,\n  candyMachineWallet : PublicKey,\n  data : Buffer,\n) : Promise<[Array<TransactionInstruction>, Keypair]> => {\n  const candyMachineMint = Keypair.generate();\n  const candyMachineMetadata = await getMetadata(candyMachineMint.publicKey);\n  const candyMachineMaster = await getEdition(candyMachineMint.publicKey);\n\n  const setup : Array<TransactionInstruction> = [];\n  await createMintAndAccount(connection, walletKey, candyMachineMint.publicKey, setup);\n  setup.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: distributorKey            , isSigner: false , isWritable: true  } ,\n          { pubkey: distributorWalletKey      , isSigner: false , isWritable: true  } ,\n          { pubkey: claimCount                , isSigner: false , isWritable: true  } ,\n          { pubkey: temporalSigner            , isSigner: true  , isWritable: false } ,\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // payer\n\n          { pubkey: configKey                 , isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineKey           , isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineWallet        , isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineMint.publicKey, isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineMetadata      , isSigner: false , isWritable: true  } ,\n          { pubkey: candyMachineMaster        , isSigner: false , isWritable: true  } ,\n\n          { pubkey: SystemProgram.programId   , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_PROGRAM_ID          , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_METADATA_PROGRAM_ID , isSigner: false , isWritable: false } ,\n          { pubkey: CANDY_MACHINE_ID          , isSigner: false , isWritable: false } ,\n          { pubkey: SYSVAR_RENT_PUBKEY        , isSigner: false , isWritable: false } ,\n          { pubkey: SYSVAR_CLOCK_PUBKEY       , isSigner: false , isWritable: false } ,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:claim_candy\")).slice(0, 8),\n        ...data,\n      ])\n  }));\n\n  return [setup, candyMachineMint];\n}\n\nconst createMintAndAccount = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  mint : PublicKey,\n  setup : Array<TransactionInstruction>,\n) => {\n  const [walletTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      walletKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      mint.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n\n  setup.push(SystemProgram.createAccount({\n    fromPubkey: walletKey,\n    newAccountPubkey: mint,\n    space: MintLayout.span,\n    lamports:\n      await connection.getMinimumBalanceForRentExemption(\n        MintLayout.span,\n      ),\n    programId: TOKEN_PROGRAM_ID,\n  }));\n\n  setup.push(Token.createInitMintInstruction(\n    TOKEN_PROGRAM_ID,\n    mint,\n    0,\n    walletKey,\n    walletKey,\n  ));\n\n  setup.push(Token.createAssociatedTokenAccountInstruction(\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    mint,\n    walletTokenKey,\n    walletKey,\n    walletKey\n  ));\n\n  setup.push(Token.createMintToInstruction(\n    TOKEN_PROGRAM_ID,\n    mint,\n    walletTokenKey,\n    walletKey,\n    [],\n    1,\n  ));\n\n}\n\nconst buildEditionClaim = async (\n  connection : RPCConnection,\n  walletKey : PublicKey,\n  distributorKey : PublicKey,\n  distributorInfo : any,\n  masterMint : string,\n  edition : number,\n  proof : Array<Buffer>,\n  handle : string,\n  amount : number,\n  index : number,\n  pin : BN | null,\n) : Promise<[Array<TransactionInstruction>, Array<Buffer>, Array<Keypair>]> => {\n\n  let masterMintKey : PublicKey;\n  try {\n    masterMintKey = new PublicKey(masterMint);\n  } catch (err) {\n    throw new Error(`Invalid master mint key ${err}`);\n  }\n\n  const [secret, pdaSeeds] = await walletKeyOrPda(walletKey, handle, pin, masterMintKey);\n\n  // should we assert that the amount is 1?\n  const leaf = Buffer.from(\n    [...new BN(index).toArray(\"le\", 8),\n     ...secret.toBuffer(),\n     ...masterMintKey.toBuffer(),\n     ...new BN(amount).toArray(\"le\", 8),\n     ...new BN(edition).toArray(\"le\", 8),\n    ]\n  );\n\n  const matches = MerkleTree.verifyClaim(\n    leaf, proof, Buffer.from(distributorInfo.root)\n  );\n\n  if (!matches) {\n    throw new Error(\"Gumdrop merkle proof does not match\");\n  }\n\n  const [claimCount, cbump] = await PublicKey.findProgramAddress(\n    [\n      Buffer.from(\"ClaimCount\"),\n      Buffer.from(new BN(index).toArray(\"le\", 8)),\n      distributorKey.toBuffer(),\n    ],\n    GUMDROP_DISTRIBUTOR_ID\n  );\n\n  // atm the contract has a special case for when the temporal key is defaulted\n  // (aka always passes temporal check)\n  // TODO: more flexible\n  let temporalSigner = distributorInfo.temporal.equals(PublicKey.default) || secret.equals(walletKey)\n      ? walletKey : distributorInfo.temporal;\n\n  const claimCountAccount = await connection.getAccountInfo(claimCount);\n  if (claimCountAccount !== null) {\n    throw new Error(`This edition was already claimed`);\n  }\n\n  const setup : Array<TransactionInstruction> = [];\n\n  const newMint = Keypair.generate();\n  const newMetadataKey = await getMetadata(newMint.publicKey);\n  const masterMetadataKey = await getMetadata(masterMintKey);\n  const newEdition = await getEdition(newMint.publicKey);\n  const masterEdition = await getEdition(masterMintKey);\n\n  await createMintAndAccount(connection, walletKey, newMint.publicKey, setup);\n\n  const [distributorTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      distributorKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      masterMintKey.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n\n  const editionMarkKey = await getEditionMarkerPda(masterMintKey, new BN(edition));\n\n  setup.push(new TransactionInstruction({\n      programId: GUMDROP_DISTRIBUTOR_ID,\n      keys: [\n          { pubkey: distributorKey            , isSigner: false , isWritable: true  } ,\n          { pubkey: claimCount                , isSigner: false , isWritable: true  } ,\n          { pubkey: temporalSigner            , isSigner: true  , isWritable: false } ,\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // payer\n\n          { pubkey: newMetadataKey            , isSigner: false , isWritable: true  } ,\n          { pubkey: newEdition                , isSigner: false , isWritable: true  } ,\n          { pubkey: masterEdition             , isSigner: false , isWritable: true  } ,\n          { pubkey: newMint.publicKey         , isSigner: false , isWritable: true  } ,\n          { pubkey: editionMarkKey            , isSigner: false , isWritable: true  } ,\n          { pubkey: walletKey                 , isSigner: true  , isWritable: false } , // `newMint` auth\n          { pubkey: distributorTokenKey       , isSigner: false , isWritable: false } ,\n          { pubkey: walletKey                 , isSigner: false , isWritable: false } , // new update auth\n          { pubkey: masterMetadataKey         , isSigner: false , isWritable: false } ,\n          { pubkey: masterMintKey             , isSigner: false , isWritable: false } ,\n\n          { pubkey: SystemProgram.programId   , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_PROGRAM_ID          , isSigner: false , isWritable: false } ,\n          { pubkey: TOKEN_METADATA_PROGRAM_ID , isSigner: false , isWritable: false } ,\n          { pubkey: SYSVAR_RENT_PUBKEY        , isSigner: false , isWritable: false } ,\n      ],\n      data: Buffer.from([\n        ...Buffer.from(sha256.digest(\"global:claim_edition\")).slice(0, 8),\n        ...new BN(cbump).toArray(\"le\", 1),\n        ...new BN(index).toArray(\"le\", 8),\n        ...new BN(amount).toArray(\"le\", 8),\n        ...new BN(edition).toArray(\"le\", 8),\n        ...secret.toBuffer(),\n        ...new BN(proof.length).toArray(\"le\", 4),\n        ...Buffer.concat(proof),\n      ])\n  }));\n\n  return [setup, pdaSeeds, [newMint]];\n}\n\nconst fetchDistributor = async (\n  connection : RPCConnection,\n  distributorStr : string,\n) => {\n  let key;\n  try {\n    key = new PublicKey(distributorStr);\n  } catch (err) {\n    throw new Error(`Invalid distributor key ${err}`);\n  }\n  const account = await connection.getAccountInfo(key);\n  if (account === null) {\n    throw new Error(`Could not fetch distributor ${distributorStr}`);\n  }\n  if (!account.owner.equals(GUMDROP_DISTRIBUTOR_ID)) {\n    const ownerStr = account.owner.toBase58();\n    throw new Error(`Invalid distributor owner ${ownerStr}`);\n  }\n  const info = coder.accounts.decode(\"MerkleDistributor\", account.data);\n  return [key, info];\n};\n\nconst fetchNeedsTemporalSigner = async (\n  connection : RPCConnection,\n  distributorStr : string,\n  indexStr : string,\n  claimMethod : string,\n) => {\n  const [key, info] = await fetchDistributor(connection, distributorStr);\n  if (!info.temporal.equals(GUMDROP_TEMPORAL_SIGNER)) {\n    // default pubkey or program itself (distribution through wallets)\n    return false;\n  } else if (claimMethod === \"candy\") {\n    const [claimCount, ] = await PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"ClaimCount\"),\n        Buffer.from(new BN(Number(indexStr)).toArray(\"le\", 8)),\n        key.toBuffer(),\n      ],\n      GUMDROP_DISTRIBUTOR_ID\n    );\n    // if someone (maybe us) has already claimed this, the contract will\n    // not check the existing temporal signer anymore since presumably\n    // they have already verified the OTP. So we need to fetch the temporal\n    // signer if it is null\n    const claimCountAccount = await connection.getAccountInfo(claimCount);\n    return claimCountAccount === null;\n  } else {\n    // default to need one\n    return true;\n  }\n};\n\nexport type ClaimProps = {};\n\nexport const Claim = (\n  props : RouteComponentProps<ClaimProps>,\n) => {\n  const connection = useConnection();\n  const wallet = useWallet();\n\n  let params = queryString.parse(props.location.search);\n  const [distributor, setDistributor] = React.useState(params.distributor as string || \"\");\n  const [claimMethod, setClaimMethod] = React.useState(\n        params.tokenAcc ? \"transfer\"\n      : params.config   ? \"candy\"\n      : params.master   ? \"edition\"\n      :                   \"\");\n  const [tokenAcc, setTokenAcc] = React.useState(params.tokenAcc as string || \"\");\n  const [candyConfig, setCandyConfig] = React.useState(params.config as string || \"\");\n  const [candyUUID, setCandyUUID] = React.useState(params.uuid as string || \"\");\n  const [masterMint, setMasterMint] = React.useState(params.master as string || \"\");\n  const [editionStr, setEditionStr] = React.useState(params.edition as string || \"\");\n  const [handle, setHandle] = React.useState(params.handle as string || \"\");\n  const [amountStr, setAmount] = React.useState(params.amount as string || \"\");\n  const [indexStr, setIndex] = React.useState(params.index as string || \"\");\n  const [pinStr, setPin] = React.useState(params.pin as string || \"\");\n  const [proofStr, setProof] = React.useState(params.proof as string || \"\");\n\n  const allFieldsPopulated =\n    distributor.length > 0\n    && ( claimMethod === \"transfer\" ? tokenAcc.length > 0\n       : claimMethod === \"candy\"    ? candyConfig.length > 0 && candyUUID.length > 0\n       : claimMethod === \"edition\"  ? masterMint.length > 0 && editionStr.length > 0\n       :                              false\n       )\n    && handle.length > 0\n    && amountStr.length > 0\n    && indexStr.length > 0;\n    // NB: pin can be empty if handle is a public-key and we are claiming through wallets\n    // NB: proof can be empty!\n\n  const [editable, setEditable] = React.useState(!allFieldsPopulated);\n\n  // temporal verification\n  const [transaction, setTransaction] = React.useState<Transaction | null>(null);\n  const [OTPStr, setOTPStr] = React.useState(\"\");\n\n  // async computed\n  const [asyncNeedsTemporalSigner, setNeedsTemporalSigner] = React.useState<boolean>(true);\n\n  React.useEffect(() => {\n    const wrap = async () => {\n      try {\n        setNeedsTemporalSigner(await fetchNeedsTemporalSigner(\n          connection, distributor, indexStr, claimMethod));\n      } catch {\n        // TODO: log?\n      }\n    };\n    wrap();\n  }, [connection, distributor, indexStr, claimMethod]);\n\n  const lambdaAPIEndpoint = \"https://n82bm4ts81.execute-api.us-east-2.amazonaws.com/send-OTP\";\n\n  const skipAWSWorkflow = false;\n\n  const sendOTP = async (e : React.SyntheticEvent) => {\n    e.preventDefault();\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const index = Number(indexStr);\n    const amount = Number(amountStr);\n    let pin : BN | null = null;\n\n    if (isNaN(amount)) {\n      throw new Error(`Could not parse amount ${amountStr}`);\n    }\n    if (isNaN(index)) {\n      throw new Error(`Could not parse index ${indexStr}`);\n    }\n    if (pinStr.length > 0) {\n      try {\n        pin = new BN(pinStr);\n      } catch (err) {\n        throw new Error(`Could not parse pin ${pinStr}: ${err}`);\n      }\n    }\n\n    // TODO: use cached?\n    const [distributorKey, distributorInfo] =\n        await fetchDistributor(connection, distributor);\n\n    console.log(\"Distributor\", distributorInfo);\n\n    const proof = proofStr === \"\" ? [] : proofStr.split(\",\").map(b => {\n      const ret = Buffer.from(bs58.decode(b))\n      if (ret.length !== 32)\n        throw new Error(`Invalid proof hash length`);\n      return ret;\n    });\n\n    let instructions, pdaSeeds, extraSigners;\n    if (claimMethod === \"candy\") {\n      console.log(\"Building candy claim\");\n      [instructions, pdaSeeds, extraSigners] = await buildCandyClaim(\n        connection, wallet.publicKey, distributorKey, distributorInfo,\n        candyConfig, candyUUID,\n        proof, handle, amount, index, pin\n      );\n    } else if (claimMethod === \"transfer\") {\n      [instructions, pdaSeeds, extraSigners] = await buildMintClaim(\n        connection, wallet.publicKey, distributorKey, distributorInfo,\n        tokenAcc,\n        proof, handle, amount, index, pin\n      );\n    } else if (claimMethod === \"edition\") {\n      const edition = Number(editionStr);\n      if (isNaN(edition)) {\n        throw new Error(`Could not parse edition ${editionStr}`);\n      }\n      [instructions, pdaSeeds, extraSigners] = await buildEditionClaim(\n        connection, wallet.publicKey, distributorKey, distributorInfo,\n        masterMint, edition,\n        proof, handle, amount, index, pin\n      );\n    } else {\n      throw new Error(`Unknown claim method ${claimMethod}`);\n    }\n\n    // NB: if we're claiming through wallets then pdaSeeds should be empty\n    // since the secret is the wallet key (which is also a signer)\n    if (pin === null && pdaSeeds.length > 0) {\n      throw new Error(`Internal error: PDA generated when distributing to wallet directly`);\n    }\n\n    let transaction = new Transaction({\n      feePayer: wallet.publicKey,\n      recentBlockhash: (await connection.getRecentBlockhash(\"singleGossip\")).blockhash,\n    });\n\n    const signers = new Set<PublicKey>();\n    for (const instr of instructions) {\n      transaction.add(instr);\n      for (const key of instr.keys)\n        if (key.isSigner)\n          signers.add(key.pubkey);\n    }\n    console.log(`Expecting the following signers: ${[...signers].map(s => s.toBase58())}`);\n    transaction.setSigners(...signers);\n\n    if (extraSigners.length > 0) {\n      transaction.partialSign(...extraSigners);\n    }\n\n    const txnNeedsTemporalSigner =\n        transaction.signatures.some(s => s.publicKey.equals(GUMDROP_TEMPORAL_SIGNER));\n    if (txnNeedsTemporalSigner && !skipAWSWorkflow) {\n      const params = {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          method: \"send\",\n          transaction: bs58.encode(transaction.serializeMessage()),\n          seeds: pdaSeeds,\n        }),\n      };\n\n      const response = await fetch(lambdaAPIEndpoint, params);\n      console.log(response);\n\n      if (response.status !== 200) {\n        throw new Error(`Failed to send AWS OTP`);\n      }\n\n      let data;\n      try {\n        data = await response.json();\n      } catch {\n        throw new Error(`Could not parse AWS OTP response`);\n      }\n\n      console.log(\"AWS OTP response data:\", data);\n\n      if (!data.MessageId) {\n        throw new Error(`Failed to send AWS OTP`);\n      }\n\n      notify({\n        message: \"OTP sent\",\n        description: `Please check ${handle} for a OTP`,\n      });\n    }\n\n    return transaction;\n  };\n\n  const verifyOTP = async (\n    e : React.SyntheticEvent,\n    transaction : Transaction | null,\n  ) => {\n    e.preventDefault();\n\n    if (!transaction) {\n      throw new Error(`Transaction not available for OTP verification`);\n    }\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const txnNeedsTemporalSigner =\n        transaction.signatures.some(s => s.publicKey.equals(GUMDROP_TEMPORAL_SIGNER));\n    if (txnNeedsTemporalSigner && !skipAWSWorkflow) {\n      // TODO: distinguish between OTP failure and transaction-error. We can try\n      // again on the former but not the latter\n      const OTP = Number(OTPStr);\n      if (isNaN(OTP) || OTPStr.length === 0) {\n        throw new Error(`Could not parse OTP ${OTPStr}`);\n      }\n\n      const params = {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        FunctionName: \"send-OTP\",\n        body: JSON.stringify({\n          method: \"verify\",\n          otp: OTP,\n          handle: handle,  // TODO?\n        }),\n      };\n\n      const response = await fetch(lambdaAPIEndpoint, params);\n      console.log(response);\n\n      if (response.status !== 200) {\n        const blob = JSON.stringify(response);\n        throw new Error(`Failed to verify AWS OTP. ${blob}`);\n      }\n\n      let data;\n      try {\n        data = await response.json();\n      } catch {\n        throw new Error(`Could not parse AWS OTP verification response`);\n      }\n\n      console.log(\"AWS verify response data:\", data);\n\n      let sig;\n      try {\n        sig = bs58.decode(data);\n      } catch {\n        throw new Error(`Could not decode transaction signature ${data.body}`);\n      }\n\n      transaction.addSignature(GUMDROP_TEMPORAL_SIGNER, sig);\n    }\n\n    let fullySigned;\n    try {\n      fullySigned = await wallet.signTransaction(transaction);\n    } catch {\n      throw new Error(\"Failed to sign transaction\");\n    }\n\n    const claimResult = await sendSignedTransaction({\n      connection,\n      signedTransaction: fullySigned,\n    });\n\n    console.log(claimResult);\n    notify({\n      message: \"Claim succeeded\",\n      description: (\n        <HyperLink href={explorerLinkFor(claimResult.txid, connection)}>\n          View transaction on explorer\n        </HyperLink>\n      ),\n    });\n    setTransaction(null);\n    try {\n      setNeedsTemporalSigner(await fetchNeedsTemporalSigner(\n        connection, distributor, indexStr, claimMethod));\n    } catch {\n      // TODO: log?\n    }\n  };\n\n  const [loading, setLoading] = React.useState(false);\n  const loadingProgress = () => (\n    <CircularProgress\n      size={24}\n      sx={{\n        position: 'absolute',\n        top: '50%',\n        left: '50%',\n        marginTop: '-12px',\n        marginLeft: '-12px',\n      }}\n    />\n  );\n\n  const verifyOTPC = (onClick) => (\n    <React.Fragment>\n      <TextField\n        style={{width: \"60ch\"}}\n        id=\"otp-text-field\"\n        label=\"OTP\"\n        value={OTPStr}\n        onChange={(e) => setOTPStr(e.target.value)}\n      />\n      <Box />\n\n      <Box sx={{ position: \"relative\" }}>\n      <Button\n        disabled={!wallet.connected || !OTPStr || loading}\n        variant=\"contained\"\n        color=\"success\"\n        style={{ width: \"100%\" }}\n        onClick={(e) => {\n          setLoading(true);\n          const wrap = async () => {\n            try {\n              await verifyOTP(e, transaction);\n              setLoading(false);\n              onClick();\n            } catch (err) {\n              notify({\n                message: \"Claim failed\",\n                description: `${err}`,\n              });\n              setLoading(false);\n            }\n          };\n          wrap();\n        }}\n      >\n        Claim Gumdrop\n      </Button>\n      {loading && loadingProgress()}\n      </Box>\n    </React.Fragment>\n  );\n\n  const claimData = (claimMethod) => {\n    if (claimMethod === \"candy\") {\n      return (\n        <React.Fragment>\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"config-text-field\"\n            label=\"Candy Config\"\n            value={candyConfig}\n            onChange={e => setCandyConfig(e.target.value)}\n            disabled={!editable}\n          />\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"config-uuid-text-field\"\n            label=\"Candy UUID\"\n            value={candyUUID}\n            onChange={e => setCandyUUID(e.target.value)}\n            disabled={!editable}\n          />\n        </React.Fragment>\n      );\n    } else if (claimMethod === \"transfer\") {\n      return (\n        <React.Fragment>\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"token-acc-text-field\"\n            label=\"Source Token Account\"\n            value={tokenAcc}\n            onChange={(e) => setTokenAcc(e.target.value)}\n            disabled={!editable}\n          />\n        </React.Fragment>\n      );\n    } else if (claimMethod === \"edition\") {\n      return (\n        <React.Fragment>\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"master-mint-text-field\"\n            label=\"Master Mint\"\n            value={masterMint}\n            onChange={(e) => setMasterMint(e.target.value)}\n            disabled={!editable}\n          />\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"edition-text-field\"\n            label=\"Edition\"\n            value={editionStr}\n            onChange={(e) => setEditionStr(e.target.value)}\n            disabled={!editable}\n          />\n        </React.Fragment>\n      );\n    }\n  };\n\n  const populateClaimC = (onClick) => (\n    <React.Fragment>\n      <TextField\n        style={{width: \"60ch\"}}\n        id=\"distributor-text-field\"\n        label=\"Distributor\"\n        value={distributor}\n        onChange={(e) => setDistributor(e.target.value)}\n        disabled={!editable}\n      />\n      <FormControl fullWidth>\n        <InputLabel id=\"claim-method-label\">Claim Method</InputLabel>\n        <Select\n          labelId=\"claim-method-label\"\n          id=\"claim-method-select\"\n          value={claimMethod}\n          label=\"Claim Method\"\n          onChange={(e) => { setClaimMethod(e.target.value); }}\n          style={{textAlign: \"left\"}}\n          disabled={!editable}\n        >\n          <MenuItem value={\"transfer\"}>Token Transfer</MenuItem>\n          <MenuItem value={\"candy\"}>Candy Machine</MenuItem>\n          <MenuItem value={\"edition\"}>Limited Edition</MenuItem>\n        </Select>\n      </FormControl>\n      {claimMethod !== \"\" && claimData(claimMethod)}\n      {claimMethod !== \"edition\" && <TextField\n        style={{width: \"60ch\"}}\n        id=\"amount-text-field\"\n        label=\"Amount\"\n        value={amountStr}\n        onChange={(e) => setAmount(e.target.value)}\n        disabled={!editable}\n      />}\n      <TextField\n        style={{width: \"60ch\"}}\n        id=\"handle-text-field\"\n        label=\"Handle\"\n        value={handle}\n        onChange={(e) => setHandle(e.target.value)}\n        disabled={!editable}\n      />\n      <TextField\n        style={{width: \"60ch\"}}\n        id=\"index-text-field\"\n        label=\"Index\"\n        value={indexStr}\n        onChange={(e) => setIndex(e.target.value)}\n        disabled={!editable}\n      />\n      <TextField\n        style={{width: \"60ch\"}}\n        id=\"pin-text-field\"\n        label=\"Pin\"\n        value={pinStr}\n        onChange={(e) => setPin(e.target.value)}\n        disabled={!editable}\n      />\n      <TextField\n        style={{width: \"60ch\"}}\n        id=\"proof-text-field\"\n        label=\"Proof\"\n        multiline\n        value={proofStr}\n        onChange={(e) => setProof(e.target.value)}\n        disabled={!editable}\n      />\n      <Button\n        color=\"info\"\n        onClick={(e) => setEditable(!editable)}\n      >\n        {!editable ? \"Edit Claim\" : \"Stop Editing\"}\n      </Button>\n      <Box />\n\n      <Box sx={{ position: \"relative\" }}>\n      <Button\n        disabled={!wallet.connected || !allFieldsPopulated || loading}\n        variant=\"contained\"\n        style={{ width: \"100%\" }}\n        color={asyncNeedsTemporalSigner ? \"primary\" : \"success\"}\n        onClick={(e) => {\n          setLoading(true);\n          const wrap = async () => {\n            try {\n              const needsTemporalSigner = await fetchNeedsTemporalSigner(\n                  connection, distributor, indexStr, claimMethod);\n              const transaction = await sendOTP(e);\n              if (!needsTemporalSigner) {\n                await verifyOTP(e, transaction);\n              } else {\n                setTransaction(transaction);\n              }\n              setLoading(false);\n              onClick();\n            } catch (err) {\n              notify({\n                message: \"Claim failed\",\n                description: `${err}`,\n              });\n              setLoading(false);\n            }\n          };\n          wrap();\n        }}\n      >\n        {asyncNeedsTemporalSigner ? \"Next\" : \"Claim Gumdrop\"}\n      </Button>\n      {loading && loadingProgress()}\n      </Box>\n    </React.Fragment>\n  );\n\n  const steps = [\n    { name: \"Populate Claim\", inner: populateClaimC },\n  ];\n  if (asyncNeedsTemporalSigner) {\n    steps.push(\n    { name: \"Verify OTP\"    , inner: verifyOTPC     }\n    );\n  }\n\n  // TODO: better interaction between setting `asyncNeedsTemporalSigner` and\n  // the stepper... this is pretty jank\n  const [activeStep, setActiveStep] = React.useState(0);\n  const stepToUse = Math.min(activeStep, steps.length - 1);\n\n  const handleNext = () => {\n    // return to start if going past the end (claim succeeded)\n    setActiveStep(prev => {\n      if (prev === steps.length - 1) {\n        return 0;\n      } else {\n        return prev + 1;\n      }\n    });\n  };\n  const handleBack = () => {\n    setActiveStep(prev => prev - 1);\n  };\n\n  const stepper = (\n    <React.Fragment>\n      <Stepper activeStep={stepToUse}>\n        {steps.map((s, index) => {\n          return (\n            <Step key={s.name}>\n              <StepLabel>{s.name}</StepLabel>\n            </Step>\n          );\n        })}\n      </Stepper>\n      <Box />\n    </React.Fragment>\n  );\n\n  return (\n    <Stack spacing={2}>\n      {asyncNeedsTemporalSigner && stepper}\n      {steps[stepToUse].inner(handleNext)}\n      {stepToUse > 0 && (\n        <Button\n          color=\"info\"\n          onClick={handleBack}\n        >\n          Back\n        </Button>\n      )}\n    </Stack>\n  );\n};\n\n","import { WalletAdapter, WalletError } from \"@solana/wallet-adapter-base\";\nimport {\n  useWallet,\n  WalletProvider as BaseWalletProvider,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  getLedgerWallet,\n  getMathWallet,\n  getPhantomWallet,\n  getSolflareWallet,\n  getSolletWallet,\n  getSolongWallet,\n  getTorusWallet,\n} from \"@solana/wallet-adapter-wallets\";\nimport { Button } from \"antd\";\nimport React, {\n  createContext,\n  FC,\n  ReactNode,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\nimport { notify } from \"../../utils\";\nimport { DefaultModal } from \"../../components\";\n\nimport \"./wallet.less\";\n\nexport interface WalletModalContextState {\n  visible: boolean;\n  setVisible: (open: boolean) => void;\n}\n\nexport const WalletModalContext = createContext<WalletModalContextState>(\n  {} as WalletModalContextState\n);\n\nexport function useWalletModal(): WalletModalContextState {\n  return useContext(WalletModalContext);\n}\n\nexport const WalletModal: FC = () => {\n  const { wallets, wallet: selected, select } = useWallet();\n  const { visible, setVisible } = useWalletModal();\n  const [ , setShowWallets] = useState(false);\n  const close = useCallback(() => {\n    setVisible(false);\n    setShowWallets(false);\n  }, [setVisible, setShowWallets]);\n\n  return (\n    <DefaultModal visible={visible} onCancel={close}>\n      <div\n        style={{\n          background:\n            \"linear-gradient(180deg, #D329FC 0%, #8F6DDE 49.48%, #19E6AD 100%)\",\n          borderRadius: 36,\n          width: 50,\n          height: 50,\n          textAlign: \"center\",\n          verticalAlign: \"middle\",\n          fontWeight: 700,\n          fontSize: \"1.3rem\",\n          lineHeight: 2.4,\n          marginBottom: 10,\n        }}\n      ></div>\n      <h2\n        style={{\n          color: \"white\",\n          fontWeight: \"bold\",\n          fontSize: 20,\n        }}\n      >\n        {selected ? \"Change provider\" : \"\"}\n      </h2>\n      <p style={{ color: \"white\", fontSize: 14 }}>\n        {selected\n          ? \"Choose from the following options:\"\n          : \"Please sign into your wallet\"}\n      </p>\n\n      <br />\n      {wallets.map((wallet) => {\n        return (\n          <Button\n            key={wallet.name}\n            size=\"large\"\n            type={wallet === selected ? \"primary\" : \"ghost\"}\n            onClick={() => {\n              select(wallet.name);\n              close();\n            }}\n            icon={\n              <img\n                alt={`${wallet.name}`}\n                width={20}\n                height={20}\n                src={wallet.icon}\n                style={{ marginRight: 30, float: \"left\" }}\n              />\n            }\n            style={{\n              display: \"block\",\n              width: \"100%\",\n              textAlign: \"left\",\n              marginBottom: 8,\n              color: \"white\",\n            }}\n          >\n            {wallet.name}\n          </Button>\n        );\n      })}\n    </DefaultModal>\n  );\n};\n\nexport const WalletModalProvider: FC<{ children: ReactNode }> = ({\n  children,\n}) => {\n  const { publicKey } = useWallet();\n  const [connected, setConnected] = useState(!!publicKey);\n  const [visible, setVisible] = useState(false);\n\n  useEffect(() => {\n    if (publicKey) {\n      const base58 = publicKey.toBase58();\n      const keyToDisplay =\n        base58.length > 20\n          ? `${base58.substring(0, 7)}.....${base58.substring(\n              base58.length - 7,\n              base58.length\n            )}`\n          : base58;\n\n      notify({\n        message: \"Wallet update\",\n        description: \"Connected to wallet \" + keyToDisplay,\n      });\n    }\n  }, [publicKey]);\n\n  useEffect(() => {\n    if (!publicKey && connected) {\n      notify({\n        message: \"Wallet update\",\n        description: \"Disconnected from wallet\",\n      });\n    }\n    setConnected(!!publicKey);\n  }, [publicKey, connected, setConnected]);\n\n  return (\n    <WalletModalContext.Provider\n      value={{\n        visible,\n        setVisible,\n      }}\n    >\n      {children}\n      <WalletModal />\n    </WalletModalContext.Provider>\n  );\n};\n\nexport const WalletProvider: FC<{ children: ReactNode }> = ({ children }) => {\n  const wallets = useMemo(\n    () => [\n      getPhantomWallet(),\n      getSolflareWallet(),\n      getTorusWallet({\n        options: {\n          // @FIXME: this should be changed for Default, and by each Default storefront\n          clientId:\n            \"BOM5Cl7PXgE9Ylq1Z1tqzhpydY0RVr8k90QQ85N7AKI5QGSrr9iDC-3rvmy0K_hF0JfpLMiXoDhta68JwcxS1LQ\",\n        },\n      }),\n      getLedgerWallet(),\n      getSolongWallet(),\n      getMathWallet(),\n      getSolletWallet(),\n    ],\n    []\n  );\n\n  const onError = useCallback((error: WalletError) => {\n    console.error(error);\n    notify({\n      message: \"Wallet error\",\n      description: error.message,\n    });\n  }, []);\n\n  return (\n    <BaseWalletProvider wallets={wallets} onError={onError} autoConnect>\n      <WalletModalProvider>{children}</WalletModalProvider>\n    </BaseWalletProvider>\n  );\n};\n\nexport type WalletSigner = Pick<\n  WalletAdapter,\n  \"publicKey\" | \"signTransaction\" | \"signAllTransactions\"\n>;\n","export default __webpack_public_path__ + \"static/media/wallet.c746d144.less\";","import React, { useState, useContext, useCallback } from 'react';\n\nimport { WalletModal } from './WalletContext/WalletContext';\n\nexport enum ModalEnum {\n  WALLET = 'wallet',\n}\n\ntype ModalContextProps = {\n  setModal: (modal: ModalEnum | undefined) => void;\n  removeModal: () => void;\n};\n\nexport const ModalContext = React.createContext<ModalContextProps>({\n  setModal: () => null,\n  removeModal: () => null,\n});\n\nexport const ModalProvider: React.FC = ({ children }) => {\n  const [modal, setModal] = useState<ModalEnum | undefined>(undefined);\n\n  const removeModal = useCallback(() => {\n    setModal(undefined);\n  }, [setModal]);\n\n  return (\n    <ModalContext.Provider\n      value={{\n        setModal,\n        removeModal,\n      }}\n    >\n      {children}\n      {modal === ModalEnum.WALLET && <WalletModal />}\n    </ModalContext.Provider>\n  );\n};\n\nexport const useModal = (): ModalContextProps => {\n  const context = useContext(ModalContext);\n  if (context === undefined) {\n    throw new Error('useModal must be used within a ModalProvider');\n  }\n  return context;\n};\n","import * as anchor from '@project-serum/anchor';\nimport { Connection, PublicKey } from '@solana/web3.js';\nimport {\n  AccountLayout,\n  MintInfo,\n  MintLayout,\n} from \"@solana/spl-token\";\nimport BN from 'bn.js';\n\nimport {\n  CANDY_MACHINE_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  TOKEN_METADATA_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n} from \"./ids\";\n\nexport const getMintInfo = async (\n  connection : Connection,\n  mint : string\n) : Promise<{ key: PublicKey, info: MintInfo }> => {\n  let mintKey : PublicKey;\n  try {\n    mintKey = new PublicKey(mint);\n  } catch (err) {\n    throw new Error(`Invalid mint key ${err}`);\n  }\n  const mintAccount = await connection.getAccountInfo(mintKey);\n  if (mintAccount === null) {\n    throw new Error(`Could not fetch mint`);\n  }\n  if (!mintAccount.owner.equals(TOKEN_PROGRAM_ID)) {\n    const mintOwner = mintAccount.owner.toBase58();\n    throw new Error(`Invalid mint owner ${mintOwner}`);\n  }\n  if (mintAccount.data.length !== MintLayout.span) {\n    throw new Error(`Invalid mint size ${mintAccount.data.length}`);\n  }\n  const mintInfo = MintLayout.decode(Buffer.from(mintAccount.data));\n  return {\n    key: mintKey,\n    info: mintInfo,\n  };\n};\n\nexport const getCreatorTokenAccount = async (\n  walletKey : PublicKey,\n  connection : Connection,\n  mintKey : PublicKey,\n  totalClaim : number,\n) => {\n  const [creatorTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      walletKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      mintKey.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n  const creatorTokenAccount = await connection.getAccountInfo(creatorTokenKey);\n  if (creatorTokenAccount === null) {\n    throw new Error(`Could not fetch creator token account`);\n  }\n  if (creatorTokenAccount.data.length !== AccountLayout.span) {\n    throw new Error(`Invalid token account size ${creatorTokenAccount.data.length}`);\n  }\n  const creatorTokenInfo = AccountLayout.decode(Buffer.from(creatorTokenAccount.data));\n  if (new BN(creatorTokenInfo.amount, 8, \"le\").toNumber() < totalClaim) {\n    throw new Error(`Creator token account does not have enough tokens`);\n  }\n  return creatorTokenKey;\n};\n\nexport const fetchCoder = async (\n  address : anchor.Address,\n  connection : Connection,\n) : Promise<anchor.Coder | null> => {\n  return new anchor.Coder(await anchor.Program.fetchIdl(\n      address, { connection: connection } as anchor.Provider));\n}\n\nexport const getCandyConfig = async (\n  connection : Connection,\n  config : string\n) : Promise<PublicKey> => {\n  let configKey : PublicKey;\n  try {\n    configKey = new PublicKey(config);\n  } catch (err) {\n    throw new Error(`Invalid config key ${err}`);\n  }\n  const configAccount = await connection.getAccountInfo(configKey);\n  if (configAccount === null) {\n    throw new Error(`Could not fetch config`);\n  }\n  if (!configAccount.owner.equals(CANDY_MACHINE_ID)) {\n    throw new Error(`Invalid config owner ${configAccount.owner.toBase58()}`);\n  }\n  return configKey;\n};\n\nexport const getCandyMachineAddress = async (\n  config: PublicKey,\n  uuid: string,\n) => {\n  return await PublicKey.findProgramAddress(\n    [Buffer.from(\"candy_machine\"), config.toBuffer(), Buffer.from(uuid)],\n    CANDY_MACHINE_ID,\n  );\n};\n\nexport const getCandyMachine = async (\n  connection : Connection,\n  candyMachineKey : PublicKey,\n) => {\n  const candyMachineCoder = await fetchCoder(CANDY_MACHINE_ID, connection);\n  if (candyMachineCoder === null) {\n    throw new Error(`Could not fetch candy machine IDL`);\n  }\n  const candyMachineAccount = await connection.getAccountInfo(candyMachineKey);\n  if (candyMachineAccount === null) {\n    throw new Error(`Could not fetch candy machine`);\n  }\n  return candyMachineCoder.accounts.decode(\n      \"CandyMachine\", candyMachineAccount.data);\n}\n\nexport const getMetadata = async (\n  mint: PublicKey,\n): Promise<PublicKey> => {\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const getEdition = async (\n  mint: PublicKey,\n): Promise<PublicKey> => {\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('edition'),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const getEditionMarkerPda = async (\n  mint: PublicKey,\n  edition: BN,\n) : Promise<PublicKey> => {\n  // editions are divided into pages of 31-bytes (248-bits) for more efficient\n  // packing to check if an edition is occupied. The offset is determined from\n  // the edition passed in through data\n  const editionPageNumber = edition.div(new BN(248)).toNumber();\n\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('edition'),\n        Buffer.from(String(editionPageNumber)),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n}\n","import React from \"react\";\n\nexport type CenteredProps = {\n  children : React.ReactNode,\n  height : string,\n  width : string,\n}\n\nexport const Centered = (\n  props : CenteredProps\n) => {\n  return (\n    <div\n      style={{\n        display: \"table\",\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        height: \"100%\",\n        width: \"100%\",\n      }}\n    >\n      <div\n        style={{\n          display: \"table-cell\",\n          verticalAlign: \"middle\",\n        }}\n      >\n        <div\n          style={{\n            marginLeft: \"auto\",\n            marginRight: \"auto\",\n            height: props.height,\n            width: props.width,\n          }}\n        >\n          {props.children}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Centered;\n","import { ButtonGroup, ButtonGroupProps } from \"@mui/material\";\nimport { Settings } from \"./Settings\";\n\nexport type ConnectButtonProps = ButtonGroupProps & {\n  isConnected: boolean;\n  onClickConnect: () => void;\n  onClickChange: () => void;\n};\n\nexport const ConnectButton: React.FC<ConnectButtonProps> = ({\n  isConnected,\n  onClickConnect,\n  onClickChange,\n  ...restProps\n}) => {\n  return (\n    <ButtonGroup   {...restProps}>\n      <Settings/>\n    </ButtonGroup>\n  );\n};\n\nexport default ConnectButton;\n","import React, { useCallback } from \"react\";\nimport {\n  Box,\n  Button,\n  Link,\n  Stack,\n} from \"@mui/material\";\nimport HomeIcon from '@mui/icons-material/Home';\n\nimport ConnectButton from \"../ConnectButton\";\nimport { ModalEnum, useModal, useWalletModal } from \"../../contexts\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { AppBar } from \"@mui/material\";\n\nexport const Header: React.FC = () => {\n  const { setModal } = useModal();\n  const { setVisible } = useWalletModal();\n  const wallet = useWallet();\n  const connected = wallet.connected;\n\n  const handleChange = useCallback(() => setVisible(true), [setVisible]);\n\n  const handleConnect = useCallback(() => {\n    setModal(ModalEnum.WALLET);\n    setVisible(true);\n  }, [setModal, setVisible]);\n  return (\n    <AppBar color=\"default\">\n    <Box\n      sx={{\n        display: \"flex\",\n        bgcolor: \"action.disabledBackground\",\n      }}\n      minWidth=\"100%\"\n    >\n      <Stack\n        direction=\"row\"\n        spacing={2}\n        sx={{\n          display: \"flex\",\n          height: \"62px\",\n          justifyContent: \"flex-start\",\n          alignItems: \"center\",\n          marginLeft: \"36px\",\n        }}\n      >\n        <Link href=\"#/\" underline=\"none\">\n          <Button variant=\"outlined\">\n            <HomeIcon />\n          </Button>\n        </Link>\n        <Link href=\"#/create\" underline=\"none\">\n          <Button variant=\"outlined\">\n            Create\n          </Button>\n        </Link>\n        <Link href=\"#/claim\" underline=\"none\">\n          <Button variant=\"outlined\">\n            Claim\n          </Button>\n        </Link>\n        <Link href=\"#/close\" underline=\"none\">\n          <Button variant=\"outlined\">\n            Close\n          </Button>\n        </Link>\n      </Stack>\n      <Box sx={{flexGrow: 1}}></Box>\n      <Box\n        sx={{\n          display: \"flex\",\n          height: \"62px\",\n          justifyContent: \"flex-end\",\n          alignItems: \"center\",\n        }}\n      >\n        <ConnectButton\n          isConnected={connected}\n          sx={{ marginRight: \"36px\" }}\n          onClickConnect={handleConnect}\n          onClickChange={handleChange}\n        />\n      </Box>\n    </Box>\n</AppBar>\n  );\n};\n\nexport default Header;\n","import React from \"react\";\n\nimport {\n  Button,\n  FormControl,\n  InputLabel,\n  Link as HyperLink,\n  MenuItem,\n  Stack,\n  Select,\n  TextField,\n} from \"@mui/material\";\n\nimport {\n  useWallet,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  Keypair,\n} from \"@solana/web3.js\";\n\nimport {\n  useConnection,\n  Connection,\n} from \"../contexts\";\nimport {\n  notify,\n} from \"../utils\";\nimport {\n  closeGumdrop,\n} from \"../utils/claimant\";\nimport {\n  explorerLinkFor,\n} from \"../utils/transactions\";\n\nexport const Close = () => {\n  const connection = useConnection();\n  const wallet = useWallet();\n\n  const [baseKey, setBaseKey] = React.useState(\"\");\n  const [claimMethod, setClaimMethod] = React.useState(localStorage.getItem(\"claimMethod\") || \"transfer\");\n  const [candyConfig, setCandyConfig] = React.useState(localStorage.getItem(\"candyConfig\") || \"\");\n  const [candyUUID, setCandyUUID] = React.useState(localStorage.getItem(\"candyUUID\") || \"\");\n  const [masterMint, setMasterMint] = React.useState(localStorage.getItem(\"masterMint\") || \"\");\n\n  const submit = async (e : React.SyntheticEvent) => {\n    e.preventDefault();\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const base = Keypair.fromSecretKey(\n      new Uint8Array(JSON.parse(baseKey)));\n\n    const instructions = await closeGumdrop(\n      connection,\n      wallet.publicKey,\n      base,\n      claimMethod,\n      candyConfig,\n      candyUUID,\n      masterMint,\n    );\n\n    const closeResult = await Connection.sendTransactionWithRetry(\n      connection,\n      wallet,\n      instructions,\n      [base]\n    );\n\n    console.log(closeResult);\n    if (typeof closeResult === \"string\") {\n      notify({\n        message: \"Close failed\",\n        description: closeResult,\n      });\n    } else {\n      notify({\n        message: \"Close succeeded\",\n        description: (\n          <HyperLink href={explorerLinkFor(closeResult.txid, connection)}>\n            View transaction on explorer\n          </HyperLink>\n        ),\n      });\n    }\n  };\n\n  const claimData = (claimMethod) => {\n    if (claimMethod === \"candy\") {\n      return (\n        <React.Fragment>\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"config-text-field\"\n            label=\"Candy Config\"\n            value={candyConfig}\n            onChange={e => setCandyConfig(e.target.value)}\n          />\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"config-uuid-text-field\"\n            label=\"Candy UUID\"\n            value={candyUUID}\n            onChange={e => setCandyUUID(e.target.value)}\n          />\n        </React.Fragment>\n      );\n    } else if (claimMethod === \"transfer\") {\n      return null;\n    } else if (claimMethod === \"edition\") {\n      return (\n        <React.Fragment>\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"master-mint-text-field\"\n            label=\"Master Mint\"\n            value={masterMint}\n            onChange={(e) => setMasterMint(e.target.value)}\n          />\n        </React.Fragment>\n      );\n    }\n  };\n\n  return (\n    <Stack spacing={2}>\n      <TextField\n        style={{width: \"60ch\"}}\n        id=\"base-text-field\"\n        label=\"Base Private Key\"\n        value={baseKey}\n        onChange={(e) => setBaseKey(e.target.value)}\n      />\n      <FormControl fullWidth>\n        <InputLabel id=\"claim-method-label\">Claim Method</InputLabel>\n        <Select\n          labelId=\"claim-method-label\"\n          id=\"claim-method-select\"\n          value={claimMethod}\n          label=\"Claim Method\"\n          onChange={(e) => {\n            localStorage.setItem(\"claimMethod\", e.target.value);\n            setClaimMethod(e.target.value);\n          }}\n          style={{textAlign: \"left\"}}\n        >\n          <MenuItem value={\"transfer\"}>Token Transfer</MenuItem>\n          <MenuItem value={\"candy\"}>Candy Machine</MenuItem>\n          <MenuItem value={\"edition\"}>Limited Edition</MenuItem>\n        </Select>\n      </FormControl>\n      {claimMethod !== \"\" && claimData(claimMethod)}\n      <Button\n        disabled={!wallet.connected || !baseKey}\n        variant=\"contained\"\n        onClick={(e) => {\n          const wrap = async () => {\n            try {\n              await submit(e);\n            } catch (err) {\n              notify({\n                message: \"Close failed\",\n                description: `${err}`,\n              });\n            }\n          };\n          wrap();\n        }}\n      >\n        Close Gumdrop\n      </Button>\n    </Stack>\n  );\n};\n","import log from 'loglevel';\nimport { SESClient, SendEmailCommand } from \"@aws-sdk/client-ses\"\n\nimport { ClaimantInfo } from \"./claimant\"\n\nexport type AuthKeys = { [key: string] : string }\n\ntype DropInfo = {\n  type : string,\n  meta : string,\n};\n\nconst formatDropMessage = (info : ClaimantInfo, drop : DropInfo) => {\n  if (drop.type === \"Token\") {\n    return {\n      subject: \"Gumdrop Token Drop\",\n      message: `You received ${info.amount} token(s) `\n             + `(click <a href=\"${drop.meta}\">here</a> to view the mint on explorer). `\n             + `<a href=\"${info.url}\">Click here to claim them!</a>`,\n    };\n  } else if (drop.type === \"Candy\") {\n    return {\n      subject: \"Gumdrop NFT Drop\",\n      message: `You received ${info.amount} Candy Machine pre-sale mint `\n             + `(click <a href=\"${drop.meta}\">here</a> to view the config on explorer). `\n             + `<a href=\"${info.url}\">Click here to claim it!</a>`,\n    };\n  } else if (drop.type === \"Edition\") {\n    return {\n      subject: \"Gumdrop NFT Drop\",\n      message: `You received ${info.amount} limited-edition print `\n             + `(click <a href=\"${drop.meta}\">here</a> to view the master on explorer). `\n             + `<a href=\"${info.url}\">Click here to claim it!</a>`,\n    };\n  } else {\n    throw new Error(`Internal Error: Unknown drop type ${drop.type}`);\n  }\n};\n\nexport const setupSes = (auth : AuthKeys, source : string) => {\n  log.debug(\"SES auth\", auth);\n  const client = new SESClient({\n    region: \"us-east-2\",\n    credentials: {\n      accessKeyId: auth.accessKeyId,\n      secretAccessKey: auth.secretAccessKey,\n    },\n  });\n\n  return async (\n    info : ClaimantInfo,\n    drop : DropInfo,\n  ) => {\n    const formatted = formatDropMessage(info, drop);\n    const message = {\n      Destination: {\n        ToAddresses: [\n          info.handle,\n        ]\n      },\n      Message: {\n        Subject: {\n          Data: formatted.subject,\n          Charset: \"utf-8\",\n        },\n        Body: {\n          Html: {\n            Data: formatted.message,\n            Charset: \"utf-8\",\n          },\n        },\n      },\n      Source: source,\n    };\n\n    try {\n      const response = await client.send(new SendEmailCommand(message));\n      log.debug(response);\n      if (response.$metadata.httpStatusCode !== 200) {\n      //   throw new Error(`AWS SES ssemed to fail to send email: ${response[0].reject_reason}`);\n      }\n    } catch (err) {\n      console.error(err);\n    }\n  };\n}\n\nexport const setupManual = (auth : AuthKeys, source : string) => {\n  return async (\n    info : ClaimantInfo,\n    mintUrl: string,\n  ) => {\n    // TODO duplicated work since claim URLs are available for download\n    // regardless...\n    log.debug({\n      \"handle\": info.handle,\n      \"url\": info.url,\n    });\n  };\n}\n\nexport const setupWalletListUpload = (auth : AuthKeys, source : string) => {\n  const toUpload = Array<{ [key: string] : string }>();\n  return async (\n    info : ClaimantInfo,\n    mintUrl: string,\n  ) => {\n    toUpload.push({\n      \"handle\": info.handle,\n      \"url\": info.url,\n    });\n  };\n}\n","import React from \"react\"\nimport {\n  useColorMode,\n} from \"../contexts/ColorModeContext\";\n\nexport const DragAndDrop = (props) => {\n  const dropRef = React.useRef<HTMLDivElement>(null);\n  const [dragCounter, setDragCounter] = React.useState(0);\n  const [dragging, setDragging] = React.useState(false);\n\n  const handleDrag = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n  };\n\n  const handleDragIn = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    setDragCounter(dragCounter + 1);\n    if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {\n      setDragging(true);\n    }\n  };\n\n  const handleDragOut = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    const remainingDrags = dragCounter - 1;\n    setDragCounter(remainingDrags);\n    if (remainingDrags === 0) {\n      setDragging(false);\n    }\n  };\n\n  const handleDrop = (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    setDragging(false);\n    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\n      props.handleDrop(e.dataTransfer.files);\n      e.dataTransfer.clearData();\n      setDragCounter(0);\n    }\n  };\n\n  React.useEffect(() => {\n    const node = dropRef.current;\n    if (node === null) return;\n    node.addEventListener(\"dragenter\" , handleDragIn);\n    node.addEventListener(\"dragleave\" , handleDragOut);\n    node.addEventListener(\"dragover\"  , handleDrag);\n    node.addEventListener(\"drop\"      , handleDrop);\n\n    return () => {\n      node.removeEventListener(\"dragenter\" , handleDragIn);\n      node.removeEventListener(\"dragleave\" , handleDragOut);\n      node.removeEventListener(\"dragover\"  , handleDrag);\n      node.removeEventListener(\"drop\"      , handleDrop);\n    };\n  });\n\n  const colorModeCtx = useColorMode();\n  const shade = colorModeCtx.mode === 'dark' ? \"rgba(255,255,255,.1)\" : \"rgba(0, 0, 0,.1)\";\n\n  return (\n    <div\n      ref={dropRef}\n      style={dragging ? { backgroundColor: shade} : {}}\n    >\n      {props.children}\n    </div>\n  );\n};\n\n\nexport default DragAndDrop;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport {\n  Box,\n  Button,\n  CircularProgress,\n  FormControl,\n  Link as HyperLink,\n  InputLabel,\n  MenuItem,\n  Stack,\n  Select,\n  Table,\n  TableBody,\n  TableCell,\n  TableContainer,\n  TableHead,\n  TableRow,\n  TextField,\n} from \"@mui/material\";\nimport FilePresentIcon from '@mui/icons-material/FilePresent';\n\nimport {\n  useWallet,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  Keypair,\n  PublicKey,\n} from \"@solana/web3.js\";\nimport {\n  MintInfo,\n} from \"@solana/spl-token\";\nimport BN from 'bn.js';\n\nimport {\n  useConnection,\n  Connection,\n} from \"../contexts\";\nimport {\n  GUMDROP_DISTRIBUTOR_ID,\n  GUMDROP_TEMPORAL_SIGNER,\n  notify,\n  shortenAddress,\n} from \"../utils\";\nimport {\n  ClaimantInfo,\n  buildGumdrop,\n  parseClaimants,\n  validateTransferClaims,\n  validateCandyClaims,\n  validateEditionClaims,\n} from \"../utils/claimant\";\nimport {\n  AuthKeys,\n  setupSes,\n  setupManual,\n  setupWalletListUpload,\n} from \"../utils/communication\";\nimport {\n  envFor,\n  explorerLinkFor,\n} from \"../utils/transactions\";\nimport { DragAndDrop } from \"./DragAndDrop\";\nimport { DefaultModal } from \"./DefaultModal\";\n\n// NB: assumes no overflow\nconst randomBytes = () : Uint8Array => {\n  // TODO: some predictable seed? sha256?\n  const buf = new Uint8Array(4);\n  window.crypto.getRandomValues(buf);\n  return buf;\n}\n\nconst WHITESPACE = \"\\u00A0\";\n\nconst setupSender = (\n  method : string,\n  auth : AuthKeys,\n  source : string,\n) => {\n  if (method === \"AWS SES\") {\n    return setupSes(auth, source);\n  } else if (method === \"Manual\") {\n    return setupManual(auth, source);\n  } else if (method === \"Wallets\") {\n    return setupWalletListUpload(auth, source);\n  } else {\n    throw new Error(`Unrecognized claim distribution method ${method}`);\n  }\n}\n\nconst reactModal = (renderModal) => {\n  const container = document.createElement('div');\n  document.body.appendChild(container);\n\n  const displayModal = ({ onSubmit, onDismiss }) => {\n    ReactDOM.render(renderModal({ onSubmit, onDismiss, show: true }), container);\n  };\n\n  const hideModal = ({ onSubmit, onDismiss }, callback) => {\n    ReactDOM.render(renderModal({ onSubmit, onDismiss, show: false }), container, callback);\n  };\n\n  const destroyModal = () => {\n    ReactDOM.unmountComponentAtNode(container);\n    document.body.removeChild(container);\n  };\n\n  const confirmation = new Promise((resolve) => {\n    const onSubmit = (value) => resolve(value);\n    const onDismiss = () => resolve(undefined);\n    displayModal({ onSubmit, onDismiss });\n  });\n\n  return confirmation.finally(() => {\n    const onSubmit = () => {};\n    const onDismiss = () => {};\n    hideModal({ onSubmit, onDismiss }, destroyModal);\n  });\n};\n\nconst resendOnlyRender = ({ show, onSubmit, onDismiss }) => {\n  const options = [\n    { click: () => onSubmit(\"create\"), name: \"Create and Send\" },\n    { click: () => onSubmit(\"send\")  , name: \"Send only\"       },\n  ];\n  return (\n    <DefaultModal visible={show} onCancel={onDismiss} width=\"70ch\">\n      <p style={{\n        color: \"white\",\n        fontSize: \"1rem\",\n        width: \"50ch\",\n        marginTop: 8,\n      }}>\n        Uploaded distribution list has URLs for all claimants.\n        Skip creation of airdrop and only re-send links?\n      </p>\n      <br />\n      <Stack direction=\"row\" spacing={2}>\n      {options.map((opt) => {\n        return (\n          <Button\n            key={opt.name}\n            style={{\n              width: \"30ch\",\n              color: \"white\",\n              marginBottom: 8,\n            }}\n            variant=\"outlined\"\n            onClick={opt.click}\n          >\n            {opt.name}\n          </Button>\n        );\n      })}\n      </Stack>\n    </DefaultModal>\n  );\n};\n\nconst displayMintTokens = (amount : number, mintInfo : MintInfo) : string => {\n  // TODO: better decimal rounding\n  return String(amount / Math.pow(10, mintInfo.decimals));\n};\n\nconst hyperLinkData = (data) => {\n  const encoded = encodeURIComponent(JSON.stringify(data));\n  return `data:text/plain;charset=utf-8,${encoded}`;\n};\n\nconst shouldSendRender = (claimants, needsPin, claimMethod, claimInfo, baseKey) => {\n  return ({ show, onSubmit, onDismiss }) => {\n    return (\n      <DefaultModal visible={show} onCancel={onDismiss} width=\"70ch\">\n        <h2\n          style={{\n            color: \"white\",\n            fontWeight: \"bold\",\n            fontSize: 20,\n          }}\n        >\n          Claim Distribution Preview\n        </h2>\n        <p style={{ color: \"white\", fontSize: 14, textAlign: \"center\" }}>\n          Approving will save the keypair authority generated for gumdrop\n          state. This keypair is necessary to close the gumdrop later!\n        </p>\n        <TableContainer\n          sx={{\n            \"td, th\": { color: \"white\" },\n            backgroundColor: \"#444444\",\n            borderRadius: \"5px\",\n            maxHeight: \"30ch\",\n          }}\n        >\n          <Table size=\"small\">\n            <TableHead>\n              <TableRow>\n                <TableCell>Handle</TableCell>\n                <TableCell>\n                  {claimMethod === \"edition\"\n                    ? \"Edition\"\n                    : \"Tokens\"\n                  }\n                </TableCell>\n                {needsPin && <TableCell>Pin</TableCell>}\n              </TableRow>\n            </TableHead>\n            <TableBody>\n              {claimants.map((c, idx) => (\n                <TableRow\n                  key={idx}\n                  sx={{ 'td, th': { border: 0 } }}\n                >\n                  <TableCell component=\"th\" scope=\"row\">{c.handle} </TableCell>\n                  <TableCell>\n                    { claimMethod === \"transfer\" ? displayMintTokens(c.amount, claimInfo.mint.info)\n                    : claimMethod === \"candy\"    ? c.amount\n                    : /* === \"edition\" */          c.edition\n                    }\n                  </TableCell>\n                  {needsPin && <TableCell>{c.pin.toNumber()}</TableCell>}\n                </TableRow>\n              ))}\n            </TableBody>\n          </Table>\n        </TableContainer>\n        <Box style={{ height: \"3ch\" }} />\n        <Stack direction=\"row\" spacing={2}>\n          <Button\n            style={{\n              width: \"30ch\",\n              color: \"white\",\n              marginBottom: 8,\n            }}\n            variant=\"outlined\"\n            onClick={() => onSubmit(false)}\n          >\n            Cancel\n          </Button>\n          <HyperLink\n            href={hyperLinkData(Array.from(baseKey.secretKey))}\n            download={`${baseKey.publicKey.toBase58()}.json`}\n            underline=\"none\"\n            style={{width: \"30ch\"}}\n          >\n            <Button\n              style={{\n                width: \"100%\",\n                color: \"white\",\n                marginBottom: 8,\n              }}\n              variant=\"outlined\"\n              onClick={() => onSubmit(true)}\n            >\n              Approve\n            </Button>\n          </HyperLink>\n        </Stack>\n      </DefaultModal>\n    );\n  }\n};\n\nexport type CreateProps = {};\n\nexport const Create = (\n  props : CreateProps,\n) => {\n  const connection = useConnection();\n  const wallet = useWallet();\n\n  // claim state\n  const [claimMethod, setClaimMethod] = React.useState(localStorage.getItem(\"claimMethod\") || \"\");\n  const [candyConfig, setCandyConfig] = React.useState(localStorage.getItem(\"candyConfig\") || \"\");\n  const [candyUUID, setCandyUUID] = React.useState(localStorage.getItem(\"candyUUID\") || \"\");\n  const [mint, setMint] = React.useState(localStorage.getItem(\"mint\") || \"\");\n  const [masterMint, setMasterMint] = React.useState(localStorage.getItem(\"masterMint\") || \"\");\n  const [filename, setFilename] = React.useState(\"\");\n  const [text, setText] = React.useState(\"\");\n  const [claimURLs, setClaimURLs] = React.useState<Array<ClaimantInfo>>([]);\n\n  // auth state\n  const [otpAuth, setOtpAuth] = React.useState(localStorage.getItem(\"otpAuth\") || \"default\");\n  const [commMethod, setCommMethod] = React.useState(localStorage.getItem(\"commMethod\") || \"\");\n  const [commAuth, setCommAuth] = React.useState<AuthKeys>({});\n  const [commSource, setCommSource] = React.useState(localStorage.getItem(\"commSource\") || \"\");\n  const [awsAccessKeyId, setAwsAccessKeyId] = React.useState(\"\");\n  const [awsSecretKey, setAwsSecretKey] = React.useState(\"\");\n  const [mailcAPIKey, setMailcAPIKey] = React.useState(\"\");\n\n  const explorerUrlFor = (key : PublicKey) => {\n    return `https://explorer.solana.com/address/${key.toBase58()}?cluster=${envFor(connection)}`;\n  }\n\n  const submit = async (e : React.SyntheticEvent) => {\n    e.preventDefault();\n\n    setClaimURLs([]);\n\n    if (!wallet.connected || wallet.publicKey === null) {\n      throw new Error(`Wallet not connected`);\n    }\n\n    const claimants = parseClaimants(text);\n    if (claimants.length === 0) {\n      throw new Error(`No claimants provided`);\n    }\n\n    let claimInfo;\n    switch (claimMethod) {\n      case \"transfer\": {\n        claimInfo = await validateTransferClaims(\n          connection,\n          envFor(connection),\n          wallet.publicKey,\n          claimants,\n          mint,\n        );\n        break;\n      }\n      case \"candy\": {\n        claimInfo = await validateCandyClaims(\n          connection,\n          envFor(connection),\n          wallet.publicKey,\n          claimants,\n          candyConfig,\n          candyUUID,\n        );\n        break;\n      }\n      case \"edition\": {\n        claimInfo = await validateEditionClaims(\n          connection,\n          envFor(connection),\n          wallet.publicKey,\n          claimants,\n          masterMint,\n        );\n        break;\n      }\n      default:\n        throw new Error(`Unknown claim method ${claimMethod}`);\n    }\n    console.log(\"Claims info\", claimInfo);\n\n\n    const mightHaveExisting = (info : ClaimantInfo) => {\n      // TODO: others?\n      return info.url !== undefined && info.url !== null;\n    };\n    if (claimants.reduce((acc, c) => acc && mightHaveExisting(c), true)) {\n      // TODO: more validation of URLs? The creator is using they're own\n      // credentials to re-send so if they're malicious it's not that bad\n      // right?...\n      const resendOnly = await reactModal(resendOnlyRender);\n      console.log(\"Resend only\", resendOnly);\n      if (resendOnly === \"send\") {\n        setClaimURLs(claimants);\n        const sender = setupSender(commMethod, commAuth, commSource);\n        for (const c of claimants) {\n          await sender(c, claimInfo.info);\n        }\n        return;\n      } else if (resendOnly === \"create\") {\n        // fallthrough to full create\n      } else {\n        // dismissed. don't use exceptions for control flow?\n        throw new Error(\"Dismissed\");\n      }\n    }\n\n    claimants.forEach(c => {\n      c.pin = new BN(randomBytes());\n      c.seed = claimMethod === \"transfer\" ? claimInfo.mint.key\n             : claimMethod === \"candy\"    ? claimInfo.config\n             : /* === edition */            claimInfo.masterMint.key;\n    });\n\n    // temporal auth is the AWS signer by 'default' and a no-op key otherwise\n    let temporalSigner;\n    if (commMethod === \"Wallets\") {\n      // TODO: this is a bit jank. There should be no form option to set the\n      // OTP auth if we are using a wallet but there's still a defaulted value\n      // atm...\n      // NB: We also need this to not be 'none' since there is a special check\n      // for claimant_secret==accounts.temporal\n      temporalSigner = GUMDROP_DISTRIBUTOR_ID;\n    } else if (otpAuth === \"default\") {\n      temporalSigner = GUMDROP_TEMPORAL_SIGNER;\n    } else if (otpAuth === \"none\") {\n      temporalSigner = PublicKey.default;\n    } else {\n      throw new Error(`Unknown OTP authorization type ${otpAuth}`);\n    }\n\n    console.log(`Temporal signer: ${temporalSigner.toBase58()}`);\n\n    const base = Keypair.generate();\n    console.log(`Base ${base.publicKey.toBase58()}`);\n\n    const needsPin = commMethod !== \"Wallets\";\n    const instructions = await buildGumdrop(\n      connection,\n      wallet.publicKey,\n      needsPin,\n      claimMethod,\n      `${window.location.origin}${window.location.pathname}`,\n      base.publicKey,\n      temporalSigner,\n      claimants,\n      claimInfo\n    );\n\n    const shouldSend = await reactModal(\n      shouldSendRender(claimants, needsPin, claimMethod, claimInfo, base)\n    ) as boolean | undefined;\n    if (shouldSend === true) {\n    } else {\n      // dismissed. don't use exceptions for control flow?\n      throw new Error(\"Claim distribution preview not approved\");\n    }\n\n\n    setClaimURLs(claimants);\n\n    const createResult = await Connection.sendTransactionWithRetry(\n      connection,\n      wallet,\n      instructions,\n      [base]\n    );\n\n    console.log(createResult);\n    if (typeof createResult === \"string\") {\n      throw new Error(createResult);\n    } else {\n      notify({\n        message: \"Gumdrop creation succeeded\",\n        description: (\n          <HyperLink href={explorerLinkFor(createResult.txid, connection)}>\n            View transaction on explorer\n          </HyperLink>\n        ),\n      });\n    }\n\n    console.log(\"Distributing claim URLs\");\n    const sender = setupSender(commMethod, commAuth, commSource);\n    for (const c of claimants) {\n      await sender(c, claimInfo.info);\n    }\n  };\n\n  const handleFiles = (files) => {\n    if (files.length !== 1) {\n      notify({\n        message: \"File upload failed\",\n        description: `Received ${files.length} files`,\n      });\n      return;\n    }\n\n    const file = files[0];\n    const reader = new FileReader();\n    reader.onload = (e) => {\n      if (e !== null && e.target !== null) {\n        if (typeof e.target.result === \"string\") {\n          try {\n            parseClaimants(e.target.result);\n          } catch {\n            notify({\n              message: `File upload failed for: ${file.name}`,\n              description: (\n                <span>\n                  Could not parse uploaded file.{WHITESPACE}\n                  <HyperLink href=\"#/\">\n                    Does it follow the JSON scheme?\n                  </HyperLink>\n                </span>\n              ),\n            });\n            setFilename(\"\");\n            setText(\"\");\n            return;\n          }\n          setFilename(file.name);\n          setText(e.target.result);\n        } else {\n          notify({\n            message: `File upload failed for: ${file.name}`,\n            description: \"Could not read uploaded file\",\n          });\n        }\n      }\n    };\n    reader.readAsText(file);\n  };\n\n  const claimData = (claimMethod) => {\n    if (claimMethod === \"candy\") {\n      return (\n        <React.Fragment>\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"config-text-field\"\n            label=\"Candy Config\"\n            value={candyConfig}\n            onChange={e => {\n              setCandyConfig(e.target.value);\n              localStorage.setItem(\"candyConfig\", e.target.value);\n            }}\n          />\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"config-uuid-text-field\"\n            label=\"Candy UUID\"\n            value={candyUUID}\n            onChange={e => {\n              setCandyUUID(e.target.value);\n              localStorage.setItem(\"candyUUID\", e.target.value);\n            }}\n          />\n        </React.Fragment>\n      );\n    } else if (claimMethod === \"transfer\") {\n      return (\n        <TextField\n          style={{width: \"60ch\"}}\n          id=\"mint-text-field\"\n          label=\"Mint\"\n          value={mint}\n          onChange={(e) => {\n            localStorage.setItem(\"mint\", e.target.value);\n            setMint(e.target.value);\n          }}\n        />\n      );\n    } else if (claimMethod === \"edition\") {\n      // transfers master mint token from this account to the distributor\n      // wallet ATA\n      return (\n        <TextField\n          style={{width: \"60ch\"}}\n          id=\"master-mint-text-field\"\n          label=\"Master Mint\"\n          value={masterMint}\n          onChange={(e) => {\n            localStorage.setItem(\"masterMint\", e.target.value);\n            setMasterMint(e.target.value);\n          }}\n        />\n      );\n    }\n  };\n\n  const commAuthorization = (commMethod) => {\n    if (commMethod === \"Manual\" || commMethod === \"Wallets\") {\n      return null;\n    }\n\n    if (commMethod === \"AWS SES\") {\n      return (\n        <React.Fragment>\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"comm-access-key-id-field\"\n            label={`${commMethod} Access Key Id`}\n            value={awsAccessKeyId}\n            onChange={(e) => {\n              setCommAuth(prev => ({...prev, accessKeyId: e.target.value}));\n              setAwsAccessKeyId(e.target.value)\n            }}\n          />\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"comm-secret-access-key-field\"\n            label={`${commMethod} Secret Access Key`}\n            value={awsSecretKey}\n            onChange={(e) => {\n              setCommAuth(prev => ({...prev, secretAccessKey: e.target.value}));\n              setAwsSecretKey(e.target.value)\n            }}\n          />\n          <TextField\n            style={{width: \"60ch\"}}\n            id=\"comm-source-field\"\n            label={`${commMethod} Source`}\n            value={commSource}\n            onChange={(e) => {\n              localStorage.setItem(\"commSource\", e.target.value);\n              setCommSource(e.target.value)\n            }}\n          />\n        </React.Fragment>\n      );\n    }\n\n    return (\n      <React.Fragment>\n        <TextField\n          style={{width: \"60ch\"}}\n          id=\"comm-auth-field\"\n          label={`${commMethod} API key`}\n          value={mailcAPIKey}\n          onChange={(e) => {\n            setCommAuth(prev => ({...prev, apiKey: e.target.value}));\n            setMailcAPIKey(e.target.value)\n          }}\n        />\n        <TextField\n          style={{width: \"60ch\"}}\n          id=\"comm-source-field\"\n          label={`${commMethod} Source`}\n          value={commSource}\n          onChange={(e) => {\n            localStorage.setItem(\"commSource\", e.target.value);\n            setCommSource(e.target.value)\n          }}\n        />\n      </React.Fragment>\n    );\n  };\n\n  const fileUpload = (\n    <React.Fragment>\n      <DragAndDrop handleDrop={handleFiles} >\n        <Stack\n          direction=\"row\"\n          style={{\n            width: \"60ch\",\n            height: \"15ch\",\n          }}\n          sx={{\n            border: '1px dashed grey',\n            justifyContent: \"center\",\n            alignContent: \"center\",\n          }}\n        >\n          <Button\n            variant=\"text\"\n            component=\"label\"\n            style={{\n              padding: 0,\n              // don't make the button click field too large...\n              marginTop: \"5ch\",\n              marginBottom: \"5ch\",\n            }}\n          >\n            Upload a {filename === \"\" ? \"distribution\" : \"different\"} list\n            <input\n              type=\"file\"\n              onChange={(e) => {\n                handleFiles(e.target.files);\n                // re-parse every time...\n                e.target.value = '';\n              }}\n              hidden\n            />\n          </Button>\n          {WHITESPACE}\n          {/*For display alignment...*/}\n          <Button\n            variant=\"text\"\n            component=\"label\"\n            disabled={true}\n            style={{padding: 0}}\n          >\n            or drag it here\n          </Button>\n        </Stack>\n      </DragAndDrop>\n      {filename !== \"\"\n      ? (<Button\n            variant=\"text\"\n            component=\"label\"\n            disabled={true}\n            style={{\n              padding: 0,\n              // textTransform: 'none',\n            }}\n          >\n            <FilePresentIcon />\n            <span>{WHITESPACE} Uploaded {filename}</span>\n          </Button>\n        )\n      : (<Box/>)}\n    </React.Fragment>\n  );\n\n  const [loading, setLoading] = React.useState(false);\n  const loadingProgress = () => (\n    <CircularProgress\n      size={24}\n      sx={{\n        position: 'absolute',\n        top: '50%',\n        left: '50%',\n        marginTop: '-12px',\n        marginLeft: '-12px',\n      }}\n    />\n  );\n  const createAirdrop = (\n    <Box sx={{ position: \"relative\" }}>\n    <Button\n      disabled={!wallet.connected || !commMethod || !filename || loading}\n      variant=\"contained\"\n      style={{ width: \"100%\" }}\n      onClick={(e) => {\n        setLoading(true);\n        const wrap = async () => {\n          try {\n            await submit(e);\n            setLoading(false);\n          } catch (err) {\n            notify({\n              message: \"Create failed\",\n              description: `${err}`,\n            });\n            setLoading(false);\n          }\n        };\n        wrap();\n      }}\n    >\n      Create{claimURLs.length > 0 ? \" Another \" : \" \"}Gumdrop\n    </Button>\n    {loading && loadingProgress()}\n    </Box>\n  );\n\n  const otpAuthC = (\n    <React.Fragment>\n      <FormControl fullWidth>\n        <InputLabel id=\"otp-auth-label\">OTP Authorization</InputLabel>\n        <Select\n          labelId=\"otp-auth-label\"\n          id=\"otp-auth-select\"\n          value={otpAuth}\n          label=\"OTP Authorization\"\n          onChange={(e) => {\n            localStorage.setItem(\"otpAuth\", e.target.value);\n            setOtpAuth(e.target.value);\n          }}\n          style={{textAlign: \"left\"}}\n        >\n          <MenuItem value={\"default\"}>\n            Default{WHITESPACE}\n            <HyperLink\n              href={explorerUrlFor(GUMDROP_TEMPORAL_SIGNER)}\n              underline=\"none\"\n              target=\"_blank\" rel=\"noopener noreferrer\"\n            >\n              ({shortenAddress(GUMDROP_TEMPORAL_SIGNER.toBase58())})\n            </HyperLink>\n          </MenuItem>\n          <MenuItem value={\"none\"}>None</MenuItem>\n        </Select>\n      </FormControl>\n    </React.Fragment>\n  );\n\n  return (\n    <Stack spacing={2}>\n      <FormControl fullWidth>\n        <InputLabel id=\"claim-method-label\">Claim Method</InputLabel>\n        <Select\n          labelId=\"claim-method-label\"\n          id=\"claim-method-select\"\n          value={claimMethod}\n          label=\"Claim Method\"\n          onChange={(e) => {\n            localStorage.setItem(\"claimMethod\", e.target.value);\n            setClaimMethod(e.target.value);\n          }}\n          style={{textAlign: \"left\"}}\n        >\n          <MenuItem value={\"transfer\"}>Token Transfer</MenuItem>\n          <MenuItem value={\"candy\"}>Candy Machine</MenuItem>\n          <MenuItem value={\"edition\"}>Limited Edition</MenuItem>\n        </Select>\n      </FormControl>\n      {claimMethod !== \"\" && claimData(claimMethod)}\n      <FormControl fullWidth>\n        <InputLabel id=\"comm-method-label\">Distribution Method</InputLabel>\n        <Select\n          labelId=\"comm-method-label\"\n          id=\"comm-method-select\"\n          value={commMethod}\n          label=\"Distribution Method\"\n          onChange={(e) => {\n            localStorage.setItem(\"commMethod\", e.target.value);\n            setCommMethod(e.target.value);\n          }}\n          style={{textAlign: \"left\"}}\n        >\n          <MenuItem value={\"AWS SES\"}>AWS SES</MenuItem>\n          <MenuItem value={\"Manual\"}>Manual</MenuItem>\n          <MenuItem value={\"Wallets\"}>Wallets</MenuItem>\n        </Select>\n      </FormControl>\n      {commMethod !== \"\" && commAuthorization(commMethod)}\n      {commMethod !== \"\" && commMethod !== \"Wallets\" && otpAuthC}\n      {fileUpload}\n      {createAirdrop}\n      {claimURLs.length > 0 && (\n        <HyperLink\n          href={hyperLinkData(claimURLs)}\n          download=\"claimURLs.json\"\n          underline=\"none\"\n          style={{width: \"100%\"}}\n        >\n          <Button\n            variant=\"contained\"\n            style={{width: \"100%\"}}\n          >\n            Download claim URLs\n          </Button>\n        </HyperLink>\n      )}\n    </Stack>\n  );\n};\n","import React from \"react\";\nimport {\n  HashRouter,\n  Link,\n  Route,\n  Switch,\n} from \"react-router-dom\";\n\nimport { createTheme, ThemeProvider } from \"@mui/material/styles\";\nimport CssBaseline from \"@mui/material/CssBaseline\";\nimport {\n  Box,\n  Link as HyperLink,\n  Stack,\n} from \"@mui/material\";\n\nimport \"./App.css\";\nimport {\n  useColorMode,\n} from \"./contexts\";\nimport Centered from \"./components/Centered\";\nimport Header from \"./components/Header/Header\";\nimport { Claim } from \"./components/Claim\";\nimport { Close } from \"./components/Close\";\nimport { Create } from \"./components/Create\";\n\nconst WHITESPACE = \"\\u00A0\";\n\ntype AboutProps = {};\n\nconst About = (\n  props : AboutProps,\n) => {\n  const summary = (\n    <Stack spacing={1}>\n      <div>\n      The Gumdrop program leverages the Solana blockchain and merkle trees to\n      facilitate airdrops to a large number of whitelisted users at a low cost\n      to creators.\n      </div>\n\n      <div>\n      In the Solana ecosystem, the cost of token airdrops is currently largely\n      due to rent costs being{WHITESPACE}\n      <HyperLink\n        href=\"https://docs.solana.com/implemented-proposals/rent\"\n        underline=\"none\"\n      >\n        \"fixed at the genesis\"\n      </HyperLink>\n      . With the large increase in SOLUSD since genesis, rent costs when\n      creating accounts for thousands of users have duly skyrocketed.\n      </div>\n\n      <div>\n      Simultaneously, NFT projects often have a presale to early project\n      followers and contributors. However, the candy-machine doesn't have the\n      ability to grant early minting to a whitelisted subset of wallets while\n      also using the same asset configuration for open launch.\n      </div>\n\n      <div>\n      Gumdrop (originally pioneered for token airdrops by{\" \"}\n      <HyperLink\n        href=\"https://github.com/Uniswap/merkle-distributor\"\n        underline=\"none\"\n      >\n        Uniswap\n      </HyperLink>\n      {\" \"}and ported to Solana by{WHITESPACE}\n      <HyperLink\n        href=\"https://github.com/saber-hq/merkle-distributor\"\n        underline=\"none\"\n      >\n        Saber\n      </HyperLink>) solves both these issues by building a space-efficient hash\n      structure (the merkle tree) such that an on-chain program can validate\n      whether the user is part of a whitelist. Moreover, Gumdrop\n      allows creators to directly send whitelisted users an airdrop reclamation\n      link by building the tree with off-chain handles (e.g email, twitter,\n      etc) and allowing the user to redeem into any wallet.\n      </div>\n    </Stack>\n  );\n\n  const create= (\n    <Stack spacing={1}>\n      <Link to=\"/create\">\n        CREATION\n      </Link>\n\n      <div>\n      Creation builds a whitelist of users that can claim either existing\n      fungible tokens or directly mint from a pre-sale candy-machine.\n      </div>\n\n      <div>\n      Creators must choose a mint or a candy-machine config and UUID, an\n      off-chain notification method (based on the handles supplied below, e.g\n      email, twitter, etc), and supply a list of recipients and balances with\n      the following JSON schema{WHITESPACE}\n      <HyperLink\n        href={`data:text/plain;charset=utf-8,${JSON.stringify(require(\"./example.json\"))}`}\n        download=\"example.json\"\n        underline=\"none\"\n      >\n      (Click here for an example)\n      </HyperLink>\n      </div>\n\n      <pre style={{ fontSize: 14 }}>{`\n[\n  {\n    \"handle\": \"<DISTRIBUTION-SPECIFIC-HANDLE>\"\n    \"amount\": <#-TOKENS-OR-CANDY-MINTS>\n  },\n  ...\n]`}</pre>\n\n      <div>\n      NB: When a candy-machine is supplied, update authority for the\n      candy-machine will be transferred to the Gumdrop state. This can\n      be reclaimed by closing the Gumdrop.\n      </div>\n    </Stack>\n  );\n\n  const claim = (\n    <Stack spacing={1}>\n      <Link to=\"/claim\">\n        CLAIMS\n      </Link>\n\n      <div>\n      Claims are redeemed through a URL with query parameters holding\n      claim-specific keys. Claimants will need to verify ownership of the\n      specified handle by answering a OTP challenge and pay the rent and\n      minting fees if applicable.\n      </div>\n    </Stack>\n  );\n\n  const close = (\n    <Stack spacing={1}>\n      <Link to=\"/close\">\n        CLOSING\n      </Link>\n\n      <div>\n      Closing the Gumdrop cleans up the on-chain state and allows\n      creators to recycle any lamports held for rent-exemption after the\n      airdrop is complete.\n      </div>\n\n      <div>\n      When closing a candy-machine-integrated distributor, update authority\n      will be transferred back to the wallet owner.\n      </div>\n    </Stack>\n  );\n\n  const steps = [\n    { name: \"summary\" , inner: summary } ,\n    { name: \"create\"  , inner: create  } ,\n    { name: \"claim\"   , inner: claim   } ,\n    { name: \"close\"   , inner: close   } ,\n  ];\n  return (\n    <Stack\n      alignContent=\"left\"\n      textAlign=\"left\"\n      spacing={2}\n    >\n      {steps.map(s => s.inner)}\n    </Stack>\n  );\n};\n\nconst getWindowDimensions = () => {\n  const { innerWidth: width, innerHeight: height } = window;\n  return {\n    width,\n    height,\n  };\n};\n\n// eslint-disable-next-line\nconst useWindowDimensions = () => {\n  const [windowDimensions, setWindowDimensions] = React.useState(\n    getWindowDimensions()\n  );\n\n  React.useEffect(() => {\n    const handleResize = () => {\n      setWindowDimensions(getWindowDimensions());\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []);\n\n  return windowDimensions;\n};\n\nfunction App() {\n  const colorModeCtx = useColorMode();\n\n  React.useEffect(() => {}, [colorModeCtx.mode]);\n\n  const theme = React.useMemo(\n    () => {\n      let mode, disabledColor;\n      if (colorModeCtx.mode === \"dark\" || !colorModeCtx.mode) {\n        mode = \"dark\";\n        disabledColor = \"#eee\";\n      } else {\n        mode = \"light\";\n        disabledColor = \"#111\";\n      }\n\n      return createTheme({\n        palette: {\n          mode,\n          action: {\n            disabled: disabledColor,\n          },\n        },\n      })\n    },\n    [colorModeCtx.mode]\n  );\n\n  const { height } = useWindowDimensions();\n\n  return (\n    <div className=\"App\" style={{ backgroundColor: \"transparent\" }}>\n      <ThemeProvider theme={theme}>\n        <CssBaseline />\n        <Header />\n        <Centered height={ `${height * 0.8}px` } width=\"60ch\">\n          <Box height=\"60px\" />\n          <HashRouter>\n            <Switch>\n              <Route path=\"/create\" component={Create} />\n              <Route path=\"/claim\" component={Claim} />\n              <Route path=\"/close\" component={Close} />\n              <Route path=\"/\" component={About} />\n            </Switch>\n          </HashRouter>\n          <Box height=\"80px\" />\n        </Centered>\n      </ThemeProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport {\n  AccountsProvider,\n  WalletProvider,\n  ConnectionProvider,\n  ColorModeContextProvider,\n} from \"./contexts\";\n\nimport \"antd/dist/antd.css\";\nimport \"@fontsource/open-sans\";\nimport \"@fontsource/roboto\";\nimport \"@fontsource/sora\";\n\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <ConnectionProvider>\n      <WalletProvider>\n        <AccountsProvider>\n          <ColorModeContextProvider>\n            <App />\n          </ColorModeContextProvider>\n        </AccountsProvider>\n      </WalletProvider>\n    </ConnectionProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\nreportWebVitals();\n","import {\n  Blockhash,\n  Commitment,\n  Connection,\n  FeeCalculator,\n  Keypair,\n  RpcResponseAndContext,\n  SignatureStatus,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n} from '@solana/web3.js';\nimport { sleep } from \"../utils/utils\";\nimport log from 'loglevel';\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport const DEFAULT_TIMEOUT = 15000;\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nexport const envFor = (\n  connection: Connection\n) : string => {\n  const endpoint = (connection as any)._rpcEndpoint;\n  const regex = /https:\\/\\/api.([^.]*).solana.com/;\n  const match = endpoint.match(regex);\n  if (match[1]) {\n    return match[1];\n  }\n  return \"mainnet-beta\";\n}\n\nexport const explorerLinkFor = (\n  txid: TransactionSignature,\n  connection: Connection\n) : string => {\n  return `https://explorer.solana.com/tx/${txid}?cluster=${envFor(connection)}`;\n}\n\nexport const sendTransactionWithRetryWithKeypair = async (\n  connection: Connection,\n  wallet: Keypair,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void,\n) => {\n  const transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.sign(...[wallet, ...signers]);\n  } else {\n    transaction.sign(wallet);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const { txid, slot } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction,\n  });\n\n  return { txid, slot };\n};\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    },\n  );\n\n  log.debug('Started awaiting confirmation for', txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      'confirmed',\n      true,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      log.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err) {\n    log.error('Timeout Error caught', err);\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, 'single')\n      ).value;\n    } catch (e) {\n      log.error('Simulate Transaction error', e);\n    }\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith('Program log: ')) {\n            throw new Error(\n              'Transaction failed: ' + line.slice('Program log: '.length),\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  log.debug('Latency (ms)', txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment,\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching,\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config: any = { encoding: 'base64', commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest('simulateTransaction', args);\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n  return res.result;\n}\n\nexport async function awaitTransactionSignatureConfirmation(\n  txid: TransactionSignature,\n  timeout: number,\n  connection: Connection,\n  commitment: Commitment = 'recent',\n  queryStatus = false,\n): Promise<SignatureStatus | null | void> {\n  let done = false;\n  let status: SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  // eslint-disable-next-line no-async-promise-executor\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      log.warn('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            log.warn('Rejected via websocket', result.err);\n            reject(status);\n          } else {\n            log.debug('Resolved via websocket', result);\n            resolve(status);\n          }\n        },\n        commitment,\n      );\n    } catch (e) {\n      done = true;\n      log.error('WS error in setup', txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          console.log(explorerLinkFor(txid, connection));\n          if (!done) {\n            if (!status) {\n              log.debug('REST null result for', txid, status);\n            } else if (status.err) {\n              log.error('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              log.error('REST no confirmations for', txid, status);\n            } else {\n              log.debug('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            log.error('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  log.debug('Returning status', status);\n  return status;\n}\n","import BN from 'bn.js';\n\nexport const TEN = new BN(10);\nexport const HALF_WAD = TEN.pow(new BN(18));\nexport const WAD = TEN.pow(new BN(18));\nexport const RAY = TEN.pow(new BN(27));\nexport const ZERO = new BN(0);\n","import { useCallback, useState } from 'react';\nimport { MintInfo } from '@solana/spl-token';\n\nimport { TokenAccount } from './../models';\nimport { PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport { WAD, ZERO } from '../constants';\nimport { TokenInfo } from '@solana/spl-token-registry';\n\nexport type KnownTokenMap = Map<string, TokenInfo>;\n\nexport const formatPriceNumber = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 8,\n});\n\nexport function useLocalStorageState(key: string, defaultState?: string) {\n  const [state, setState] = useState(() => {\n    // NOTE: Not sure if this is ok\n    const storedState = localStorage.getItem(key);\n    if (storedState) {\n      return JSON.parse(storedState);\n    }\n    return defaultState;\n  });\n\n  const setLocalStorageState = useCallback(\n    newState => {\n      const changed = state !== newState;\n      if (!changed) {\n        return;\n      }\n      setState(newState);\n      if (newState === null) {\n        localStorage.removeItem(key);\n      } else {\n        try {\n          localStorage.setItem(key, JSON.stringify(newState));\n        } catch {\n          // ignore\n        }\n      }\n    },\n    [state, key],\n  );\n\n  return [state, setLocalStorageState];\n}\n\nexport const findProgramAddress = async (\n  seeds: (Buffer | Uint8Array)[],\n  programId: PublicKey,\n) => {\n  const key =\n    'pda-' +\n    seeds.reduce((agg, item) => agg + item.toString('hex'), '') +\n    programId.toString();\n  let cached = localStorage.getItem(key);\n  if (cached) {\n    const value = JSON.parse(cached);\n\n    return [value.key, parseInt(value.nonce)] as [string, number];\n  }\n\n  const result = await PublicKey.findProgramAddress(seeds, programId);\n\n  try {\n    localStorage.setItem(\n      key,\n      JSON.stringify({\n        key: result[0].toBase58(),\n        nonce: result[1],\n      }),\n    );\n  } catch {\n    // ignore\n  }\n\n  return [result[0].toBase58(), result[1]] as [string, number];\n};\n\n// shorten the checksummed version of the input address to have 4 characters at start and end\nexport function shortenAddress(address: string, chars = 4): string {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n}\n\nexport function getTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownSymbol = map.get(mintAddress)?.symbol;\n  if (knownSymbol) {\n    return knownSymbol;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\nexport function getVerboseTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownName = map.get(mintAddress)?.name;\n  if (knownName) {\n    return knownName;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\n\nexport function getTokenByName(tokenMap: KnownTokenMap, name: string) {\n  let token: TokenInfo | null = null;\n  for (const val of tokenMap.values()) {\n    if (val.symbol === name) {\n      token = val;\n      break;\n    }\n  }\n  return token;\n}\n\nexport function getTokenIcon(\n  map: KnownTokenMap,\n  mintAddress?: string | PublicKey,\n): string | undefined {\n  const address =\n    typeof mintAddress === 'string' ? mintAddress : mintAddress?.toBase58();\n  if (!address) {\n    return;\n  }\n\n  return map.get(address)?.logoURI;\n}\n\nexport function isKnownMint(map: KnownTokenMap, mintAddress: string) {\n  return !!map.get(mintAddress);\n}\n\nexport const STABLE_COINS = new Set(['USDC', 'wUSDC', 'USDT']);\n\nexport function chunks<T>(array: T[], size: number): T[][] {\n  return Array.apply<number, T[], T[][]>(\n    0,\n    new Array(Math.ceil(array.length / size)),\n  ).map((_, index) => array.slice(index * size, (index + 1) * size));\n}\n\nexport function toLamports(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  return Math.floor(amount * precision);\n}\n\nexport function wadToLamports(amount?: BN): BN {\n  return amount?.div(WAD) || ZERO;\n}\n\nexport function fromLamports(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount = Math.floor(\n    typeof account === 'number'\n      ? account\n      : BN.isBN(account)\n      ? account.toNumber()\n      : account.info.amount.toNumber(),\n  );\n\n  const precision = Math.pow(10, mint?.decimals || 9);\n  return (amount / precision) * rate;\n}\n\nexport const tryParseKey = (key: string): PublicKey | null => {\n  try {\n    return new PublicKey(key);\n  } catch (error) {\n    return null;\n  }\n};\n\nvar SI_SYMBOL = ['', 'k', 'M', 'G', 'T', 'P', 'E'];\n\nconst abbreviateNumber = (number: number, precision: number) => {\n  let tier = (Math.log10(number) / 3) | 0;\n  let scaled = number;\n  let suffix = SI_SYMBOL[tier];\n  if (tier !== 0) {\n    let scale = Math.pow(10, tier * 3);\n    scaled = number / scale;\n  }\n\n  return scaled.toFixed(precision) + suffix;\n};\n\nexport const formatAmount = (\n  val: number,\n  precision: number = 2,\n  abbr: boolean = true,\n) => (abbr ? abbreviateNumber(val, precision) : val.toFixed(precision));\n\nexport function formatTokenAmount(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n  prefix = '',\n  suffix = '',\n  precision = 2,\n  abbr = false,\n): string {\n  if (!account) {\n    return '';\n  }\n\n  return `${[prefix]}${formatAmount(\n    fromLamports(account, mint, rate),\n    precision,\n    abbr,\n  )}${suffix}`;\n}\n\nexport const formatUSD = new Intl.NumberFormat('en-US', {\n  style: 'currency',\n  currency: 'USD',\n});\n\nconst numberFormater = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport const formatNumber = {\n  format: (val?: number) => {\n    if (!val) {\n      return '--';\n    }\n\n    return numberFormater.format(val);\n  },\n};\n\nexport const formatPct = new Intl.NumberFormat('en-US', {\n  style: 'percent',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport function convert(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  let result = (amount / precision) * rate;\n\n  return result;\n}\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n"],"sourceRoot":""}